 .gitignore                   |    3 -
 Changelog                    |   33 --
 Makefile.am                  |   48 +-
 README.md                    |    6 +-
 compare/README.md            |    5 +-
 compare/compare.c            |   70 +--
 compare/image.c              |    9 +-
 configure.ac                 |  159 ++----
 libass/ass.c                 |  278 ++-------
 libass/ass.h                 |   25 +-
 libass/ass_bitmap.c          |  262 +++++++--
 libass/ass_bitmap.h          |   88 ++-
 libass/ass_blur.c            |  407 ++++++++++++-
 libass/ass_cache.c           |   10 +-
 libass/ass_cache_template.h  |    3 +-
 libass/ass_drawing.c         |   24 +-
 libass/ass_font.c            |   92 ++-
 libass/ass_font.h            |    3 +-
 libass/ass_fontselect.c      |   25 +-
 libass/ass_fontselect.h      |    2 +-
 libass/ass_library.c         |    7 -
 libass/ass_library.h         |    2 +-
 libass/ass_outline.c         |   86 +--
 libass/ass_outline.h         |   44 +-
 libass/ass_parse.c           |  579 ++++++++-----------
 libass/ass_parse.h           |   20 +-
 libass/ass_priv.h            |    5 +-
 libass/ass_rasterizer.c      |   16 +-
 libass/ass_rasterizer.h      |   14 +-
 libass/ass_render.c          | 1303 ++++++++++++++++++------------------------
 libass/ass_render.h          |   64 +--
 libass/ass_render_api.c      |   25 +-
 libass/ass_shaper.c          |   70 +--
 libass/ass_shaper.h          |    6 +-
 libass/ass_types.h           |   90 +--
 libass/ass_utils.c           |  251 +++++++-
 libass/ass_utils.h           |   54 +-
 libass/c/c_be_blur.c         |    2 +-
 libass/c/c_blend_bitmaps.c   |    4 +-
 libass/c/c_blur.c            |    2 +-
 libass/c/c_rasterizer.c      |    4 +-
 libass/x86/be_blur.asm       |    6 +-
 libass/x86/blend_bitmaps.asm |   20 +-
 libass/x86/blur.asm          |  160 +++---
 libass/x86/rasterizer.asm    |    3 -
 45 files changed, 2216 insertions(+), 2173 deletions(-)

diff --git a/.gitignore b/.gitignore
index 8135f28..1af81c0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -21,8 +21,6 @@ Makefile.in
 /test/test
 /compare/compare
 /profile/profile
-/fuzz/fuzz
-/checkasm/checkasm
 
 # pkgconfig
 /libass.pc
@@ -39,4 +37,3 @@ Makefile.in
 /ltmain.sh
 /missing
 /m4
-/test-driver
diff --git a/Changelog b/Changelog
index 2b5f2c1..8130524 100644
--- a/Changelog
+++ b/Changelog
@@ -1,36 +1,3 @@
-libass (0.17.1)
- * Fix buffer overread if soft-wrapping occurred and
-   ASS_FEATURE_WHOLE_TEXT_LAYOUT was enabled via API or due to Encoding -1
-   (bug introduced in 0.16.0)
- * x86: detect GNU Hurd and configure NASM appropriately
-
-libass (0.17.0)
- * Fix various parts relating to automatic linebreaking
- * Fix rendering when hinting was enabled and fontsizes or scales are zero
- * Switch build to a non-recursive setup for improved parallelism
- * Improve quality of SSA Effects movement
- * Further documentation improvements
- * Completely invalid Events are now discarded during parsing
-
- * Introduction of LayoutRes{X,Y} script headers
- * New AlphaLevel style override to set all alpha values while keeping the color
- * Add ASS_FEATURE_WRAP_UNICODE to allow automatic linebreaks in accordance
-   with the Unicode line breaking algorithm instead of ASS' much stricter
-   breaking rules. For the feature to be available at runtime, libass must be
-   linked against the new optional dependency libunibreak.
-
- * Improve VSFilter compatibility:
-   * Fix premature truncation of animated alphas (was a 0.15.0 regression)
-   * Fix handling of small delay parameters for legacy SSA Effects
-   * Fix x-scaling with PlayResX
-   * Fix x-scaling for anamorphic video
-     (except for \be whose scaling remains buggy in general)
-   * Support SSA's AlphaLevel style field
-   * Support the \kt override tag from VSFilter's v4++ set
-   * Parse ScriptType headers
-   * Parse integer header, style and event field values like VSFilter
-   * Ignore trailing whitespace in an event's text
-
 libass (0.16.0)
  * Fix missing `-framework` options in libass.pc on macOS
  * Fix missing GDI or DirectWrite options in libass.pc on Win32
diff --git a/Makefile.am b/Makefile.am
index 52f99f1..3506e98 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -1,48 +1,20 @@
 ACLOCAL_AMFLAGS = -I m4
-AM_CPPFLAGS = -I$(top_srcdir)/libass
-AM_CFLAGS = -std=gnu99 -Wall -Wextra -Wno-sign-compare -Wno-unused-parameter \
-            -Werror-implicit-function-declaration -Wstrict-prototypes        \
-            -Wpointer-arith -Wredundant-decls -Wno-missing-field-initializers\
-            -D_GNU_SOURCE
-
 EXTRA_DIST = libass.pc.in Changelog MAINTAINERS ltnasm.sh
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = libass.pc
 
-nasm_verbose = $(nasm_verbose_$(V))
-nasm_verbose_ = $(nasm_verbose_$(AM_DEFAULT_VERBOSITY))
-nasm_verbose_0 = @echo "  NASM    " $@;
-
-lib_LTLIBRARIES =
-noinst_PROGRAMS =
-check_PROGRAMS =
-TESTS =
-
-include libass/Makefile_library.am
-include Makefile_util.am
-
-# Tests
-if ENABLE_FUZZ
-check: check-art-fuzz
-.PHONY: check-art-fuzz
-check-art-fuzz: fuzz/fuzz
-	@if [ -z '$(ART_SAMPLES)' ] ; then \
-		echo "ART_SAMPLES location not set; cannot run regression tests!"; \
-	else \
-		cd '$(ART_SAMPLES)'/crash/ ; \
-		./run-all.sh '$(abs_top_builddir)'/fuzz/fuzz ; \
-	fi
+if ENABLE_TEST
+    test = test
 endif
 
 if ENABLE_COMPARE
-check: check-art-compare
-.PHONY: check-art-compare
-check-art-compare: compare/compare
-	@if [ -z '$(ART_SAMPLES)' ] ; then \
-		echo "ART_SAMPLES location not set; cannot run regression tests!"; \
-	else \
-		cd '$(ART_SAMPLES)'/regression/ ; \
-		./run-all.sh '$(abs_top_builddir)'/compare/compare ; \
-	fi
+    compare = compare
 endif
+
+if ENABLE_PROFILE
+    profile = profile
+endif
+
+SUBDIRS = libass $(test) $(compare) $(profile)
+
diff --git a/README.md b/README.md
index a4b017c..0e5bf9d 100644
--- a/README.md
+++ b/README.md
@@ -8,7 +8,7 @@ libass is a portable subtitle renderer for the ASS/SSA (Advanced Substation Alph
 
 Get it
 ======
-See [GitHub releases](https://github.com/libass/libass/releases) for the latest release 0.17.1 (released 2023-02-26).
+See [GitHub releases](https://github.com/libass/libass/releases) for the latest release 0.16.0 (released 2022-05-12).
 See the [changelog](https://github.com/libass/libass/blob/master/Changelog) for a detailed list of changes.
 
 Source code is available from our [GitHub repository](https://github.com/libass/libass).
@@ -43,7 +43,7 @@ The following projects/companies use libass:
 
 Information about the ASS format:
 =================================
-- [ASS format overview (incomplete and partially incorrect)](http://moodub.free.fr/video/ass-specs.doc)
+- [ASS specification (incomplete)](http://moodub.free.fr/video/ass-specs.doc)
 - [ASS override tags (Aegisub manual)](http://docs.aegisub.org/latest/ASS_Tags/)
 - [VSFilter source code (Guliverkli2)](http://sourceforge.net/p/guliverkli2/code/HEAD/tree/src/subtitles/)
 
@@ -60,6 +60,6 @@ Other ASS/SSA implementations:
   - VSFilter in [guliverkli](http://sourceforge.net/projects/guliverkli/) (defunct, forked as Guliverkli2)
 - [ffdshow](http://ffdshow-tryout.sourceforge.net/) (defunct)
 - [Perian](https://github.com/MaddTheSane/perian) (defunct)
-- [asa](https://web.archive.org/web/20110906033709/http://asa.diac24.net/) (defunct)
+- [asa](http://git.spaceboyz.net/asa.git) (defunct)
 - [libjass](https://github.com/Arnavion/libjass) (defunct)
 - [ASS.js](https://github.com/weizhenye/ASS)
diff --git a/compare/README.md b/compare/README.md
index d0d7bd9..2586f43 100644
--- a/compare/README.md
+++ b/compare/README.md
@@ -5,12 +5,11 @@ To build a test utility configure libass with the `--enable-compare` flag.
 The utility works with `png` image files so there is external dependency of libpng.
 
 Test program command line:  
-`compare ([-i] <input-dir>)+ [-o <output-dir>] [-s <scale:1-8>[x<scale:1-8>]] [-p <pass-level:0-3>]`
+`compare ([-i] <input-dir>)+ [-o <output-dir>] [-s <scale:1-8>] [-p <pass-level:0-3>]`
 
 * `<input-dir>` is a test input directory, can be several of them;
 * `<output-dir>` if present sets directory to store the rendering results;
-* `<scale>` sets factors for horizontal and vertical oversampling (positive integers up to 8)
-  or a single factor to be used in both directions (default 1);
+* `<scale>` sets an oversampling factor (positive integer up to 8, default 1);
 * `<pass-level>` corresponds to the level of image differences required to pass test:
   - 0: only `SAME` level accepted, bitwise comparison mode;
   - 1: `GOOD` level or less required;
diff --git a/compare/compare.c b/compare/compare.c
index cb6680b..3cb3cff 100644
--- a/compare/compare.c
+++ b/compare/compare.c
@@ -171,11 +171,11 @@ static int compare1(const Image16 *target, const uint16_t *grad,
 
 static int compare(const Image16 *target, const uint16_t *grad,
                    const ASS_Image *img, const char *path,
-                   double *result, int scale_x, int scale_y)
+                   double *result, int scale)
 {
-    if (scale_x == 1 && scale_y == 1)
+    if (scale == 1)
         return compare1(target, grad, img, path, result);
-    int scale_area = scale_x * scale_y;
+    int scale2 = scale * scale;
 
     Image16 frame;
     frame.width  = target->width;
@@ -186,9 +186,9 @@ static int compare(const Image16 *target, const uint16_t *grad,
         return 0;
 
     Image8 temp;
-    temp.width  = scale_x * target->width;
-    temp.height = scale_y * target->height;
-    temp.buffer = malloc(4 * scale_area * size);
+    temp.width  = scale * target->width;
+    temp.height = scale * target->height;
+    temp.buffer = malloc(4 * scale2 * size);
     if (!temp.buffer) {
         free(frame.buffer);
         return 0;
@@ -198,24 +198,24 @@ static int compare(const Image16 *target, const uint16_t *grad,
     uint16_t *dst = frame.buffer;
     const uint8_t *src = temp.buffer;
     int32_t stride = 4 * temp.width;
-    const uint32_t offs = ((uint32_t) 1 << 19) - 1;
-    uint32_t mul = ((uint32_t) 257 << 20) / scale_area;
+    const uint32_t offs = ((uint32_t) 1 << 18) - 1;
+    uint32_t mul = ((uint32_t) 257 << 19) / scale2;
     for (int32_t y = 0; y < frame.height; y++) {
         for (int32_t x = 0; x < frame.width; x++) {
             uint16_t res[4] = {0};
             const uint8_t *ptr = src;
-            for (int i = 0; i < scale_y; i++) {
-                for (int j = 0; j < scale_x; j++)
+            for (int i = 0; i < scale; i++) {
+                for (int j = 0; j < scale; j++)
                     for (int k = 0; k < 4; k++)
                         res[k] += ptr[4 * j + k];
                 ptr += stride;
             }
             for (int k = 0; k < 4; k++)
-                // equivalent to (257 * res[k] + (scale_area - 1) / 2) / scale_area;
-                *dst++ = (res[k] * (uint64_t) mul + offs) >> 20;
-            src += 4 * scale_x;
+                // equivalent to (257 * res[k] + (scale2 - 1) / 2) / scale2;
+                *dst++ = (res[k] * (uint64_t) mul + offs) >> 19;
+            src += 4 * scale;
         }
-        src += (scale_y - 1) * stride;
+        src += (scale - 1) * stride;
     }
 
     free(temp.buffer);
@@ -323,8 +323,7 @@ Result classify_result(double error)
 
 static Result process_image(ASS_Renderer *renderer, ASS_Track *track,
                             const char *input, const char *output,
-                            const char *file, int64_t time,
-                            int scale_x, int scale_y)
+                            const char *file, int64_t time, int scale)
 {
     uint64_t tm = time;
     unsigned msec = tm % 1000;  tm /= 1000;
@@ -350,7 +349,7 @@ static Result process_image(ASS_Renderer *renderer, ASS_Track *track,
     calc_grad(&target, grad);
 
     ass_set_storage_size(renderer, target.width, target.height);
-    ass_set_frame_size(renderer, scale_x * target.width, scale_y * target.height);
+    ass_set_frame_size(renderer, scale * target.width, scale * target.height);
     ASS_Image *img = ass_render_frame(renderer, track, time, NULL);
 
     const char *out_file = NULL;
@@ -359,7 +358,7 @@ static Result process_image(ASS_Renderer *renderer, ASS_Track *track,
         out_file = path;
     }
     double max_err;
-    int res = compare(&target, grad, img, out_file, &max_err, scale_x, scale_y);
+    int res = compare(&target, grad, img, out_file, &max_err, scale);
     free(target.buffer);
     free(grad);
     if (!res) {
@@ -570,26 +569,11 @@ static int *parse_cmdline(int argc, char *argv[])
 fail:
     free(pos);
     const char *fmt =
-        "Usage: %s ([-i] <input-dir>)+ [-o <output-dir>] [-s <scale:1-8>[x<scale:1-8>]] [-p <pass-level:0-3>]\n"
-        "\n"
-        "Scale can be a single uniform scaling factor or a pair of independent horizontal and vertical factors. -s N is equivalent to -s NxN.\n";
+        "Usage: %s ([-i] <input-dir>)+ [-o <output-dir>] [-s <scale:1-8>] [-p <pass-level:0-3>]\n";
     printf(fmt, argv[0] ? argv[0] : "compare");
     return NULL;
 }
 
-static bool parse_scale(const char *arg,  int *scale_x, int *scale_y)
-{
-    if (arg[0] < '1' || arg[0] > '8')
-        return false;
-    *scale_x = *scale_y = arg[0] - '0';
-    if (!arg[1])
-        return true;
-    if (arg[1] != 'x' || arg[2] < '1' || arg[2] > '8' || arg[3])
-        return false;
-    *scale_y = arg[2] - '0';
-    return true;
-}
-
 void msg_callback(int level, const char *fmt, va_list va, void *data)
 {
     if (level > 3)
@@ -609,10 +593,14 @@ int main(int argc, char *argv[])
     ItemList list = {0};
     int result = R_ERROR;
 
-    int scale_x = 1, scale_y = 1;
-    if (pos[SCALE] && !parse_scale(argv[pos[SCALE]], &scale_x, &scale_y)) {
-        printf("Invalid scale value, should be 1-8[x1-8]!\n");
-        goto end;
+    int scale = 1;
+    if (pos[SCALE]) {
+        const char *arg = argv[pos[SCALE]];
+        if (arg[0] < '1' || arg[0] > '8' || arg[1]) {
+            printf("Invalid scale value, should be 1-8!\n");
+            goto end;
+        }
+        scale = arg[0] - '0';
     }
 
     int level = R_BAD;
@@ -665,8 +653,7 @@ int main(int argc, char *argv[])
     const char *prev = "";
     ASS_Track *track = NULL;
     unsigned total = 0, good = 0;
-    if (list.n_items)
-        qsort(list.items, list.n_items, sizeof(Item), item_compare);
+    qsort(list.items, list.n_items, sizeof(Item), item_compare);
     for (size_t i = 0; i < list.n_items; i++) {
         char *name = list.items[i].name;
         size_t len = list.items[i].prefix;
@@ -692,8 +679,7 @@ int main(int argc, char *argv[])
         if (!track)
             continue;
         Result res = process_image(renderer, track, list.items[i].dir, output,
-                                   name, list.items[i].time,
-                                   scale_x, scale_y);
+                                   name, list.items[i].time, scale);
         result = FFMAX(result, res);
         if (res <= level)
             good++;
diff --git a/compare/image.c b/compare/image.c
index b9648ef..5263b93 100644
--- a/compare/image.c
+++ b/compare/image.c
@@ -20,11 +20,6 @@
 #include <png.h>
 
 
-static inline bool is_little_endian(void)
-{
-    return *(char *) &(uint16_t) {1};
-}
-
 bool read_png(const char *path, Image16 *img)
 {
     FILE *fp = fopen(path, "rb");
@@ -84,7 +79,7 @@ bool read_png(const char *path, Image16 *img)
     ptrdiff_t half = 4 * w;
     if (depth == 8)
         ptr += half;
-    else if (is_little_endian())
+    else
         png_set_swap(png);
 
     for (uint32_t i = 0; i < h; i++) {
@@ -191,7 +186,7 @@ static bool write_png(const char *path, uint32_t width, uint32_t height,
                  PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
     png_write_info(png, info);
 
-    if (depth > 8 && is_little_endian())
+    if (depth > 8)
         png_set_swap(png);
     png_write_image(png, rows);
     png_write_end(png, NULL);
diff --git a/configure.ac b/configure.ac
index 012478a..afac0ef 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1,6 +1,8 @@
-AC_INIT(libass, 0.17.1)
-AM_INIT_AUTOMAKE([foreign subdir-objects])
+AC_INIT(libass, 0.16.0)
+AM_INIT_AUTOMAKE([foreign])
 AC_CONFIG_MACRO_DIR([m4])
+# Disable Fortran checks
+define([AC_LIBTOOL_LANG_F77_CONFIG], [:])
 LT_INIT
 AC_CONFIG_SRCDIR([libass/ass.c])
 AC_CONFIG_HEADERS([config.h])
@@ -8,7 +10,6 @@ AC_CONFIG_HEADERS([config.h])
 # Checks for programs.
 AC_PROG_CC
 AM_PROG_CC_C_O
-AM_PROG_AS
 
 # Checks for header files.
 AC_CHECK_HEADERS_ONCE([iconv.h])
@@ -23,16 +24,12 @@ AC_ARG_ENABLE([compare], AS_HELP_STRING([--enable-compare],
     [enable compare program (requires libpng) @<:@default=no@:>@]))
 AC_ARG_ENABLE([profile], AS_HELP_STRING([--enable-profile],
     [enable profiling program @<:@default=no@:>@]))
-AC_ARG_ENABLE([fuzz], AS_HELP_STRING([--enable-fuzz],
-    [enable fuzzing consumer @<:@default=no@:>@]))
 AC_ARG_ENABLE([fontconfig], AS_HELP_STRING([--disable-fontconfig],
     [disable fontconfig support @<:@default=check@:>@]))
 AC_ARG_ENABLE([directwrite], AS_HELP_STRING([--disable-directwrite],
     [disable DirectWrite support (Windows only) @<:@default=check@:>@]))
 AC_ARG_ENABLE([coretext], AS_HELP_STRING([--disable-coretext],
     [disable CoreText support (OSX only) @<:@default=check@:>@]))
-AC_ARG_ENABLE([libunibreak], AS_HELP_STRING([--disable-libunibreak],
-    [disable libunibreak support @<:@default=check@:>@]))
 AC_ARG_ENABLE([require-system-font-provider], AS_HELP_STRING([--disable-require-system-font-provider],
     [allow compilation even if no system font provider was found @<:@default=enabled:>@]))
 AC_ARG_ENABLE([asm], AS_HELP_STRING([--disable-asm],
@@ -40,14 +37,6 @@ AC_ARG_ENABLE([asm], AS_HELP_STRING([--disable-asm],
 AC_ARG_ENABLE([large-tiles], AS_HELP_STRING([--enable-large-tiles],
     [use larger tiles in the rasterizer (better performance, slightly worse quality) @<:@default=disabled@:>@]))
 
-AC_ARG_VAR([ART_SAMPLES],
-    [Path to the root of libass' regression testing sample repository. If set, it is used in make check.])
-AC_ARG_VAR([FUZZ_LDFLAGS],
-    [Optional special linking flags only used for the fuzzer binary.])
-AC_ARG_VAR([FUZZ_CPPFLAGS],
-    [If fuzzing program is enabled, set this to select alternative modes; see fuzzer source for options.])
-FUZZ_CPPFLAGS="${FUZZ_CPPFLAGS:--DASS_FUZZMODE=0}"
-
 # Checks for available libraries and define corresponding C Macros
 # Start with system libs, then check everything else via pkg-config
 AS_IF([test "x$ac_cv_header_iconv_h" = xyes], [
@@ -107,19 +96,6 @@ AS_IF([test "x$enable_test" = xyes || test "x$enable_compare" = xyes], [
     ])
 ])
 
-AS_IF([test "x$enable_libunibreak" != xno], [
-    PKG_CHECK_MODULES([LIBUNIBREAK], [libunibreak >= 1.1], [
-        pkg_requires="libunibreak >= 1.1, ${pkg_requires}"
-        CFLAGS="$CFLAGS $LIBUNIBREAK_CFLAGS"
-        LIBS="$LIBS $LIBUNIBREAK_LIBS"
-        AC_DEFINE(CONFIG_UNIBREAK, 1, [found libunibreak via pkg-config])
-    ], [
-        AS_IF([test "x$enable_libunibreak" = xyes], [
-            AC_MSG_ERROR([libunibreak support was requested, but it was not found.])
-        ])
-    ])
-])
-
 ## Check for system font providers
 ### Fontconfig
 AS_IF([test "x$enable_fontconfig" != xno], [
@@ -235,96 +211,83 @@ AS_IF([test "x$enable_require_system_font_provider" != xno  dnl
 
 # Locate and configure Assembler appropriately
 can_asm=false
-cpu_family="other"
 AS_IF([test "x$enable_asm" != xno], [
     AS_CASE([$host],
         [i?86-*], [
             AS=nasm
-            cpu_family="x86"
+            X86=true
             BITS=32
             BITTYPE=32
             ASFLAGS="$ASFLAGS -DARCH_X86_64=0"
         ],
         [x86_64-*-gnux32|amd64-*-gnux32], [
             AS=nasm
-            cpu_family="x86"
+            X86=true
+            X86_64=true
             BITS=64
             BITTYPE=x32
             ASFLAGS="$ASFLAGS -DARCH_X86_64=1"
         ],
         [x86_64-*|amd64-*], [
             AS=nasm
-            cpu_family="x86"
+            X86=true
+            X86_64=true
             BITS=64
             BITTYPE=64
             ASFLAGS="$ASFLAGS -DARCH_X86_64=1"
         ],
-        [aarch64-*|aarch64_be-*], [
-            cpu_family="arm64"
-            BITS=64
-            BITTYPE=64
-        ],
         [ # default
+            X86=false
             AC_MSG_NOTICE([Assembly optimizations are not yet supported on this architecture; disabling.])
         ]
     )
-    AS_CASE([$cpu_family],
-        [x86], [
-            AC_CHECK_PROG([nasm_check], [$AS], [yes])
-            AS_IF([test "x$nasm_check" != xyes], [
-                AC_MSG_WARN(nasm was not found; ASM functions are disabled.)
-                AC_MSG_WARN(Install nasm for a significantly faster libass build.)
-            ], [
-                AS_CASE([$host_os],
-                    [darwin*], [
-                        ASFLAGS="$ASFLAGS -f macho$BITTYPE -DPREFIX -DSTACK_ALIGNMENT=16"
-                    ],
-                    [cygwin*|mingw*], [
-                        ASFLAGS="$ASFLAGS -f win$BITTYPE"
-                        AS_IF([test "x$BITS" = x32], [
-                            ASFLAGS="$ASFLAGS -DPREFIX"
-                        ])
-                    ],
-                    [linux*|solaris*|haiku*|gnu*], [
-                        ASFLAGS="$ASFLAGS -f elf$BITTYPE -DSTACK_ALIGNMENT=16"
-                    ],
-                    [dragonfly*|*bsd*], [
-                        ASFLAGS="$ASFLAGS -f elf$BITTYPE"
-                    ],
-                    [ # default
-                        AC_MSG_ERROR(m4_text_wrap(m4_normalize([
-                                Please contact libass upstream to figure out if ASM
-                                support for your platform can be added.
-                                In the meantime you will need to use --disable-asm.]),
-                            [                  ],
-                            [could not identify NASM format for $host_os !],
-                            [78]
-                        ))
-                    ]
-                )
-                AC_MSG_CHECKING([if $AS supports vpmovzxwd])
-                echo "vpmovzxwd ymm0, xmm0" > conftest.asm
-                AS_IF([$AS conftest.asm $ASFLAGS -o conftest.o >conftest.log 2>&1], [
-                    AC_MSG_RESULT([yes])
-                    can_asm=true
-                ], [
-                    AC_MSG_RESULT([no])
-                    VER=`($AS --version || echo no assembler) 2>/dev/null | head -n 1`
-                    AC_MSG_WARN([nasm is too old (found $VER); ASM functions are disabled.])
-                    AC_MSG_WARN([Install nasm-2.10 or later for a significantly faster libass build.])
-                ])
-                rm conftest.asm conftest.o > /dev/null 2>&1
-            ])
-        ],
-        [arm64], [
+    AS_IF([test "x$X86" = xtrue], [
+        AC_CHECK_PROG([nasm_check], [$AS], [yes])
+        AS_IF([test "x$nasm_check" != xyes], [
+            AC_MSG_WARN(nasm was not found; ASM functions are disabled.)
+            AC_MSG_WARN(Install nasm for a significantly faster libass build.)
+        ], [
             AS_CASE([$host],
                 [*darwin*], [
-                    CCASFLAGS="$CCASFLAGS -DPREFIX"
+                    ASFLAGS="$ASFLAGS -f macho$BITTYPE -DPREFIX -DSTACK_ALIGNMENT=16"
+                ],
+                [*linux*|*solaris*|*haiku*], [
+                    ASFLAGS="$ASFLAGS -f elf$BITTYPE -DSTACK_ALIGNMENT=16"
+                ],
+                [*dragonfly*|*bsd*], [
+                    ASFLAGS="$ASFLAGS -f elf$BITTYPE"
+                ],
+                [*cygwin*|*mingw*], [
+                    ASFLAGS="$ASFLAGS -f win$BITTYPE"
+                    AS_IF([test "x$BITS" = x32], [
+                        ASFLAGS="$ASFLAGS -DPREFIX"
+                    ])
+                ],
+                [ # default
+                    AC_MSG_ERROR(m4_text_wrap(m4_normalize([
+                            Please contact libass upstream to figure out if ASM
+                            support for your platform can be added.
+                            In the meantime you will need to use --disable-asm.]),
+                        [                  ],
+                        [could not identify NASM format for $host !],
+                        [78]
+                    ))
                 ]
             )
-            can_asm=true
-        ]
-    )
+            AC_MSG_CHECKING([if $AS supports vpmovzxwd])
+            echo "vpmovzxwd ymm0, xmm0" > conftest.asm
+            AS_IF([$AS conftest.asm $ASFLAGS -o conftest.o >conftest.log 2>&1], [
+                AC_MSG_RESULT([yes])
+                can_asm=true
+            ], [
+                AC_MSG_RESULT([no])
+                VER=`($AS --version || echo no assembler) 2>/dev/null | head -n 1`
+                AC_MSG_WARN([nasm is too old (found $VER); ASM functions are disabled.])
+                AC_MSG_WARN([Install nasm-2.10 or later for a significantly faster libass build.])
+            ])
+            rm conftest.asm conftest.o > /dev/null 2>&1
+        ])
+    ])
 ])
 
 AS_IF([test x"$enable_asm" = xyes && test x"$can_asm" != xtrue], [
@@ -354,18 +317,14 @@ AS_IF([test "x$enable_shared" != xno], [
 
 ## Setup conditionals for use in Makefiles
 AM_CONDITIONAL([ASM], [test "x$can_asm" = xtrue])
-AM_CONDITIONAL([X86], [test "x$cpu_family" = xx86])
-AM_CONDITIONAL([X86_64], [test "x$cpu_family" = xx86 && test "x$BITS" = x64])
-AM_CONDITIONAL([AARCH64], [test "x$cpu_family" = xarm64])
+AM_CONDITIONAL([X86], [test "x$X86" = xtrue])
+AM_CONDITIONAL([X86_64], [test "x$X86_64" = xtrue])
 
 AM_CONDITIONAL([ENABLE_LARGE_TILES], [test "x$enable_large_tiles" = xyes])
 
 AM_CONDITIONAL([ENABLE_COMPARE], [test "x$enable_compare" = xyes && test "x$libpng" = xtrue])
 AM_CONDITIONAL([ENABLE_TEST], [test "x$enable_test" = xyes && test "x$libpng" = xtrue])
 AM_CONDITIONAL([ENABLE_PROFILE], [test "x$enable_profile" = xyes])
-AM_CONDITIONAL([ENABLE_FUZZ], [test "x$enable_fuzz" = xyes])
-# tcc doesn't have the full support of __attribute__((aligned(32)))
-AM_CONDITIONAL([ENABLE_CHECKASM], [test "x$can_asm" = xtrue && test "x$GCC" = xyes])
 
 AM_CONDITIONAL([FONTCONFIG], [test "x$fontconfig" = xtrue])
 AM_CONDITIONAL([CORETEXT], [test "x$coretext" = xtrue])
@@ -377,12 +336,6 @@ AM_COND_IF([ASM], [
     AM_COND_IF([X86], [
         AC_DEFINE(ARCH_X86, 1, [targeting a 32- or 64-bit x86 host architecture])
     ])
-    AM_COND_IF([X86_64], [
-        AC_DEFINE(ARCH_X86_64, 1, [targeting a 64-bit x86 host architecture])
-    ])
-    AM_COND_IF([AARCH64], [
-        AC_DEFINE(ARCH_AARCH64, 1, [targeting a 64-bit arm host architecture])
-    ])
 ], [
     AC_DEFINE(CONFIG_ASM, 0, [ASM enabled])
 ])
@@ -414,5 +367,5 @@ AC_DEFINE_UNQUOTED([CONFIG_SOURCEVERSION], ["$srcversion_string"],
 ## Setup output beautifier.
 m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
 
-AC_CONFIG_FILES([Makefile libass.pc])
+AC_CONFIG_FILES([Makefile libass/Makefile test/Makefile compare/Makefile profile/Makefile libass.pc])
 AC_OUTPUT
diff --git a/libass/ass.c b/libass/ass.c
index 0679483..991d31b 100644
--- a/libass/ass.c
+++ b/libass/ass.c
@@ -239,138 +239,9 @@ static long long string2timecode(ASS_Library *library, char *p)
     return tm;
 }
 
-static int read_digits(char **str, unsigned base, uint32_t *res)
-{
-    char *p = *str;
-    char *start = p;
-    uint32_t val = 0;
-
-    while (1) {
-        unsigned digit;
-        if (*p >= '0' && *p < FFMIN(base, 10) + '0')
-            digit = *p - '0';
-        else if (*p >= 'a' && *p < base - 10 + 'a')
-            digit = *p - 'a' + 10;
-        else if (*p >= 'A' && *p < base - 10 + 'A')
-            digit = *p - 'A' + 10;
-        else
-            break;
-        val = val * base + digit;
-        ++p;
-    }
-
-    *res = val;
-    *str = p;
-    return p != start;
-}
-
-/**
- * \brief Convert a string to an integer reduced modulo 2**32
- * Follows the rules for strtoul but reduces the number modulo 2**32
- * instead of saturating it to 2**32 - 1.
- */
-static int mystrtou32_modulo(char **p, unsigned base, uint32_t *res)
-{
-    // This emulates scanf with %d or %x format as it works on
-    // Windows, because that's what is used by VSFilter. In practice,
-    // scanf works the same way on other platforms too, but
-    // the standard leaves its behavior on overflow undefined.
-
-    // Unlike scanf and like strtoul, produce 0 for invalid inputs.
-
-    char *start = *p;
-    int sign = 1;
-
-    skip_spaces(p);
-
-    if (**p == '+')
-        ++*p;
-    else if (**p == '-')
-        sign = -1, ++*p;
-
-    if (base == 16 && !ass_strncasecmp(*p, "0x", 2))
-        *p += 2;
-
-    if (read_digits(p, base, res)) {
-        *res *= sign;
-        return 1;
-    } else {
-        *p = start;
-        return 0;
-    }
-}
-
-static int32_t parse_int_header(char *str)
-{
-    uint32_t val = 0;
-    unsigned base;
-
-    if (!ass_strncasecmp(str, "&h", 2) || !ass_strncasecmp(str, "0x", 2)) {
-        str += 2;
-        base = 16;
-    } else
-        base = 10;
-
-    mystrtou32_modulo(&str, base, &val);
-    return val;
-}
-
-static uint32_t parse_color_header(char *str)
-{
-    uint32_t color = parse_int_header(str);
-    return ass_bswap32(color);
-}
-
-// Return a boolean value for a string
-static char parse_bool(char *str)
-{
-    skip_spaces(&str);
-    return !ass_strncasecmp(str, "yes", 3) || strtol(str, NULL, 10) > 0;
-}
-
-static int parse_ycbcr_matrix(char *str)
-{
-    skip_spaces(&str);
-    if (*str == '\0')
-        return YCBCR_DEFAULT;
-
-    char *end = str + strlen(str);
-    rskip_spaces(&end, str);
-
-    // Trim a local copy of the input that we know is safe to
-    // modify. The buffer is larger than any valid string + NUL,
-    // so we can simply chop off the rest of the input.
-    char buffer[16];
-    size_t n = FFMIN(end - str, sizeof buffer - 1);
-    memcpy(buffer, str, n);
-    buffer[n] = '\0';
-
-    if (!ass_strcasecmp(buffer, "none"))
-        return YCBCR_NONE;
-    if (!ass_strcasecmp(buffer, "tv.601"))
-        return YCBCR_BT601_TV;
-    if (!ass_strcasecmp(buffer, "pc.601"))
-        return YCBCR_BT601_PC;
-    if (!ass_strcasecmp(buffer, "tv.709"))
-        return YCBCR_BT709_TV;
-    if (!ass_strcasecmp(buffer, "pc.709"))
-        return YCBCR_BT709_PC;
-    if (!ass_strcasecmp(buffer, "tv.240m"))
-        return YCBCR_SMPTE240M_TV;
-    if (!ass_strcasecmp(buffer, "pc.240m"))
-        return YCBCR_SMPTE240M_PC;
-    if (!ass_strcasecmp(buffer, "tv.fcc"))
-        return YCBCR_FCC_TV;
-    if (!ass_strcasecmp(buffer, "pc.fcc"))
-        return YCBCR_FCC_PC;
-    return YCBCR_UNKNOWN;
-}
-
-#define NEXT(str,token,rtrim) \
-    token = next_token(&str, rtrim); \
+#define NEXT(str,token) \
+    token = next_token(&str); \
     if (!token) break;
-#define NEXTNAME(str,token) NEXT(str, token, true)
-#define NEXTVAL(str,token) NEXT(str, token, false)
 
 
 #define ALIAS(alias,name) \
@@ -411,7 +282,7 @@ static int parse_ycbcr_matrix(char *str)
         }
 
 #define COLORVAL(name) ANYVAL(name,parse_color_header)
-#define INTVAL(name) ANYVAL(name,parse_int_header)
+#define INTVAL(name) ANYVAL(name,atoi)
 #define FPVAL(name) ANYVAL(name,ass_atof)
 #define TIMEVAL(name) \
     } else if (ass_strcasecmp(tname, #name) == 0) { \
@@ -419,7 +290,7 @@ static int parse_ycbcr_matrix(char *str)
 
 #define STYLEVAL(name) \
     } else if (ass_strcasecmp(tname, #name) == 0) { \
-        target->name = ass_lookup_style(track, token);
+        target->name = lookup_style(track, token);
 
 // skip spaces in str beforehand, or trim leading spaces afterwards
 static inline void advance_token_pos(const char **const str,
@@ -430,9 +301,10 @@ static inline void advance_token_pos(const char **const str,
     *end   = *start;
     while (**end != '\0' && **end != ',') ++*end;
     *str = *end + (**end == ',');
+    rskip_spaces((char**)end, (char*)*start);
 }
 
-static char *next_token(char **str, bool rtrim)
+static char *next_token(char **str)
 {
     char *p;
     char *start;
@@ -445,8 +317,6 @@ static char *next_token(char **str, bool rtrim)
                       (const char**)&start,
                       (const char**)&p);
 
-    if (rtrim)
-        rskip_spaces(&p, start);
     *p = '\0';
     return start;
 }
@@ -473,24 +343,24 @@ static int process_event_tail(ASS_Track *track, ASS_Event *event,
     char *q = format;           // format scanning pointer
 
     for (i = 0; i < n_ignored; ++i) {
-        NEXTVAL(q, tname);
+        NEXT(q, tname);
     }
 
     while (1) {
-        NEXTNAME(q, tname);
+        NEXT(q, tname);
         if (ass_strcasecmp(tname, "Text") == 0) {
+            char *last;
             event->Text = strdup(p);
             if (event->Text && *event->Text != 0) {
-                char *end = event->Text + strlen(event->Text);
-                while (end > event->Text &&
-                       (end[-1] == '\r' || end[-1] == '\t' || end[-1] == ' '))
-                    *--end = 0;
+                last = event->Text + strlen(event->Text) - 1;
+                if (last >= event->Text && *last == '\r')
+                    *last = 0;
             }
             event->Duration -= event->Start;
             free(format);
             return event->Text ? 0 : -1;           // "Text" is always the last
         }
-        NEXTVAL(p, token);
+        NEXT(p, token);
 
         ALIAS(End, Duration)    // temporarily store end timecode in event->Duration
         ALIAS(Actor, Name)      // both variants are used in files
@@ -510,16 +380,6 @@ static int process_event_tail(ASS_Track *track, ASS_Event *event,
     return 1;
 }
 
-static void set_style_alpha(ASS_Style *style, int32_t front_alpha, int32_t back_alpha)
-{
-        front_alpha  = FFMAX(FFMIN(front_alpha, 0xFF), 0);
-        back_alpha = FFMAX(FFMIN(back_alpha, 0xFF), 0);
-        style->PrimaryColour   = (style->PrimaryColour   & 0xFFFFFF00) | front_alpha;
-        style->SecondaryColour = (style->SecondaryColour & 0xFFFFFF00) | front_alpha;
-        style->OutlineColour   = (style->OutlineColour   & 0xFFFFFF00) | front_alpha;
-        style->BackColour      = (style->BackColour      & 0xFFFFFF00) | back_alpha;
-}
-
 /**
  * \brief Parse command line style overrides (--ass-force-style option)
  * \param track track to apply overrides to
@@ -543,17 +403,13 @@ void ass_process_force_style(ASS_Track *track)
         token = eq + 1;
 
         if (!ass_strcasecmp(*fs, "PlayResX"))
-            track->PlayResX = parse_int_header(token);
+            track->PlayResX = atoi(token);
         else if (!ass_strcasecmp(*fs, "PlayResY"))
-            track->PlayResY = parse_int_header(token);
-        else if (!ass_strcasecmp(*fs, "LayoutResX"))
-            track->LayoutResX = parse_int_header(token);
-        else if (!ass_strcasecmp(*fs, "LayoutResY"))
-            track->LayoutResY = parse_int_header(token);
+            track->PlayResY = atoi(token);
         else if (!ass_strcasecmp(*fs, "Timer"))
             track->Timer = ass_atof(token);
         else if (!ass_strcasecmp(*fs, "WrapStyle"))
-            track->WrapStyle = parse_int_header(token);
+            track->WrapStyle = atoi(token);
         else if (!ass_strcasecmp(*fs, "ScaledBorderAndShadow"))
             track->ScaledBorderAndShadow = parse_bool(token);
         else if (!ass_strcasecmp(*fs, "Kerning"))
@@ -580,9 +436,6 @@ void ass_process_force_style(ASS_Track *track)
                     COLORVAL(SecondaryColour)
                     COLORVAL(OutlineColour)
                     COLORVAL(BackColour)
-                    } else if (ass_strcasecmp(tname, "AlphaLevel") == 0) {
-                        int32_t alpha = parse_int_header(token);
-                        set_style_alpha(target, alpha, alpha);
                     FPVAL(FontSize)
                     INTVAL(Bold)
                     INTVAL(Italic)
@@ -659,11 +512,9 @@ static int process_style(ASS_Track *track, char *str)
     style->ScaleX = 100.;
     style->ScaleY = 100.;
 
-    int32_t ssa_alpha = 0;
-
     while (1) {
-        NEXTNAME(q, tname);
-        NEXTVAL(p, token);
+        NEXT(q, tname);
+        NEXT(p, token);
 
         PARSE_START
             STARREDSTRVAL(Name)
@@ -672,12 +523,10 @@ static int process_style(ASS_Track *track, char *str)
             COLORVAL(SecondaryColour)
             COLORVAL(OutlineColour) // TertiaryColor
             COLORVAL(BackColour)
-                // SSA uses BackColour for both outline and shadow
-                // this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
-                if (track->track_type == TRACK_TYPE_SSA)
-                    target->OutlineColour = target->BackColour;
-            } else if (ass_strcasecmp(tname, "AlphaLevel") == 0) {
-                ssa_alpha = parse_int_header(token);
+            // SSA uses BackColour for both outline and shadow
+            // this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
+            if (track->track_type == TRACK_TYPE_SSA)
+                target->OutlineColour = target->BackColour;
             FPVAL(FontSize)
             INTVAL(Bold)
             INTVAL(Italic)
@@ -687,13 +536,13 @@ static int process_style(ASS_Track *track, char *str)
             FPVAL(Angle)
             INTVAL(BorderStyle)
             INTVAL(Alignment)
-                if (track->track_type == TRACK_TYPE_ASS)
-                    target->Alignment = numpad2align(target->Alignment);
-                // VSFilter compatibility
-                else if (target->Alignment == 8)
-                    target->Alignment = 3;
-                else if (target->Alignment == 4)
-                    target->Alignment = 11;
+            if (track->track_type == TRACK_TYPE_ASS)
+                target->Alignment = numpad2align(target->Alignment);
+            // VSFilter compatibility
+            else if (target->Alignment == 8)
+                target->Alignment = 3;
+            else if (target->Alignment == 4)
+                target->Alignment = 11;
             INTVAL(MarginL)
             INTVAL(MarginR)
             INTVAL(MarginV)
@@ -705,9 +554,6 @@ static int process_style(ASS_Track *track, char *str)
         PARSE_END
     }
     free(format);
-    // VSF compat: always set BackColour Alpha to 0x80 in SSA
-    if (track->track_type == TRACK_TYPE_SSA)
-        set_style_alpha(style, ssa_alpha, 0x80);
     style->ScaleX = FFMAX(style->ScaleX, 0.) / 100.;
     style->ScaleY = FFMAX(style->ScaleY, 0.) / 100.;
     style->Spacing = FFMAX(style->Spacing, 0.);
@@ -753,8 +599,6 @@ static bool format_line_compare(const char *fmt1, const char *fmt2)
 
         advance_token_pos(&fmt1, &tk1_start, &tk1_end);
         advance_token_pos(&fmt2, &tk2_start, &tk2_end);
-        rskip_spaces((char**)&tk1_end, (char*)tk1_start);
-        rskip_spaces((char**)&tk2_end, (char*)tk2_start);
 
         TOKEN_ALIAS(Name, Actor)
         if ((tk1_end-tk1_start) != (tk2_end-tk2_start))
@@ -817,26 +661,6 @@ static int process_styles_line(ASS_Track *track, char *str)
     return ret;
 }
 
-static inline void parse_script_type(ASS_Track *track, const char *str)
-{
-    // VSF compat: don't check for leading 'v' and
-    // parse value from the last non-space backwards
-    const char *p = str + strlen(str);
-    rskip_spaces((char **) &p, (char *) str);
-    size_t len = p - str;
-    if (len < 4) // rskip_spaces stops _at_ last space
-        return;
-
-    int ver = TRACK_TYPE_SSA;
-    if (*(p-1) == '+') {
-        ver = TRACK_TYPE_ASS;
-        --len; --p;
-    }
-
-    if (len >= 4 && !strncmp(p-4, "4.00", 4))
-        track->track_type = ver;
-}
-
 static inline void check_duplicate_info_line(const ASS_Track *const track,
                                              const ScriptInfo si,
                                              const char *const name)
@@ -853,22 +677,16 @@ static int process_info_line(ASS_Track *track, char *str)
 {
     if (!strncmp(str, "PlayResX:", 9)) {
         check_duplicate_info_line(track, SINFO_PLAYRESX, "PlayResX");
-        track->PlayResX = parse_int_header(str + 9);
+        track->PlayResX = atoi(str + 9);
     } else if (!strncmp(str, "PlayResY:", 9)) {
         check_duplicate_info_line(track, SINFO_PLAYRESY, "PlayResY");
-        track->PlayResY = parse_int_header(str + 9);
-    } else if (!strncmp(str, "LayoutResX:", 11)) {
-        check_duplicate_info_line(track, SINFO_LAYOUTRESX, "LayoutResX");
-        track->LayoutResX = parse_int_header(str + 11);
-    } else if (!strncmp(str, "LayoutResY:", 11)) {
-        check_duplicate_info_line(track, SINFO_LAYOUTRESY, "LayoutResY");
-        track->LayoutResY = parse_int_header(str + 11);
+        track->PlayResY = atoi(str + 9);
     } else if (!strncmp(str, "Timer:", 6)) {
         check_duplicate_info_line(track, SINFO_TIMER, "Timer");
         track->Timer = ass_atof(str + 6);
     } else if (!strncmp(str, "WrapStyle:", 10)) {
         check_duplicate_info_line(track, SINFO_WRAPSTYLE, "WrapStyle");
-        track->WrapStyle = parse_int_header(str + 10);
+        track->WrapStyle = atoi(str + 10);
     } else if (!strncmp(str, "ScaledBorderAndShadow:", 22)) {
         check_duplicate_info_line(track, SINFO_SCALEDBORDER,
                                     "ScaledBorderAndShadow");
@@ -885,9 +703,6 @@ static int process_info_line(ASS_Track *track, char *str)
         while (*p && ass_isspace(*p)) p++;
         free(track->Language);
         track->Language = strndup(p, 2);
-    } else if (!strncmp(str, "ScriptType:", 11)) {
-        check_duplicate_info_line(track, SINFO_SCRIPTTYPE, "ScriptType");
-        parse_script_type(track, str + 11);
     } else if (!strncmp(str, "; Script generated by ", 22)) {
         if (!strncmp(str + 22,"FFmpeg/Lavc", 11))
             track->parser_priv->header_flags |= GENBY_FFMPEG;
@@ -948,8 +763,9 @@ static bool detect_legacy_conv_subs(ASS_Track *track)
      */
 
     // GENBY_FFMPEG and exact ffmpeg headers required
+    // Note: If there's SINFO_SCRIPTTYPE in the future this needs to be updated
     if (track->parser_priv->header_flags
-            != (SINFO_SCRIPTTYPE | SINFO_PLAYRESX | SINFO_PLAYRESY | GENBY_FFMPEG))
+            ^ (SINFO_PLAYRESX | SINFO_PLAYRESY | GENBY_FFMPEG))
         return false;
 
     // Legacy ffmpeg only ever has one style
@@ -1006,13 +822,7 @@ static int process_events_line(ASS_Track *track, char *str)
             return -1;
         event = track->events + eid;
 
-        int ret = process_event_tail(track, event, str, 0);
-        if (!ret)
-            return 0;
-        // If something went wrong, discard the useless Event
-        ass_free_event(track, eid);
-        track->n_events--;
-        return ret;
+        return process_event_tail(track, event, str, 0);
     } else {
         ass_msg(track->library, MSGL_V, "Not understood: '%.30s'", str);
     }
@@ -1307,16 +1117,15 @@ void ass_process_chunk(ASS_Track *track, char *data, int size,
     p = str;
 
     do {
-        NEXTVAL(p, token);
+        NEXT(p, token);
         event->ReadOrder = atoi(token);
         if (check_readorder && check_duplicate_event(track, event->ReadOrder))
             break;
 
-        NEXTVAL(p, token);
-        event->Layer = parse_int_header(token);
+        NEXT(p, token);
+        event->Layer = atoi(token);
 
-        if (process_event_tail(track, event, p, 3))
-            break;
+        process_event_tail(track, event, p, 3);
 
         event->Start = timecode;
         event->Duration = duration;
@@ -1435,7 +1244,7 @@ out:
  * \param bufsize out: file size
  * \return pointer to file contents. Caller is responsible for its deallocation.
  */
-char *ass_load_file(ASS_Library *library, const char *fname, FileNameSource hint, size_t *bufsize)
+char *read_file(ASS_Library *library, const char *fname, FileNameSource hint, size_t *bufsize)
 {
     int res;
     long sz;
@@ -1567,7 +1376,7 @@ static char *read_file_recode(ASS_Library *library, char *fname,
     char *buf;
     size_t bufsize;
 
-    buf = ass_load_file(library, fname, FN_EXTERNAL, &bufsize);
+    buf = read_file(library, fname, FN_EXTERNAL, &bufsize);
     if (!buf)
         return 0;
 #ifdef CONFIG_ICONV
@@ -1623,7 +1432,7 @@ int ass_read_styles(ASS_Track *track, char *fname, char *codepage)
     ParserState old_state;
     size_t sz;
 
-    buf = ass_load_file(track->library, fname, FN_EXTERNAL, &sz);
+    buf = read_file(track->library, fname, FN_EXTERNAL, &sz);
     if (!buf)
         return 1;
 #ifdef CONFIG_ICONV
@@ -1736,9 +1545,6 @@ int ass_track_set_feature(ASS_Track *track, ASS_Feature feature, int enable)
     static const uint32_t supported =
 #ifdef USE_FRIBIDI_EX_API
         FEATURE_MASK(ASS_FEATURE_BIDI_BRACKETS) |
-#endif
-#ifdef CONFIG_UNIBREAK
-        FEATURE_MASK(ASS_FEATURE_WRAP_UNICODE) |
 #endif
         FEATURE_MASK(ASS_FEATURE_WHOLE_TEXT_LAYOUT) |
         0;
diff --git a/libass/ass.h b/libass/ass.h
index 05d97fb..85dc1fe 100644
--- a/libass/ass.h
+++ b/libass/ass.h
@@ -24,7 +24,7 @@
 #include <stdarg.h>
 #include "ass_types.h"
 
-#define LIBASS_VERSION 0x01701000
+#define LIBASS_VERSION 0x01600000
 
 #ifdef __cplusplus
 extern "C" {
@@ -266,19 +266,6 @@ typedef enum {
      */
     ASS_FEATURE_WHOLE_TEXT_LAYOUT,
 
-    /**
-     * Break lines according to the Unicode Line Breaking Algorithm.
-     * If the track language is set, some additional language-specific tweaks
-     * may be applied. Setting this enables more breaking opportunities
-     * compared to classic ASS. However, it is still possible for long words
-     * without breaking opportunities to cause overfull lines.
-     * This is incompatible with VSFilter and disabled by default.
-     *
-     * This feature may be unavailable at runtime if
-     * libass was compiled without libunibreak support.
-     */
-    ASS_FEATURE_WRAP_UNICODE,
-
     // New enum values can be added here in new ABI-compatible library releases.
 } ASS_Feature;
 
@@ -376,7 +363,7 @@ void ass_renderer_done(ASS_Renderer *priv);
  * The value set with this function can influence the pixel aspect ratio used
  * for rendering.
  * If after compensating for configured margins the frame size
- * is not an isotropically scaled version of the video display size,
+ * is not an isotropicly scaled version of the video display size,
  * you may have to use ass_set_pixel_aspect().
  * @see ass_set_pixel_aspect()
  * @see ass_set_margins()
@@ -392,7 +379,6 @@ void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
  * \brief Set the source image size in pixels.
  * This affects some ASS tags like e.g. 3D transforms and
  * is used to calculate the source aspect ratio and blur scale.
- * If subtitles specify valid LayoutRes* headers, those will take precedence.
  * The source image size can be reset to default by setting w and h to 0.
  * The value set with this function can influence the pixel aspect ratio used
  * for rendering.
@@ -460,13 +446,8 @@ void ass_set_use_margins(ASS_Renderer *priv, int use);
  * by calling this function, libass will calculate a default pixel aspect ratio
  * out of values set with ass_set_frame_size() and ass_set_storage_size(). Note
  * that this default assumes the frame size after compensating for margins
- * corresponds to an isotropically scaled version of the video display size.
+ * corresponds to an isotropicly scaled version of the video display size.
  * If the storage size has not been set, a pixel aspect ratio of 1 is assumed.
- *
- * If subtitles specify valid LayoutRes* headers, the API-configured
- * pixel aspect value is discarded in favour of one calculated out of the
- * headers and values set with ass_set_frame_size().
- *
  * \param priv renderer handle
  * \param par pixel aspect ratio (1.0 means square pixels, 0 means default)
  */
diff --git a/libass/ass_bitmap.c b/libass/ass_bitmap.c
index 41df5e1..b11fcfa 100644
--- a/libass/ass_bitmap.c
+++ b/libass/ass_bitmap.c
@@ -36,44 +36,38 @@
 #include "ass_render.h"
 
 
-static void be_blur_pre(uint8_t *buf, intptr_t stride, intptr_t width, intptr_t height)
-{
-    for (int y = 0; y < height; ++y)
-    {
-        for (int x = 0; x < width; ++x)
-        {
-            // This is equivalent to (value * 64 + 127) / 255 for all
-            // values from 0 to 256 inclusive. Assist vectorizing
-            // compilers by noting that all temporaries fit in 8 bits.
-            buf[y * stride + x] =
-                (uint8_t) ((buf[y * stride + x] >> 1) + 1) >> 1;
-        }
-    }
-}
+#define ALIGN           C_ALIGN_ORDER
+#define DECORATE(func)  ass_##func##_c
+#include "ass_func_template.h"
+#undef ALIGN
+#undef DECORATE
+
+#if CONFIG_ASM && ARCH_X86
+
+#define ALIGN           4
+#define DECORATE(func)  ass_##func##_sse2
+#include "ass_func_template.h"
+#undef ALIGN
+#undef DECORATE
+
+#define ALIGN           5
+#define DECORATE(func)  ass_##func##_avx2
+#include "ass_func_template.h"
+#undef ALIGN
+#undef DECORATE
+
+#endif
 
-static void be_blur_post(uint8_t *buf, intptr_t stride, intptr_t width, intptr_t height)
-{
-    for (int y = 0; y < height; ++y)
-    {
-        for (int x = 0; x < width; ++x)
-        {
-            // This is equivalent to (value * 255 + 32) / 64 for all values
-            // from 0 to 96 inclusive, and we only care about 0 to 64.
-            uint8_t value = buf[y * stride + x];
-            buf[y * stride + x] = (value << 2) - (value > 32);
-        }
-    }
-}
 
 void ass_synth_blur(const BitmapEngine *engine, Bitmap *bm,
-                    int be, double blur_r2x, double blur_r2y)
+                    int be, double blur_r2)
 {
     if (!bm->buffer)
         return;
 
     // Apply gaussian blur
-    if (blur_r2x > 0.001 || blur_r2y > 0.001)
-        ass_gaussian_blur(engine, bm, blur_r2x, blur_r2y);
+    if (blur_r2 > 0.001)
+        ass_gaussian_blur(engine, bm, blur_r2);
 
     if (!be)
         return;
@@ -100,8 +94,8 @@ void ass_synth_blur(const BitmapEngine *engine, Bitmap *bm,
     ass_aligned_free(tmp);
 }
 
-bool ass_alloc_bitmap(const BitmapEngine *engine, Bitmap *bm,
-                      int32_t w, int32_t h, bool zero)
+bool alloc_bitmap(const BitmapEngine *engine, Bitmap *bm,
+                  int32_t w, int32_t h, bool zero)
 {
     unsigned align = 1 << engine->align_order;
     size_t s = ass_align(align, w);
@@ -118,10 +112,10 @@ bool ass_alloc_bitmap(const BitmapEngine *engine, Bitmap *bm,
     return true;
 }
 
-bool ass_realloc_bitmap(const BitmapEngine *engine, Bitmap *bm, int32_t w, int32_t h)
+bool realloc_bitmap(const BitmapEngine *engine, Bitmap *bm, int32_t w, int32_t h)
 {
     uint8_t *old = bm->buffer;
-    if (!ass_alloc_bitmap(engine, bm, w, h, false))
+    if (!alloc_bitmap(engine, bm, w, h, false))
         return false;
     ass_aligned_free(old);
     return true;
@@ -132,13 +126,13 @@ void ass_free_bitmap(Bitmap *bm)
     ass_aligned_free(bm->buffer);
 }
 
-bool ass_copy_bitmap(const BitmapEngine *engine, Bitmap *dst, const Bitmap *src)
+bool copy_bitmap(const BitmapEngine *engine, Bitmap *dst, const Bitmap *src)
 {
     if (!src->buffer) {
         memset(dst, 0, sizeof(*dst));
         return true;
     }
-    if (!ass_alloc_bitmap(engine, dst, src->w, src->h, false))
+    if (!alloc_bitmap(engine, dst, src->w, src->h, false))
         return false;
     dst->left = src->left;
     dst->top  = src->top;
@@ -146,16 +140,15 @@ bool ass_copy_bitmap(const BitmapEngine *engine, Bitmap *dst, const Bitmap *src)
     return true;
 }
 
-bool ass_outline_to_bitmap(RenderContext *state, Bitmap *bm,
-                           ASS_Outline *outline1, ASS_Outline *outline2)
+bool outline_to_bitmap(ASS_Renderer *render_priv, Bitmap *bm,
+                       ASS_Outline *outline1, ASS_Outline *outline2)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    RasterizerData *rst = &state->rasterizer;
-    if (outline1 && !ass_rasterizer_set_outline(rst, outline1, false)) {
+    RasterizerData *rst = &render_priv->rasterizer;
+    if (outline1 && !rasterizer_set_outline(rst, outline1, false)) {
         ass_msg(render_priv->library, MSGL_WARN, "Failed to process glyph outline!\n");
         return false;
     }
-    if (outline2 && !ass_rasterizer_set_outline(rst, outline2, !!outline1)) {
+    if (outline2 && !rasterizer_set_outline(rst, outline2, !!outline1)) {
         ass_msg(render_priv->library, MSGL_WARN, "Failed to process glyph outline!\n");
         return false;
     }
@@ -170,7 +163,7 @@ bool ass_outline_to_bitmap(RenderContext *state, Bitmap *bm,
     int32_t w = x_max - x_min;
     int32_t h = y_max - y_min;
 
-    int mask = (1 << render_priv->engine.tile_order) - 1;
+    int mask = (1 << render_priv->engine->tile_order) - 1;
 
     // XXX: is that possible to trigger at all?
     if (w < 0 || h < 0 || w > INT_MAX - mask || h > INT_MAX - mask) {
@@ -181,13 +174,13 @@ bool ass_outline_to_bitmap(RenderContext *state, Bitmap *bm,
 
     int32_t tile_w = (w + mask) & ~mask;
     int32_t tile_h = (h + mask) & ~mask;
-    if (!ass_alloc_bitmap(&render_priv->engine, bm, tile_w, tile_h, false))
+    if (!alloc_bitmap(render_priv->engine, bm, tile_w, tile_h, false))
         return false;
     bm->left = x_min;
     bm->top  = y_min;
 
-    if (!ass_rasterizer_fill(&render_priv->engine, rst, bm->buffer,
-                             x_min, y_min, bm->stride, tile_h, bm->stride)) {
+    if (!rasterizer_fill(render_priv->engine, rst, bm->buffer,
+                         x_min, y_min, bm->stride, tile_h, bm->stride)) {
         ass_msg(render_priv->library, MSGL_WARN, "Failed to rasterize glyph!\n");
         ass_free_bitmap(bm);
         return false;
@@ -202,7 +195,7 @@ bool ass_outline_to_bitmap(RenderContext *state, Bitmap *bm,
  * The glyph bitmap is subtracted from outline bitmap. This way looks much
  * better in some cases.
  */
-void ass_fix_outline(Bitmap *bm_g, Bitmap *bm_o)
+void fix_outline(Bitmap *bm_g, Bitmap *bm_o)
 {
     if (!bm_g->buffer || !bm_o->buffer)
         return;
@@ -227,7 +220,7 @@ void ass_fix_outline(Bitmap *bm_g, Bitmap *bm_o)
  * \brief Shift a bitmap by the fraction of a pixel in x and y direction
  * expressed in 26.6 fixed point
  */
-void ass_shift_bitmap(Bitmap *bm, int shift_x, int shift_y)
+void shift_bitmap(Bitmap *bm, int shift_x, int shift_y)
 {
     assert((shift_x & ~63) == 0 && (shift_y & ~63) == 0);
 
@@ -258,3 +251,176 @@ void ass_shift_bitmap(Bitmap *bm, int shift_x, int shift_y)
             }
         }
 }
+
+/**
+ * \brief Blur with [[1,2,1], [2,4,2], [1,2,1]] kernel
+ * This blur is the same as the one employed by vsfilter.
+ * Pure C implementation.
+ */
+void ass_be_blur_c(uint8_t *buf, intptr_t stride,
+                   intptr_t width, intptr_t height, uint16_t *tmp)
+{
+    uint16_t *col_pix_buf = tmp;
+    uint16_t *col_sum_buf = tmp + width;
+    unsigned x, y, old_pix, old_sum, temp1, temp2;
+    uint8_t *src, *dst;
+    y = 0;
+
+    {
+        src=buf+y*stride;
+
+        x = 1;
+        old_pix = src[x-1];
+        old_sum = old_pix;
+        for ( ; x < width; x++) {
+            temp1 = src[x];
+            temp2 = old_pix + temp1;
+            old_pix = temp1;
+            temp1 = old_sum + temp2;
+            old_sum = temp2;
+            col_pix_buf[x-1] = temp1;
+            col_sum_buf[x-1] = temp1;
+        }
+        temp1 = old_sum + old_pix;
+        col_pix_buf[x-1] = temp1;
+        col_sum_buf[x-1] = temp1;
+    }
+
+    for (y++; y < height; y++) {
+        src=buf+y*stride;
+        dst=buf+(y-1)*stride;
+
+        x = 1;
+        old_pix = src[x-1];
+        old_sum = old_pix;
+        for ( ; x < width; x++) {
+            temp1 = src[x];
+            temp2 = old_pix + temp1;
+            old_pix = temp1;
+            temp1 = old_sum + temp2;
+            old_sum = temp2;
+
+            temp2 = col_pix_buf[x-1] + temp1;
+            col_pix_buf[x-1] = temp1;
+            dst[x-1] = (col_sum_buf[x-1] + temp2) >> 4;
+            col_sum_buf[x-1] = temp2;
+        }
+        temp1 = old_sum + old_pix;
+        temp2 = col_pix_buf[x-1] + temp1;
+        col_pix_buf[x-1] = temp1;
+        dst[x-1] = (col_sum_buf[x-1] + temp2) >> 4;
+        col_sum_buf[x-1] = temp2;
+    }
+
+    {
+        dst=buf+(y-1)*stride;
+        for (x = 0; x < width; x++)
+            dst[x] = (col_sum_buf[x] + col_pix_buf[x]) >> 4;
+    }
+}
+
+void be_blur_pre(uint8_t *buf, intptr_t stride, intptr_t width, intptr_t height)
+{
+    for (int y = 0; y < height; ++y)
+    {
+        for (int x = 0; x < width; ++x)
+        {
+            // This is equivalent to (value * 64 + 127) / 255 for all
+            // values from 0 to 256 inclusive. Assist vectorizing
+            // compilers by noting that all temporaries fit in 8 bits.
+            buf[y * stride + x] =
+                (uint8_t) ((buf[y * stride + x] >> 1) + 1) >> 1;
+        }
+    }
+}
+
+void be_blur_post(uint8_t *buf, intptr_t stride, intptr_t width, intptr_t height)
+{
+    for (int y = 0; y < height; ++y)
+    {
+        for (int x = 0; x < width; ++x)
+        {
+            // This is equivalent to (value * 255 + 32) / 64 for all values
+            // from 0 to 96 inclusive, and we only care about 0 to 64.
+            uint8_t value = buf[y * stride + x];
+            buf[y * stride + x] = (value << 2) - (value > 32);
+        }
+    }
+}
+
+/*
+ * To find these values, simulate blur on the border between two
+ * half-planes, one zero-filled (background) and the other filled
+ * with the maximum supported value (foreground). Keep incrementing
+ * the \be argument. The necessary padding is the distance by which
+ * the blurred foreground image extends beyond the original border
+ * and into the background. Initially it increases along with \be,
+ * but very soon it grinds to a halt. At some point, the blurred
+ * image actually reaches a stationary point and stays unchanged
+ * forever after, simply _shifting_ by one pixel for each \be
+ * step--moving in the direction of the non-zero half-plane and
+ * thus decreasing the necessary padding (although the large
+ * padding is still needed for intermediate results). In practice,
+ * images are finite rather than infinite like half-planes, but
+ * this can only decrease the required padding. Half-planes filled
+ * with extreme values are the theoretical limit of the worst case.
+ * Make sure to use the right pixel value range in the simulation!
+ */
+int be_padding(int be)
+{
+    if (be <= 3)
+        return be;
+    if (be <= 7)
+        return 4;
+    return 5;
+}
+
+/**
+ * \brief Add two bitmaps together at a given position
+ * Uses additive blending, clipped to [0,255]. Pure C implementation.
+ */
+void ass_add_bitmaps_c(uint8_t *dst, intptr_t dst_stride,
+                       uint8_t *src, intptr_t src_stride,
+                       intptr_t width, intptr_t height)
+{
+    unsigned out;
+    uint8_t* end = dst + dst_stride * height;
+    while (dst < end) {
+        for (unsigned j = 0; j < width; ++j) {
+            out = dst[j] + src[j];
+            dst[j] = FFMIN(out, 255);
+        }
+        dst += dst_stride;
+        src += src_stride;
+    }
+}
+
+void ass_imul_bitmaps_c(uint8_t *dst, intptr_t dst_stride,
+                        uint8_t *src, intptr_t src_stride,
+                        intptr_t width, intptr_t height)
+{
+    uint8_t* end = dst + dst_stride * height;
+    while (dst < end) {
+        for (unsigned j = 0; j < width; ++j) {
+            dst[j] = (dst[j] * (255 - src[j]) + 255) >> 8;
+        }
+        dst += dst_stride;
+        src += src_stride;
+    }
+}
+
+void ass_mul_bitmaps_c(uint8_t *dst, intptr_t dst_stride,
+                       uint8_t *src1, intptr_t src1_stride,
+                       uint8_t *src2, intptr_t src2_stride,
+                       intptr_t width, intptr_t height)
+{
+    uint8_t* end = src1 + src1_stride * height;
+    while (src1 < end) {
+        for (unsigned x = 0; x < width; ++x) {
+            dst[x] = (src1[x] * src2[x] + 255) >> 8;
+        }
+        dst  += dst_stride;
+        src1 += src1_stride;
+        src2 += src2_stride;
+    }
+}
diff --git a/libass/ass_bitmap.h b/libass/ass_bitmap.h
index c337bf1..1a17fd5 100644
--- a/libass/ass_bitmap.h
+++ b/libass/ass_bitmap.h
@@ -25,7 +25,70 @@
 
 #include "ass.h"
 #include "ass_outline.h"
-#include "ass_bitmap_engine.h"
+
+
+struct segment;
+typedef void (*FillSolidTileFunc)(uint8_t *buf, ptrdiff_t stride, int set);
+typedef void (*FillHalfplaneTileFunc)(uint8_t *buf, ptrdiff_t stride,
+                                      int32_t a, int32_t b, int64_t c, int32_t scale);
+typedef void (*FillGenericTileFunc)(uint8_t *buf, ptrdiff_t stride,
+                                    const struct segment *line, size_t n_lines,
+                                    int winding);
+typedef void (*MergeTileFunc)(uint8_t *buf, ptrdiff_t stride, const uint8_t *tile);
+
+typedef void (*BitmapBlendFunc)(uint8_t *dst, intptr_t dst_stride,
+                                uint8_t *src, intptr_t src_stride,
+                                intptr_t width, intptr_t height);
+typedef void (*BitmapMulFunc)(uint8_t *dst, intptr_t dst_stride,
+                              uint8_t *src1, intptr_t src1_stride,
+                              uint8_t *src2, intptr_t src2_stride,
+                              intptr_t width, intptr_t height);
+
+typedef void (*BeBlurFunc)(uint8_t *buf, intptr_t stride,
+                           intptr_t width, intptr_t height, uint16_t *tmp);
+
+// intermediate bitmaps represented as sets of verical stripes of int16_t[alignment / 2]
+typedef void (*Convert8to16Func)(int16_t *dst, const uint8_t *src, ptrdiff_t src_stride,
+                                 uintptr_t width, uintptr_t height);
+typedef void (*Convert16to8Func)(uint8_t *dst, ptrdiff_t dst_stride, const int16_t *src,
+                                 uintptr_t width, uintptr_t height);
+typedef void (*FilterFunc)(int16_t *dst, const int16_t *src,
+                           uintptr_t src_width, uintptr_t src_height);
+typedef void (*ParamFilterFunc)(int16_t *dst, const int16_t *src,
+                                uintptr_t src_width, uintptr_t src_height,
+                                const int16_t *param);
+
+#define C_ALIGN_ORDER 5
+
+typedef struct {
+    int align_order;  // log2(alignment)
+
+    // rasterizer functions
+    int tile_order;  // log2(tile_size)
+    FillSolidTileFunc fill_solid;
+    FillHalfplaneTileFunc fill_halfplane;
+    FillGenericTileFunc fill_generic;
+    MergeTileFunc merge_tile;
+
+    // blend functions
+    BitmapBlendFunc add_bitmaps, imul_bitmaps;
+    BitmapMulFunc mul_bitmaps;
+
+    // be blur function
+    BeBlurFunc be_blur;
+
+    // gaussian blur functions
+    Convert8to16Func stripe_unpack;
+    Convert16to8Func stripe_pack;
+    FilterFunc shrink_horz, shrink_vert;
+    FilterFunc expand_horz, expand_vert;
+    ParamFilterFunc blur_horz[5], blur_vert[5];
+} BitmapEngine;
+
+extern const BitmapEngine ass_bitmap_engine_c;
+extern const BitmapEngine ass_bitmap_engine_sse2;
+extern const BitmapEngine ass_bitmap_engine_avx2;
+
 
 typedef struct {
     int32_t left, top;
@@ -34,21 +97,22 @@ typedef struct {
     uint8_t *buffer;      // h * stride buffer
 } Bitmap;
 
-bool ass_alloc_bitmap(const BitmapEngine *engine, Bitmap *bm, int32_t w, int32_t h, bool zero);
-bool ass_realloc_bitmap(const BitmapEngine *engine, Bitmap *bm, int32_t w, int32_t h);
-bool ass_copy_bitmap(const BitmapEngine *engine, Bitmap *dst, const Bitmap *src);
+bool alloc_bitmap(const BitmapEngine *engine, Bitmap *bm, int32_t w, int32_t h, bool zero);
+bool realloc_bitmap(const BitmapEngine *engine, Bitmap *bm, int32_t w, int32_t h);
+bool copy_bitmap(const BitmapEngine *engine, Bitmap *dst, const Bitmap *src);
 void ass_free_bitmap(Bitmap *bm);
 
-struct render_context;
-
-bool ass_outline_to_bitmap(struct render_context *state, Bitmap *bm,
-                           ASS_Outline *outline1, ASS_Outline *outline2);
+bool outline_to_bitmap(ASS_Renderer *render_priv, Bitmap *bm,
+                       ASS_Outline *outline1, ASS_Outline *outline2);
 
 void ass_synth_blur(const BitmapEngine *engine, Bitmap *bm,
-                    int be, double blur_r2x, double blur_r2y);
+                    int be, double blur_r2);
 
-bool ass_gaussian_blur(const BitmapEngine *engine, Bitmap *bm, double r2x, double r2y);
-void ass_shift_bitmap(Bitmap *bm, int shift_x, int shift_y);
-void ass_fix_outline(Bitmap *bm_g, Bitmap *bm_o);
+int be_padding(int be);
+void be_blur_pre(uint8_t *buf, intptr_t stride, intptr_t width, intptr_t height);
+void be_blur_post(uint8_t *buf, intptr_t stride, intptr_t width, intptr_t height);
+bool ass_gaussian_blur(const BitmapEngine *engine, Bitmap *bm, double r2);
+void shift_bitmap(Bitmap *bm, int shift_x, int shift_y);
+void fix_outline(Bitmap *bm_g, Bitmap *bm_o);
 
 #endif                          /* LIBASS_BITMAP_H */
diff --git a/libass/ass_blur.c b/libass/ass_blur.c
index ec91a92..5302832 100644
--- a/libass/ass_blur.c
+++ b/libass/ass_blur.c
@@ -41,6 +41,368 @@
  * for the Fourier transform of the resulting kernel.
  */
 
+
+#define STRIPE_WIDTH  (1 << (C_ALIGN_ORDER - 1))
+#define STRIPE_MASK   (STRIPE_WIDTH - 1)
+static int16_t zero_line[STRIPE_WIDTH];
+static int16_t dither_line[2 * STRIPE_WIDTH] = {
+#if STRIPE_WIDTH > 8
+     8, 40,  8, 40,  8, 40,  8, 40,  8, 40,  8, 40,  8, 40,  8, 40,
+    56, 24, 56, 24, 56, 24, 56, 24, 56, 24, 56, 24, 56, 24, 56, 24,
+#else
+     8, 40,  8, 40,  8, 40,  8, 40,
+    56, 24, 56, 24, 56, 24, 56, 24,
+#endif
+};
+
+inline static const int16_t *get_line(const int16_t *ptr, uintptr_t offs, uintptr_t size)
+{
+    return offs < size ? ptr + offs : zero_line;
+}
+
+inline static void copy_line(int16_t *buf, const int16_t *ptr, uintptr_t offs, uintptr_t size)
+{
+    memcpy(buf, get_line(ptr, offs, size), STRIPE_WIDTH * sizeof(buf[0]));
+}
+
+/*
+ * Unpack/Pack Functions
+ *
+ * Convert between regular 8-bit bitmap and internal format.
+ * Internal image is stored as set of vertical stripes of size [STRIPE_WIDTH x height].
+ * Each pixel is represented as 16-bit integer in range of [0-0x4000].
+ */
+
+void ass_stripe_unpack_c(int16_t *dst, const uint8_t *src, ptrdiff_t src_stride,
+                         uintptr_t width, uintptr_t height)
+{
+    for (uintptr_t y = 0; y < height; y++) {
+        int16_t *ptr = dst;
+        for (uintptr_t x = 0; x < width; x += STRIPE_WIDTH) {
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                ptr[k] = (uint16_t) (((src[x + k] << 7) | (src[x + k] >> 1)) + 1) >> 1;
+                //ptr[k] = (0x4000 * src[x + k] + 127) / 255;
+            ptr += STRIPE_WIDTH * height;
+        }
+        dst += STRIPE_WIDTH;
+        src += src_stride;
+    }
+}
+
+void ass_stripe_pack_c(uint8_t *dst, ptrdiff_t dst_stride, const int16_t *src,
+                       uintptr_t width, uintptr_t height)
+{
+    for (uintptr_t x = 0; x < width; x += STRIPE_WIDTH) {
+        uint8_t *ptr = dst;
+        for (uintptr_t y = 0; y < height; y++) {
+            const int16_t *dither = dither_line + (y & 1) * STRIPE_WIDTH;
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                ptr[k] = (uint16_t) (src[k] - (src[k] >> 8) + dither[k]) >> 6;
+                //ptr[k] = (255 * src[k] + 0x1FFF) / 0x4000;
+            ptr += dst_stride;
+            src += STRIPE_WIDTH;
+        }
+        dst += STRIPE_WIDTH;
+    }
+    uintptr_t left = dst_stride - ((width + STRIPE_MASK) & ~STRIPE_MASK);
+    for (uintptr_t y = 0; y < height; y++) {
+        for (uintptr_t x = 0; x < left; x++)
+            dst[x] = 0;
+        dst += dst_stride;
+    }
+}
+
+/*
+ * Contract Filters
+ *
+ * Contract image by factor 2 with kernel [1, 5, 10, 10, 5, 1].
+ */
+
+static inline int16_t shrink_func(int16_t p1p, int16_t p1n,
+                                  int16_t z0p, int16_t z0n,
+                                  int16_t n1p, int16_t n1n)
+{
+    /*
+    return (1 * p1p + 5 * p1n + 10 * z0p + 10 * z0n + 5 * n1p + 1 * n1n + 16) >> 5;
+    */
+    int32_t r = (p1p + p1n + n1p + n1n) >> 1;
+    r = (r + z0p + z0n) >> 1;
+    r = (r + p1n + n1p) >> 1;
+    return (r + z0p + z0n + 2) >> 2;
+}
+
+void ass_shrink_horz_c(int16_t *dst, const int16_t *src,
+                       uintptr_t src_width, uintptr_t src_height)
+{
+    uintptr_t dst_width = (src_width + 5) >> 1;
+    uintptr_t size = ((src_width + STRIPE_MASK) & ~STRIPE_MASK) * src_height;
+    uintptr_t step = STRIPE_WIDTH * src_height;
+
+    uintptr_t offs = 0;
+    int16_t buf[3 * STRIPE_WIDTH];
+    int16_t *ptr = buf + STRIPE_WIDTH;
+    for (uintptr_t x = 0; x < dst_width; x += STRIPE_WIDTH) {
+        for (uintptr_t y = 0; y < src_height; y++) {
+            copy_line(ptr - 1 * STRIPE_WIDTH, src, offs - 1 * step, size);
+            copy_line(ptr + 0 * STRIPE_WIDTH, src, offs + 0 * step, size);
+            copy_line(ptr + 1 * STRIPE_WIDTH, src, offs + 1 * step, size);
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                dst[k] = shrink_func(ptr[2 * k - 4], ptr[2 * k - 3],
+                                     ptr[2 * k - 2], ptr[2 * k - 1],
+                                     ptr[2 * k + 0], ptr[2 * k + 1]);
+            dst  += STRIPE_WIDTH;
+            offs += STRIPE_WIDTH;
+        }
+        offs += step;
+    }
+}
+
+void ass_shrink_vert_c(int16_t *dst, const int16_t *src,
+                       uintptr_t src_width, uintptr_t src_height)
+{
+    uintptr_t dst_height = (src_height + 5) >> 1;
+    uintptr_t step = STRIPE_WIDTH * src_height;
+
+    for (uintptr_t x = 0; x < src_width; x += STRIPE_WIDTH) {
+        uintptr_t offs = 0;
+        for (uintptr_t y = 0; y < dst_height; y++) {
+            const int16_t *p1p = get_line(src, offs - 4 * STRIPE_WIDTH, step);
+            const int16_t *p1n = get_line(src, offs - 3 * STRIPE_WIDTH, step);
+            const int16_t *z0p = get_line(src, offs - 2 * STRIPE_WIDTH, step);
+            const int16_t *z0n = get_line(src, offs - 1 * STRIPE_WIDTH, step);
+            const int16_t *n1p = get_line(src, offs - 0 * STRIPE_WIDTH, step);
+            const int16_t *n1n = get_line(src, offs + 1 * STRIPE_WIDTH, step);
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                dst[k] = shrink_func(p1p[k], p1n[k], z0p[k], z0n[k], n1p[k], n1n[k]);
+            dst  += 1 * STRIPE_WIDTH;
+            offs += 2 * STRIPE_WIDTH;
+        }
+        src += step;
+    }
+}
+
+/*
+ * Expand Filters
+ *
+ * Expand image by factor 2 with kernel [5, 10, 1], [1, 10, 5].
+ */
+
+static inline void expand_func(int16_t *rp, int16_t *rn,
+                               int16_t p1, int16_t z0, int16_t n1)
+{
+    /*
+    *rp = (5 * p1 + 10 * z0 + 1 * n1 + 8) >> 4;
+    *rn = (1 * p1 + 10 * z0 + 5 * n1 + 8) >> 4;
+    */
+    uint16_t r = (uint16_t) (((uint16_t) (p1 + n1) >> 1) + z0) >> 1;
+    *rp = (uint16_t) (((uint16_t) (r + p1) >> 1) + z0 + 1) >> 1;
+    *rn = (uint16_t) (((uint16_t) (r + n1) >> 1) + z0 + 1) >> 1;
+}
+
+void ass_expand_horz_c(int16_t *dst, const int16_t *src,
+                       uintptr_t src_width, uintptr_t src_height)
+{
+    uintptr_t dst_width = 2 * src_width + 4;
+    uintptr_t size = ((src_width + STRIPE_MASK) & ~STRIPE_MASK) * src_height;
+    uintptr_t step = STRIPE_WIDTH * src_height;
+
+    uintptr_t offs = 0;
+    int16_t buf[2 * STRIPE_WIDTH];
+    int16_t *ptr = buf + STRIPE_WIDTH;
+    for (uintptr_t x = STRIPE_WIDTH; x < dst_width; x += 2 * STRIPE_WIDTH) {
+        for (uintptr_t y = 0; y < src_height; y++) {
+            copy_line(ptr - 1 * STRIPE_WIDTH, src, offs - 1 * step, size);
+            copy_line(ptr - 0 * STRIPE_WIDTH, src, offs - 0 * step, size);
+            for (int k = 0; k < STRIPE_WIDTH / 2; k++)
+                expand_func(&dst[2 * k], &dst[2 * k + 1],
+                            ptr[k - 2], ptr[k - 1], ptr[k]);
+            int16_t *next = dst + step - STRIPE_WIDTH;
+            for (int k = STRIPE_WIDTH / 2; k < STRIPE_WIDTH; k++)
+                expand_func(&next[2 * k], &next[2 * k + 1],
+                            ptr[k - 2], ptr[k - 1], ptr[k]);
+            dst  += STRIPE_WIDTH;
+            offs += STRIPE_WIDTH;
+        }
+        dst += step;
+    }
+    if ((dst_width - 1) & STRIPE_WIDTH)
+        return;
+
+    for (uintptr_t y = 0; y < src_height; y++) {
+        copy_line(ptr - 1 * STRIPE_WIDTH, src, offs - 1 * step, size);
+        copy_line(ptr - 0 * STRIPE_WIDTH, src, offs - 0 * step, size);
+        for (int k = 0; k < STRIPE_WIDTH / 2; k++)
+            expand_func(&dst[2 * k], &dst[2 * k + 1],
+                        ptr[k - 2], ptr[k - 1], ptr[k]);
+        dst  += STRIPE_WIDTH;
+        offs += STRIPE_WIDTH;
+    }
+}
+
+void ass_expand_vert_c(int16_t *dst, const int16_t *src,
+                       uintptr_t src_width, uintptr_t src_height)
+{
+    uintptr_t dst_height = 2 * src_height + 4;
+    uintptr_t step = STRIPE_WIDTH * src_height;
+
+    for (uintptr_t x = 0; x < src_width; x += STRIPE_WIDTH) {
+        uintptr_t offs = 0;
+        for (uintptr_t y = 0; y < dst_height; y += 2) {
+            const int16_t *p1 = get_line(src, offs - 2 * STRIPE_WIDTH, step);
+            const int16_t *z0 = get_line(src, offs - 1 * STRIPE_WIDTH, step);
+            const int16_t *n1 = get_line(src, offs - 0 * STRIPE_WIDTH, step);
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                expand_func(&dst[k], &dst[k + STRIPE_WIDTH],
+                            p1[k], z0[k], n1[k]);
+            dst  += 2 * STRIPE_WIDTH;
+            offs += 1 * STRIPE_WIDTH;
+        }
+        src += step;
+    }
+}
+
+/*
+ * Main Parametric Filters
+ *
+ * Perform 1D convolution with kernel [..., c2, c1, c0, d, c0, c1, c2, ...],
+ * cN = param[N], d = 1 - 2 * (c0 + c1 + c2 + ...),
+ * number of parameters is part of the function name.
+ */
+
+static inline void blur_horz(int16_t *dst, const int16_t *src,
+                             uintptr_t src_width, uintptr_t src_height,
+                             const int16_t *param, const int n)
+{
+    uintptr_t dst_width = src_width + 2 * n;
+    uintptr_t size = ((src_width + STRIPE_MASK) & ~STRIPE_MASK) * src_height;
+    uintptr_t step = STRIPE_WIDTH * src_height;
+
+    uintptr_t offs = 0;
+    int16_t buf[3 * STRIPE_WIDTH];
+    int16_t *ptr = buf + 2 * STRIPE_WIDTH;
+    for (uintptr_t x = 0; x < dst_width; x += STRIPE_WIDTH) {
+        for (uintptr_t y = 0; y < src_height; y++) {
+            for (int i = -((2 * n + STRIPE_WIDTH - 1u) / STRIPE_WIDTH); i <= 0; i++)
+                copy_line(ptr + i * STRIPE_WIDTH, src, offs + i * step, size);
+            int32_t acc[STRIPE_WIDTH];
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                acc[k] = 0x8000;
+            for (int i = n; i > 0; i--)
+                for (int k = 0; k < STRIPE_WIDTH; k++)
+                    acc[k] += (int16_t) (ptr[k - n - i] - ptr[k - n]) * param[i - 1] +
+                              (int16_t) (ptr[k - n + i] - ptr[k - n]) * param[i - 1];
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                dst[k] = ptr[k - n] + (acc[k] >> 16);
+
+            dst  += STRIPE_WIDTH;
+            offs += STRIPE_WIDTH;
+        }
+    }
+}
+
+static inline void blur_vert(int16_t *dst, const int16_t *src,
+                             uintptr_t src_width, uintptr_t src_height,
+                             const int16_t *param, const int n)
+{
+    uintptr_t dst_height = src_height + 2 * n;
+    uintptr_t step = STRIPE_WIDTH * src_height;
+
+    for (uintptr_t x = 0; x < src_width; x += STRIPE_WIDTH) {
+        uintptr_t offs = 0;
+        for (uintptr_t y = 0; y < dst_height; y++) {
+            int32_t acc[STRIPE_WIDTH];
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                acc[k] = 0x8000;
+            const int16_t *center = get_line(src, offs - n * STRIPE_WIDTH, step);
+            for (int i = n; i > 0; i--) {
+                const int16_t *line1 = get_line(src, offs - (n + i) * STRIPE_WIDTH, step);
+                const int16_t *line2 = get_line(src, offs - (n - i) * STRIPE_WIDTH, step);
+                for (int k = 0; k < STRIPE_WIDTH; k++)
+                    acc[k] += (int16_t) (line1[k] - center[k]) * param[i - 1] +
+                              (int16_t) (line2[k] - center[k]) * param[i - 1];
+            }
+            for (int k = 0; k < STRIPE_WIDTH; k++)
+                dst[k] = center[k] + (acc[k] >> 16);
+
+            dst  += STRIPE_WIDTH;
+            offs += STRIPE_WIDTH;
+        }
+        src += step;
+    }
+}
+
+void ass_blur4_horz_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_horz(dst, src, src_width, src_height, param, 4);
+}
+
+void ass_blur4_vert_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_vert(dst, src, src_width, src_height, param, 4);
+}
+
+void ass_blur5_horz_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_horz(dst, src, src_width, src_height, param, 5);
+}
+
+void ass_blur5_vert_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_vert(dst, src, src_width, src_height, param, 5);
+}
+
+void ass_blur6_horz_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_horz(dst, src, src_width, src_height, param, 6);
+}
+
+void ass_blur6_vert_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_vert(dst, src, src_width, src_height, param, 6);
+}
+
+void ass_blur7_horz_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_horz(dst, src, src_width, src_height, param, 7);
+}
+
+void ass_blur7_vert_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_vert(dst, src, src_width, src_height, param, 7);
+}
+
+void ass_blur8_horz_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_horz(dst, src, src_width, src_height, param, 8);
+}
+
+void ass_blur8_vert_c(int16_t *dst, const int16_t *src,
+                      uintptr_t src_width, uintptr_t src_height,
+                      const int16_t *param)
+{
+    blur_vert(dst, src, src_width, src_height, param, 8);
+}
+
+
+
 static void calc_gauss(double *res, int n, double r2)
 {
     double alpha = 0.5 / r2;
@@ -167,22 +529,17 @@ static void find_best_method(BlurMethod *blur, double r2)
 
 /**
  * \brief Perform approximate gaussian blur
- * \param r2x in: desired standard deviation along X axis squared
- * \param r2y in: desired standard deviation along Y axis squared
+ * \param r2 in: desired standard deviation squared
  */
-bool ass_gaussian_blur(const BitmapEngine *engine, Bitmap *bm, double r2x, double r2y)
+bool ass_gaussian_blur(const BitmapEngine *engine, Bitmap *bm, double r2)
 {
-    BlurMethod blur_x, blur_y;
-    find_best_method(&blur_x, r2x);
-    if (r2y == r2x)
-        memcpy(&blur_y, &blur_x, sizeof(blur_y));
-    else find_best_method(&blur_y, r2y);
+    BlurMethod blur;
+    find_best_method(&blur, r2);
 
     uint32_t w = bm->w, h = bm->h;
-    int offset_x = ((2 * blur_x.radius + 9) << blur_x.level) - 5;
-    int offset_y = ((2 * blur_y.radius + 9) << blur_y.level) - 5;
-    uint32_t end_w = ((w + offset_x) & ~((1 << blur_x.level) - 1)) - 4;
-    uint32_t end_h = ((h + offset_y) & ~((1 << blur_y.level) - 1)) - 4;
+    int offset = ((2 * blur.radius + 9) << blur.level) - 5;
+    uint32_t end_w = ((w + offset) & ~((1 << blur.level) - 1)) - 4;
+    uint32_t end_h = ((h + offset) & ~((1 << blur.level) - 1)) - 4;
 
     const int stripe_width = 1 << (engine->align_order - 1);
     uint64_t size = (((uint64_t) end_w + stripe_width - 1) & ~(stripe_width - 1)) * end_h;
@@ -197,42 +554,42 @@ bool ass_gaussian_blur(const BitmapEngine *engine, Bitmap *bm, double r2x, doubl
     int16_t *buf[2] = {tmp, tmp + size};
     int index = 0;
 
-    for (int i = 0; i < blur_y.level; i++) {
+    for (int i = 0; i < blur.level; i++) {
         engine->shrink_vert(buf[index ^ 1], buf[index], w, h);
         h = (h + 5) >> 1;
         index ^= 1;
     }
-    for (int i = 0; i < blur_x.level; i++) {
+    for (int i = 0; i < blur.level; i++) {
         engine->shrink_horz(buf[index ^ 1], buf[index], w, h);
         w = (w + 5) >> 1;
         index ^= 1;
     }
-    assert(blur_x.radius >= 4 && blur_x.radius <= 8);
-    engine->blur_horz[blur_x.radius - 4](buf[index ^ 1], buf[index], w, h, blur_x.coeff);
-    w += 2 * blur_x.radius;
+    assert(blur.radius >= 4 && blur.radius <= 8);
+    engine->blur_horz[blur.radius - 4](buf[index ^ 1], buf[index], w, h, blur.coeff);
+    w += 2 * blur.radius;
     index ^= 1;
-    assert(blur_y.radius >= 4 && blur_y.radius <= 8);
-    engine->blur_vert[blur_y.radius - 4](buf[index ^ 1], buf[index], w, h, blur_y.coeff);
-    h += 2 * blur_y.radius;
+    engine->blur_vert[blur.radius - 4](buf[index ^ 1], buf[index], w, h, blur.coeff);
+    h += 2 * blur.radius;
     index ^= 1;
-    for (int i = 0; i < blur_x.level; i++) {
+    for (int i = 0; i < blur.level; i++) {
         engine->expand_horz(buf[index ^ 1], buf[index], w, h);
         w = 2 * w + 4;
         index ^= 1;
     }
-    for (int i = 0; i < blur_y.level; i++) {
+    for (int i = 0; i < blur.level; i++) {
         engine->expand_vert(buf[index ^ 1], buf[index], w, h);
         h = 2 * h + 4;
         index ^= 1;
     }
     assert(w == end_w && h == end_h);
 
-    if (!ass_realloc_bitmap(engine, bm, w, h)) {
+    if (!realloc_bitmap(engine, bm, w, h)) {
         ass_aligned_free(tmp);
         return false;
     }
-    bm->left -= ((blur_x.radius + 4) << blur_x.level) - 4;
-    bm->top  -= ((blur_y.radius + 4) << blur_y.level) - 4;
+    offset = ((blur.radius + 4) << blur.level) - 4;
+    bm->left -= offset;
+    bm->top  -= offset;
 
     engine->stripe_pack(bm->buffer, bm->stride, buf[index], w, h);
     ass_aligned_free(tmp);
diff --git a/libass/ass_cache.c b/libass/ass_cache.c
index 0efba07..2306008 100644
--- a/libass/ass_cache.c
+++ b/libass/ass_cache.c
@@ -234,8 +234,8 @@ static void outline_destruct(void *key, void *value)
 {
     OutlineHashValue *v = value;
     OutlineHashKey *k = key;
-    ass_outline_free(&v->outline[0]);
-    ass_outline_free(&v->outline[1]);
+    outline_free(&v->outline[0]);
+    outline_free(&v->outline[1]);
     switch (k->type) {
     case OUTLINE_GLYPH:
         ass_cache_dec_ref(k->u.glyph.font);
@@ -408,7 +408,7 @@ void *ass_cache_get(Cache *cache, void *key, void *priv)
     item->queue_next = NULL;
     item->ref_count = 2;
 
-    cache->cache_size += item->size + (item->size == 1 ? 0 : CACHE_ITEM_SIZE);
+    cache->cache_size += item->size;
     cache->items++;
     return value;
 }
@@ -452,7 +452,7 @@ void ass_cache_dec_ref(void *value)
         *item->prev = item->next;
 
         cache->items--;
-        cache->cache_size -= item->size + (item->size == 1 ? 0 : CACHE_ITEM_SIZE);
+        cache->cache_size -= item->size;
     }
     destroy_item(item->desc, item);
 }
@@ -479,7 +479,7 @@ void ass_cache_cut(Cache *cache, size_t max_size)
         *item->prev = item->next;
 
         cache->items--;
-        cache->cache_size -= item->size + (item->size == 1 ? 0 : CACHE_ITEM_SIZE);
+        cache->cache_size -= item->size;
         destroy_item(cache->desc, item);
     } while (cache->cache_size > max_size);
     if (cache->queue_first)
diff --git a/libass/ass_cache_template.h b/libass/ass_cache_template.h
index 8b07faa..fd4cdb6 100644
--- a/libass/ass_cache_template.h
+++ b/libass/ass_cache_template.h
@@ -104,8 +104,7 @@ END(BorderHashKey)
 START(filter, filter_desc)
     GENERIC(int, flags)
     GENERIC(int, be)
-    GENERIC(int, blur_x)
-    GENERIC(int, blur_y)
+    GENERIC(int, blur)
     VECTOR(shadow)
 END(FilterDesc)
 
diff --git a/libass/ass_drawing.c b/libass/ass_drawing.c
index 4e6e932..8f90519 100644
--- a/libass/ass_drawing.c
+++ b/libass/ass_drawing.c
@@ -165,10 +165,10 @@ static bool drawing_add_curve(ASS_Outline *outline, ASS_Rect *cbox,
     }
 
     return (started ||
-        ass_outline_add_point(outline, p[0], 0)) &&
-        ass_outline_add_point(outline, p[1], 0) &&
-        ass_outline_add_point(outline, p[2], 0) &&
-        ass_outline_add_point(outline, p[3], OUTLINE_CUBIC_SPLINE);
+        outline_add_point(outline, p[0], 0)) &&
+        outline_add_point(outline, p[1], 0) &&
+        outline_add_point(outline, p[2], 0) &&
+        outline_add_point(outline, p[3], OUTLINE_CUBIC_SPLINE);
 }
 
 /*
@@ -177,7 +177,7 @@ static bool drawing_add_curve(ASS_Outline *outline, ASS_Rect *cbox,
 bool ass_drawing_parse(ASS_Outline *outline, ASS_Rect *cbox,
                        const char *text, ASS_Library *lib)
 {
-    if (!ass_outline_alloc(outline, DRAWING_INITIAL_POINTS, DRAWING_INITIAL_SEGMENTS))
+    if (!outline_alloc(outline, DRAWING_INITIAL_POINTS, DRAWING_INITIAL_SEGMENTS))
         return false;
     rectangle_reset(cbox);
 
@@ -198,9 +198,9 @@ bool ass_drawing_parse(ASS_Outline *outline, ASS_Rect *cbox,
             pen = token->point;
             rectangle_update(cbox, pen.x, pen.y, pen.x, pen.y);
             if (started) {
-                if (!ass_outline_add_segment(outline, OUTLINE_LINE_SEGMENT))
+                if (!outline_add_segment(outline, OUTLINE_LINE_SEGMENT))
                     goto error;
-                ass_outline_close_contour(outline);
+                outline_close_contour(outline);
                 started = false;
             }
             token = token->next;
@@ -208,9 +208,9 @@ bool ass_drawing_parse(ASS_Outline *outline, ASS_Rect *cbox,
         case TOKEN_LINE: {
             ASS_Vector to = token->point;
             rectangle_update(cbox, to.x, to.y, to.x, to.y);
-            if (!started && !ass_outline_add_point(outline, pen, 0))
+            if (!started && !outline_add_point(outline, pen, 0))
                 goto error;
-            if (!ass_outline_add_point(outline, to, OUTLINE_LINE_SEGMENT))
+            if (!outline_add_point(outline, to, OUTLINE_LINE_SEGMENT))
                 goto error;
             started = true;
             token = token->next;
@@ -246,9 +246,9 @@ bool ass_drawing_parse(ASS_Outline *outline, ASS_Rect *cbox,
 
     // Close the last contour
     if (started) {
-        if (!ass_outline_add_segment(outline, OUTLINE_LINE_SEGMENT))
+        if (!outline_add_segment(outline, OUTLINE_LINE_SEGMENT))
             goto error;
-        ass_outline_close_contour(outline);
+        outline_close_contour(outline);
     }
 
     if (lib)
@@ -261,6 +261,6 @@ bool ass_drawing_parse(ASS_Outline *outline, ASS_Rect *cbox,
 
 error:
     drawing_free_tokens(tokens);
-    ass_outline_free(outline);
+    outline_free(outline);
     return false;
 }
diff --git a/libass/ass_font.c b/libass/ass_font.c
index edf42b0..1496924 100644
--- a/libass/ass_font.c
+++ b/libass/ass_font.c
@@ -36,11 +36,6 @@
 #include "ass_utils.h"
 #include "ass_shaper.h"
 
-#if FREETYPE_MAJOR == 2 && FREETYPE_MINOR < 6
-// The lowercase name is still included (as a macro) but deprecated as of 2.6, so avoid using it if we can
-#define FT_SFNT_OS2 ft_sfnt_os2
-#endif
-
 /**
  *  Get the mbcs codepoint from the output bytes of iconv/WideCharToMultiByte,
  *  by treating the bytes as a prefix-zero-byte-omitted big-endian integer.
@@ -196,7 +191,7 @@ static uint32_t convert_unicode_to_mb(FT_Encoding encoding, uint32_t codepoint)
  * Select a good charmap, prefer Microsoft Unicode charmaps.
  * Otherwise, let FreeType decide.
  */
-void ass_charmap_magic(ASS_Library *library, FT_Face face)
+void charmap_magic(ASS_Library *library, FT_Face face)
 {
     int i;
     int ms_cmap = -1;
@@ -267,7 +262,7 @@ static void set_font_metrics(FT_Face face)
     // Mimicking GDI's behavior for asc/desc/height.
     // These fields are (apparently) sometimes used for signed values,
     // despite being unsigned in the spec.
-    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, FT_SFNT_OS2);
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
     if (os2 && ((short)os2->usWinAscent + (short)os2->usWinDescent != 0)) {
         face->ascender  =  (short)os2->usWinAscent;
         face->descender = -(short)os2->usWinDescent;
@@ -441,7 +436,7 @@ static int add_face(ASS_FontSelector *fontsel, ASS_Font *font, uint32_t ch)
     if (!face)
         return -1;
 
-    ass_charmap_magic(font->library, face);
+    charmap_magic(font->library, face);
     set_font_metrics(face);
 
     font->faces[font->n_faces] = face;
@@ -498,37 +493,34 @@ void ass_face_set_size(FT_Face face, double size)
     FT_Request_Size(face, &rq);
 }
 
+/**
+ * \brief Set font size
+ **/
+void ass_font_set_size(ASS_Font *font, double size)
+{
+    int i;
+    if (font->size != size) {
+        font->size = size;
+        for (i = 0; i < font->n_faces; ++i)
+            ass_face_set_size(font->faces[i], size);
+    }
+}
+
 /**
  * \brief Get face weight
  **/
 int ass_face_get_weight(FT_Face face)
 {
+#if FREETYPE_MAJOR > 2 || (FREETYPE_MAJOR == 2 && FREETYPE_MINOR >= 6)
     TT_OS2 *os2 = FT_Get_Sfnt_Table(face, FT_SFNT_OS2);
-    FT_UShort os2Weight = os2 ? os2->usWeightClass : 0;
-    switch (os2Weight) {
-    case 0:
+#else
+    // This old name is still included (as a macro), but deprecated as of 2.6, so avoid using it if we can
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+#endif
+    if (os2 && os2->version != 0xffff && os2->usWeightClass)
+        return os2->usWeightClass;
+    else
         return 300 * !!(face->style_flags & FT_STYLE_FLAG_BOLD) + 400;
-    case 1:
-        return 100;
-    case 2:
-        return 200;
-    case 3:
-        return 300;
-    case 4:
-        return 350;
-    case 5:
-        return 400;
-    case 6:
-        return 600;
-    case 7:
-        return 700;
-    case 8:
-        return 800;
-    case 9:
-        return 900;
-    default:
-        return os2Weight;
-    }
 }
 
 /**
@@ -559,21 +551,6 @@ static void ass_glyph_embolden(FT_GlyphSlot slot)
     FT_Outline_Embolden(&slot->outline, str);
 }
 
-/**
- * Slightly italicize a glyph
- */
-static void ass_glyph_italicize(FT_GlyphSlot slot)
-{
-    FT_Matrix xfrm = {
-        .xx = 0x10000L,
-        .yx = 0x00000L,
-        .xy = 0x05700L,
-        .yy = 0x10000L,
-    };
-
-    FT_Outline_Transform(&slot->outline, &xfrm);
-}
-
 /**
  * \brief Get glyph and face index
  * Finds a face that has the requested codepoint and returns both face
@@ -592,6 +569,9 @@ int ass_font_get_index(ASS_FontSelector *fontsel, ASS_Font *font,
         *face_index = 0;
         return 0;
     }
+    // Handle NBSP like a regular space when rendering the glyph
+    if (symbol == 0xa0)
+        symbol = ' ';
     if (font->n_faces == 0) {
         *face_index = 0;
         return 0;
@@ -677,7 +657,7 @@ bool ass_font_get_glyph(ASS_Font *font, int face_index, int index,
         return false;
     }
     if (!(face->style_flags & FT_STYLE_FLAG_ITALIC) && (font->desc.italic > 55))
-        ass_glyph_italicize(face->glyph);
+        FT_GlyphSlot_Oblique(face->glyph);
     if (font->desc.bold > ass_face_get_weight(face) + 150)
         ass_glyph_embolden(face->glyph);
     return true;
@@ -726,7 +706,7 @@ bool ass_get_glyph_outline(ASS_Outline *outline, int32_t *advance,
         }
     }
     if (adv > 0 && (flags & DECO_STRIKETHROUGH)) {
-        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, FT_SFNT_OS2);
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
         if (os2 && os2->yStrikeoutPosition >= 0 && os2->yStrikeoutSize > 0) {
             int64_t pos  = ((int64_t) os2->yStrikeoutPosition * y_scale + 0x8000) >> 16;
             int64_t size = ((int64_t) os2->yStrikeoutSize     * y_scale + 0x8000) >> 16;
@@ -742,20 +722,20 @@ bool ass_get_glyph_outline(ASS_Outline *outline, int32_t *advance,
     assert(face->glyph->format == FT_GLYPH_FORMAT_OUTLINE);
     FT_Outline *source = &face->glyph->outline;
     if (!source->n_points && !n_lines) {
-        ass_outline_clear(outline);
+        outline_clear(outline);
         return true;
     }
 
     size_t max_points = 2 * source->n_points + 4 * n_lines;
     size_t max_segments = source->n_points + 4 * n_lines;
-    if (!ass_outline_alloc(outline, max_points, max_segments))
+    if (!outline_alloc(outline, max_points, max_segments))
         return false;
 
-    if (!ass_outline_convert(outline, source))
+    if (!outline_convert(outline, source))
         goto fail;
 
     if (flags & DECO_ROTATE) {
-        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, FT_SFNT_OS2);
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
         int64_t desc = 0;
         if (os2) {
             desc = ((int64_t) os2->sTypoDescender * y_scale + 0x8000) >> 16;
@@ -766,7 +746,7 @@ bool ass_get_glyph_outline(ASS_Outline *outline, int32_t *advance,
         if (llabs(dv) > 2 * OUTLINE_MAX)
             goto fail;
         ASS_Vector offs = { dv, -desc };
-        if (!ass_outline_rotate_90(outline, offs))
+        if (!outline_rotate_90(outline, offs))
             goto fail;
     }
 
@@ -775,10 +755,10 @@ bool ass_get_glyph_outline(ASS_Outline *outline, int32_t *advance,
     FT_Orientation dir = FT_Outline_Get_Orientation(source);
     int iy = (dir == FT_ORIENTATION_TRUETYPE ? 0 : 1);
     for (int i = 0; i < n_lines; i++)
-        ass_outline_add_rect(outline, 0, line_y[i][iy], adv, line_y[i][iy ^ 1]);
+        outline_add_rect(outline, 0, line_y[i][iy], adv, line_y[i][iy ^ 1]);
     return true;
 
 fail:
-    ass_outline_free(outline);
+    outline_free(outline);
     return false;
 }
diff --git a/libass/ass_font.h b/libass/ass_font.h
index ea1130f..02d4508 100644
--- a/libass/ass_font.h
+++ b/libass/ass_font.h
@@ -49,9 +49,10 @@ struct ass_font {
     double size;
 };
 
-void ass_charmap_magic(ASS_Library *library, FT_Face face);
+void charmap_magic(ASS_Library *library, FT_Face face);
 ASS_Font *ass_font_new(ASS_Renderer *render_priv, ASS_FontDesc *desc);
 void ass_face_set_size(FT_Face face, double size);
+void ass_font_set_size(ASS_Font *font, double size);
 int ass_face_get_weight(FT_Face face);
 void ass_font_get_asc_desc(ASS_Font *font, int face_index,
                            int *asc, int *desc);
diff --git a/libass/ass_fontselect.c b/libass/ass_fontselect.c
index df07336..c229189 100644
--- a/libass/ass_fontselect.c
+++ b/libass/ass_fontselect.c
@@ -182,7 +182,7 @@ static void load_fonts_from_dir(ASS_Library *library, const char *dir)
             continue;
         ass_msg(library, MSGL_INFO, "Loading font file '%s'", path);
         size_t size = 0;
-        void *data = ass_load_file(library, path, FN_DIR_LIST, &size);
+        void *data = read_file(library, path, FN_DIR_LIST, &size);
         if (data) {
             ass_add_font(library, name, data, size);
             free(data);
@@ -891,7 +891,7 @@ static char *select_font(ASS_FontSelector *priv,
  * \return font file path
 */
 char *ass_font_select(ASS_FontSelector *priv,
-                      const ASS_Font *font, int *index, char **postscript_name,
+                      ASS_Font *font, int *index, char **postscript_name,
                       int *uid, ASS_FontStream *data, uint32_t code)
 {
     char *res = 0;
@@ -984,7 +984,7 @@ static void process_fontdata(ASS_FontProvider *priv, int idx)
 
         num_faces = face->num_faces;
 
-        ass_charmap_magic(library, face);
+        charmap_magic(library, face);
 
         memset(&info, 0, sizeof(ASS_FontProviderMetaData));
         if (!get_font_info(selector->ftlibrary, face, NULL, &info)) {
@@ -1092,16 +1092,10 @@ ass_fontselect_init(ASS_Library *library, FT_Library ftlibrary, size_t *num_emfo
     priv->path_default = path ? strdup(path) : NULL;
     priv->index_default = 0;
 
-    if (family && !priv->family_default)
-        goto fail;
-    if (path && !priv->path_default)
-        goto fail;
-
     priv->embedded_provider = ass_embedded_fonts_add_provider(priv, num_emfonts);
 
     if (priv->embedded_provider == NULL) {
         ass_msg(library, MSGL_WARN, "failed to create embedded font provider");
-        goto fail;
     }
 
     if (dfp >= ASS_FONTPROVIDER_AUTODETECT) {
@@ -1124,19 +1118,6 @@ ass_fontselect_init(ASS_Library *library, FT_Library ftlibrary, size_t *num_emfo
     }
 
     return priv;
-
-fail:
-    if (priv->default_provider)
-        ass_font_provider_free(priv->default_provider);
-    if (priv->embedded_provider)
-        ass_font_provider_free(priv->embedded_provider);
-
-    free(priv->family_default);
-    free(priv->path_default);
-
-    free(priv);
-
-    return NULL;
 }
 
 void ass_get_available_font_providers(ASS_Library *priv,
diff --git a/libass/ass_fontselect.h b/libass/ass_fontselect.h
index 07fad7b..522c729 100644
--- a/libass/ass_fontselect.h
+++ b/libass/ass_fontselect.h
@@ -246,7 +246,7 @@ ass_fontselect_init(ASS_Library *library, FT_Library ftlibrary, size_t *num_emfo
                     const char *family, const char *path, const char *config,
                     ASS_DefaultFontProvider dfp);
 char *ass_font_select(ASS_FontSelector *priv,
-                      const ASS_Font *font, int *index, char **postscript_name,
+                      ASS_Font *font, int *index, char **postscript_name,
                       int *uid, ASS_FontStream *data, uint32_t code);
 void ass_fontselect_free(ASS_FontSelector *priv);
 
diff --git a/libass/ass_library.c b/libass/ass_library.c
index 42cabbd..745798e 100644
--- a/libass/ass_library.c
+++ b/libass/ass_library.c
@@ -24,9 +24,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
-#ifdef CONFIG_UNIBREAK
-#include <linebreak.h>
-#endif
 
 #include "ass.h"
 #include "ass_library.h"
@@ -47,10 +44,6 @@ ASS_Library *ass_library_init(void)
     ASS_Library* lib = calloc(1, sizeof(*lib));
     if (lib)
         lib->msg_callback = ass_msg_handler;
-    #ifdef CONFIG_UNIBREAK
-    // libunibreak works without, but its docs suggest this improves performance
-    init_linebreak();
-    #endif
     return lib;
 }
 
diff --git a/libass/ass_library.h b/libass/ass_library.h
index 0a97960..e30609f 100644
--- a/libass/ass_library.h
+++ b/libass/ass_library.h
@@ -40,6 +40,6 @@ struct ass_library {
     void *msg_callback_data;
 };
 
-char *ass_load_file(struct ass_library *library, const char *fname, FileNameSource hint, size_t *bufsize);
+char *read_file(struct ass_library *library, const char *fname, FileNameSource hint, size_t *bufsize);
 
 #endif                          /* LIBASS_LIBRARY_H */
diff --git a/libass/ass_outline.c b/libass/ass_outline.c
index 7434283..2bdc31a 100644
--- a/libass/ass_outline.c
+++ b/libass/ass_outline.c
@@ -28,7 +28,7 @@
  * \brief Initialize ASS_Outline to an empty state
  * Equivalent to zeroing of outline object and doesn't free any memory.
  */
-void ass_outline_clear(ASS_Outline *outline)
+void outline_clear(ASS_Outline *outline)
 {
     outline->points = NULL;
     outline->segments = NULL;
@@ -40,17 +40,17 @@ void ass_outline_clear(ASS_Outline *outline)
 /*
  * \brief Initialize ASS_Outline and allocate memory
  */
-bool ass_outline_alloc(ASS_Outline *outline, size_t max_points, size_t max_segments)
+bool outline_alloc(ASS_Outline *outline, size_t max_points, size_t max_segments)
 {
     assert(max_points && max_segments);
     if (max_points > SIZE_MAX / sizeof(ASS_Vector)) {
-        ass_outline_clear(outline);
+        outline_clear(outline);
         return false;
     }
     outline->points = malloc(sizeof(ASS_Vector) * max_points);
     outline->segments = malloc(max_segments);
     if (!outline->points || !outline->segments) {
-        ass_outline_free(outline);
+        outline_free(outline);
         return false;
     }
 
@@ -62,10 +62,10 @@ bool ass_outline_alloc(ASS_Outline *outline, size_t max_points, size_t max_segme
 
 /*
  * \brief Free previously initialized ASS_Outline
- * Outline state after the call is the same as after ass_outline_clear().
+ * Outline state after the call is the same as after outline_clear().
  * Outline pointer can be NULL.
  */
-void ass_outline_free(ASS_Outline *outline)
+void outline_free(ASS_Outline *outline)
 {
     if (!outline)
         return;
@@ -73,7 +73,7 @@ void ass_outline_free(ASS_Outline *outline)
     free(outline->points);
     free(outline->segments);
 
-    ass_outline_clear(outline);
+    outline_clear(outline);
 }
 
 
@@ -86,7 +86,7 @@ static bool valid_point(const FT_Vector *pt)
  * \brief Convert FT_Ouline into ASS_Outline
  * Outline should be preallocated to a sufficient size.
  */
-bool ass_outline_convert(ASS_Outline *outline, const FT_Outline *source)
+bool outline_convert(ASS_Outline *outline, const FT_Outline *source)
 {
     enum Status {
         S_ON, S_Q, S_C1, S_C2
@@ -245,8 +245,8 @@ bool ass_outline_convert(ASS_Outline *outline, const FT_Outline *source)
  * Outline should be preallocated to a sufficient size
  * and coordinates should be in the allowable range.
  */
-void ass_outline_add_rect(ASS_Outline *outline,
-                          int32_t x0, int32_t y0, int32_t x1, int32_t y1)
+void outline_add_rect(ASS_Outline *outline,
+                      int32_t x0, int32_t y0, int32_t x1, int32_t y1)
 {
     assert(outline->n_points + 4 <= outline->max_points);
     assert(outline->n_segments + 4 <= outline->max_segments);
@@ -276,7 +276,7 @@ void ass_outline_add_rect(ASS_Outline *outline,
  * Outline should be allocated and will be enlarged if needed.
  * Also adds outline segment if segment parameter is nonzero.
  */
-bool ass_outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)
+bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)
 {
     assert(outline->max_points);
     if (abs(pt.x) > OUTLINE_MAX || abs(pt.y) > OUTLINE_MAX)
@@ -291,14 +291,14 @@ bool ass_outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment)
     outline->points[outline->n_points] = pt;
     outline->n_points++;
 
-    return !segment || ass_outline_add_segment(outline, segment);
+    return !segment || outline_add_segment(outline, segment);
 }
 
 /*
  * \brief Add a segment to the outline
  * Outline should be allocated and will be enlarged if needed.
  */
-bool ass_outline_add_segment(ASS_Outline *outline, char segment)
+bool outline_add_segment(ASS_Outline *outline, char segment)
 {
     assert(outline->max_segments);
     if (outline->n_segments >= outline->max_segments) {
@@ -315,7 +315,7 @@ bool ass_outline_add_segment(ASS_Outline *outline, char segment)
 /*
  * \brief Close last contour
  */
-void ass_outline_close_contour(ASS_Outline *outline)
+void outline_close_contour(ASS_Outline *outline)
 {
     assert(outline->n_segments);
     assert(!(outline->segments[outline->n_segments - 1] & ~OUTLINE_COUNT_MASK));
@@ -326,7 +326,7 @@ void ass_outline_close_contour(ASS_Outline *outline)
 /*
  * \brief Inplace rotate outline by 90 degrees and translate by offs
  */
-bool ass_outline_rotate_90(ASS_Outline *outline, ASS_Vector offs)
+bool outline_rotate_90(ASS_Outline *outline, ASS_Vector offs)
 {
     assert(abs(offs.x) <= INT32_MAX - OUTLINE_MAX);
     assert(abs(offs.y) <= INT32_MAX - OUTLINE_MAX);
@@ -345,11 +345,11 @@ bool ass_outline_rotate_90(ASS_Outline *outline, ASS_Vector offs)
  * Result outline should be uninitialized or empty.
  * Source outline can be NULL.
  */
-bool ass_outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
-                            int scale_ord_x, int scale_ord_y)
+bool outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
+                        int scale_ord_x, int scale_ord_y)
 {
     if (!source || !source->n_points) {
-        ass_outline_clear(outline);
+        outline_clear(outline);
         return true;
     }
 
@@ -366,11 +366,11 @@ bool ass_outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
         scale_ord_y = FFMAX(scale_ord_y, -32);
 
     if (!lim_x || !lim_y) {
-        ass_outline_clear(outline);
+        outline_clear(outline);
         return false;
     }
 
-    if (!ass_outline_alloc(outline, source->n_points, source->n_segments))
+    if (!outline_alloc(outline, source->n_points, source->n_segments))
         return false;
 
     int sx = scale_ord_x + 32;
@@ -378,7 +378,7 @@ bool ass_outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
     const ASS_Vector *pt = source->points;
     for (size_t i = 0; i < source->n_points; i++) {
         if (abs(pt[i].x) > lim_x || abs(pt[i].y) > lim_y) {
-            ass_outline_free(outline);
+            outline_free(outline);
             return false;
         }
         // that's equivalent to pt[i].x << scale_ord_x,
@@ -397,15 +397,15 @@ bool ass_outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
  * Result outline should be uninitialized or empty.
  * Source outline can be NULL.
  */
-bool ass_outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
-                              const double m[2][3])
+bool outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
+                         const double m[2][3])
 {
     if (!source || !source->n_points) {
-        ass_outline_clear(outline);
+        outline_clear(outline);
         return true;
     }
 
-    if (!ass_outline_alloc(outline, source->n_points, source->n_segments))
+    if (!outline_alloc(outline, source->n_points, source->n_segments))
         return false;
 
     const ASS_Vector *pt = source->points;
@@ -415,7 +415,7 @@ bool ass_outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
             v[k] = m[k][0] * pt[i].x + m[k][1] * pt[i].y + m[k][2];
 
         if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {
-            ass_outline_free(outline);
+            outline_free(outline);
             return false;
         }
         outline->points[i].x = lrint(v[0]);
@@ -432,15 +432,15 @@ bool ass_outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
  * Result outline should be uninitialized or empty.
  * Source outline can be NULL.
  */
-bool ass_outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
-                              const double m[3][3])
+bool outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
+                         const double m[3][3])
 {
     if (!source || !source->n_points) {
-        ass_outline_clear(outline);
+        outline_clear(outline);
         return true;
     }
 
-    if (!ass_outline_alloc(outline, source->n_points, source->n_segments))
+    if (!outline_alloc(outline, source->n_points, source->n_segments))
         return false;
 
     const ASS_Vector *pt = source->points;
@@ -454,7 +454,7 @@ bool ass_outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
         v[1] *= w;
 
         if (!(fabs(v[0]) < OUTLINE_MAX && fabs(v[1]) < OUTLINE_MAX)) {
-            ass_outline_free(outline);
+            outline_free(outline);
             return false;
         }
         outline->points[i].x = lrint(v[0]);
@@ -469,9 +469,9 @@ bool ass_outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
 /*
  * \brief Find minimal X-coordinate of control points after perspective transform
  */
-void ass_outline_update_min_transformed_x(const ASS_Outline *outline,
-                                          const double m[3][3],
-                                          int32_t *min_x) {
+void outline_update_min_transformed_x(const ASS_Outline *outline,
+                                      const double m[3][3],
+                                      int32_t *min_x) {
     const ASS_Vector *pt = outline->points;
     for (size_t i = 0; i < outline->n_points; i++) {
         double z = m[2][0] * pt[i].x + m[2][1] * pt[i].y + m[2][2];
@@ -486,7 +486,7 @@ void ass_outline_update_min_transformed_x(const ASS_Outline *outline,
 /*
  * \brief Update bounding box of control points
  */
-void ass_outline_update_cbox(const ASS_Outline *outline, ASS_Rect *cbox)
+void outline_update_cbox(const ASS_Outline *outline, ASS_Rect *cbox)
 {
     for (size_t i = 0; i < outline->n_points; i++)
         rectangle_update(cbox,
@@ -622,12 +622,12 @@ static bool emit_point(StrokerState *str, ASS_Vector pt,
 
     if (dir & 1) {
         ASS_Vector res = { pt.x + dx, pt.y + dy };
-        if (!ass_outline_add_point(str->result[0], res, segment))
+        if (!outline_add_point(str->result[0], res, segment))
             return false;
     }
     if (dir & 2) {
         ASS_Vector res = { pt.x - dx, pt.y - dy };
-        if (!ass_outline_add_point(str->result[1], res, segment))
+        if (!outline_add_point(str->result[1], res, segment))
             return false;
     }
     return true;
@@ -1466,9 +1466,9 @@ static bool close_contour(StrokerState *str, int dir)
         str->contour_start = true;
     }
     if (dir & 1)
-        ass_outline_close_contour(str->result[0]);
+        outline_close_contour(str->result[0]);
     if (dir & 2)
-        ass_outline_close_contour(str->result[1]);
+        outline_close_contour(str->result[1]);
     str->contour_first[0] = str->result[0]->n_points;
     str->contour_first[1] = str->result[1]->n_points;
     return true;
@@ -1485,11 +1485,11 @@ static bool close_contour(StrokerState *str, int dir)
  * \param eps approximate allowable error
  * \return false on allocation failure
  */
-bool ass_outline_stroke(ASS_Outline *result, ASS_Outline *result1,
-                        const ASS_Outline *path, int xbord, int ybord, int eps)
+bool outline_stroke(ASS_Outline *result, ASS_Outline *result1,
+                    const ASS_Outline *path, int xbord, int ybord, int eps)
 {
-    ass_outline_alloc(result,  2 * path->n_points, 2 * path->n_segments);
-    ass_outline_alloc(result1, 2 * path->n_points, 2 * path->n_segments);
+    outline_alloc(result,  2 * path->n_points, 2 * path->n_segments);
+    outline_alloc(result1, 2 * path->n_points, 2 * path->n_segments);
     if (!result->max_points || !result1->max_points)
         return false;
 
diff --git a/libass/ass_outline.h b/libass/ass_outline.h
index 25848b5..a7fe580 100644
--- a/libass/ass_outline.h
+++ b/libass/ass_outline.h
@@ -87,40 +87,40 @@ typedef struct {
 #define OUTLINE_MAX  (((int32_t) 1 << 28) - 1)
 // cubic spline splitting requires 8 * OUTLINE_MAX + 4 <= INT32_MAX
 
-void ass_outline_clear(ASS_Outline *outline);
-bool ass_outline_alloc(ASS_Outline *outline, size_t n_points, size_t n_segments);
-void ass_outline_free(ASS_Outline *outline);
+void outline_clear(ASS_Outline *outline);
+bool outline_alloc(ASS_Outline *outline, size_t n_points, size_t n_segments);
+void outline_free(ASS_Outline *outline);
 
 // expects preallocated outline and works inplace
-bool ass_outline_convert(ASS_Outline *outline, const FT_Outline *source);
-void ass_outline_add_rect(ASS_Outline *outline,
-                          int32_t x0, int32_t y0, int32_t x1, int32_t y1);
+bool outline_convert(ASS_Outline *outline, const FT_Outline *source);
+void outline_add_rect(ASS_Outline *outline,
+                      int32_t x0, int32_t y0, int32_t x1, int32_t y1);
 
 // enlarges outline automatically
-bool ass_outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment);
-bool ass_outline_add_segment(ASS_Outline *outline, char segment);
-void ass_outline_close_contour(ASS_Outline *outline);
+bool outline_add_point(ASS_Outline *outline, ASS_Vector pt, char segment);
+bool outline_add_segment(ASS_Outline *outline, char segment);
+void outline_close_contour(ASS_Outline *outline);
 
 // works inplace
-bool ass_outline_rotate_90(ASS_Outline *outline, ASS_Vector offs);
+bool outline_rotate_90(ASS_Outline *outline, ASS_Vector offs);
 
 // creates a new outline for the result
-bool ass_outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
-                            int scale_ord_x, int scale_ord_y);
-bool ass_outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
-                              const double m[2][3]);
-bool ass_outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
-                              const double m[3][3]);
+bool outline_scale_pow2(ASS_Outline *outline, const ASS_Outline *source,
+                        int scale_ord_x, int scale_ord_y);
+bool outline_transform_2d(ASS_Outline *outline, const ASS_Outline *source,
+                          const double m[2][3]);
+bool outline_transform_3d(ASS_Outline *outline, const ASS_Outline *source,
+                          const double m[3][3]);
 
 // info queries
-void ass_outline_update_min_transformed_x(const ASS_Outline *outline,
-                                          const double m[3][3],
-                                          int32_t *min_x);
-void ass_outline_update_cbox(const ASS_Outline *outline, ASS_Rect *cbox);
+void outline_update_min_transformed_x(const ASS_Outline *outline,
+                                      const double m[3][3],
+                                      int32_t *min_x);
+void outline_update_cbox(const ASS_Outline *outline, ASS_Rect *cbox);
 
 // creates new outlines for the results (positive and negative offset outlines)
-bool ass_outline_stroke(ASS_Outline *result, ASS_Outline *result1,
-                        const ASS_Outline *path, int xbord, int ybord, int eps);
+bool outline_stroke(ASS_Outline *result, ASS_Outline *result1,
+                    const ASS_Outline *path, int xbord, int ybord, int eps);
 
 
 #endif /* LIBASS_OUTLINE_H */
diff --git a/libass/ass_parse.c b/libass/ass_parse.c
index fae575a..9dc59f3 100644
--- a/libass/ass_parse.c
+++ b/libass/ass_parse.c
@@ -77,15 +77,25 @@ static inline int mystrcmp(char **p, const char *sample)
     return 0;
 }
 
+double ensure_font_size(ASS_Renderer *priv, double size)
+{
+    if (size < 1)
+        size = 1;
+    else if (size > priv->height * 2)
+        size = priv->height * 2;
+
+    return size;
+}
+
 /**
  * \brief Change current font, using setting from render_priv->state.
  */
-void ass_update_font(RenderContext *state)
+void update_font(ASS_Renderer *render_priv)
 {
     unsigned val;
     ASS_FontDesc desc;
 
-    desc.family = state->family;
+    desc.family = render_priv->state.family;
     if (!desc.family.str)
         return;
     if (desc.family.len && desc.family.str[0] == '@') {
@@ -96,7 +106,7 @@ void ass_update_font(RenderContext *state)
         desc.vertical = 0;
     }
 
-    val = state->bold;
+    val = render_priv->state.bold;
     // 0 = normal, 1 = bold, >1 = exact weight
     if (val == 1 || val == -1)
         val = 700;               // bold
@@ -104,15 +114,15 @@ void ass_update_font(RenderContext *state)
         val = 400;               // normal
     desc.bold = val;
 
-    val = state->italic;
+    val = render_priv->state.italic;
     if (val == 1)
         val = 100;              // italic
     else if (val <= 0)
         val = 0;                // normal
     desc.italic = val;
 
-    ass_cache_dec_ref(state->font);
-    state->font = ass_font_new(state->renderer, &desc);
+    ass_cache_dec_ref(render_priv->state.font);
+    render_priv->state.font = ass_font_new(render_priv, &desc);
 }
 
 /**
@@ -153,9 +163,9 @@ static void change_color(uint32_t *var, uint32_t new, double pwr)
 }
 
 // like change_color, but for alpha component only
-static inline void change_alpha(uint32_t *var, int32_t new, double pwr)
+inline void change_alpha(uint32_t *var, int32_t new, double pwr)
 {
-    *var = (*var & 0xFFFFFF00) | (uint8_t)calc_anim_int32(new, _a(*var), pwr);
+    *var = (*var & 0xFFFFFF00) | (uint8_t)calc_anim_int32(_a(new), _a(*var), pwr);
 }
 
 /**
@@ -166,18 +176,11 @@ static inline void change_alpha(uint32_t *var, int32_t new, double pwr)
  * At least one of the parameters must be less than or equal to 0xFF.
  * The result is less than or equal to max(a, b, 0xFF).
  */
-static inline uint32_t mult_alpha(uint32_t a, uint32_t b)
+inline uint32_t mult_alpha(uint32_t a, uint32_t b)
 {
     return a - ((uint64_t) a * b + 0x7F) / 0xFF + b;
 }
 
-void ass_apply_fade(uint32_t *clr, int fade)
-{
-    // VSFilter compatibility: apply fade only when it's positive
-    if (fade > 0)
-        change_alpha(clr, mult_alpha(_a(*clr), fade), 1);
-}
-
 /**
  * \brief Calculate alpha value by piecewise linear function
  * Used for \fad, \fade implementation.
@@ -212,7 +215,7 @@ interpolate_alpha(long long now, int32_t t1, int32_t t2, int32_t t3,
  * Parse a vector clip into an outline, using the proper scaling
  * parameters.  Translate it to correct for screen borders, if needed.
  */
-static bool parse_vector_clip(RenderContext *state,
+static bool parse_vector_clip(ASS_Renderer *render_priv,
                               struct arg *args, int nargs)
 {
     if (nargs != 1 && nargs != 2)
@@ -223,56 +226,12 @@ static bool parse_vector_clip(RenderContext *state,
         scale = argtoi32(args[0]);
 
     struct arg text = args[nargs - 1];
-    state->clip_drawing_text.str = text.start;
-    state->clip_drawing_text.len = text.end - text.start;
-    state->clip_drawing_scale = scale;
+    render_priv->state.clip_drawing_text.str = text.start;
+    render_priv->state.clip_drawing_text.len = text.end - text.start;
+    render_priv->state.clip_drawing_scale = scale;
     return true;
 }
 
-static int32_t parse_alpha_tag(char *str)
-{
-    int32_t alpha = 0;
-
-    while (*str == '&' || *str == 'H')
-        ++str;
-
-    mystrtoi32(&str, 16, &alpha);
-    return alpha;
-}
-
-static uint32_t parse_color_tag(char *str)
-{
-    int32_t color = 0;
-
-    while (*str == '&' || *str == 'H')
-        ++str;
-
-    mystrtoi32(&str, 16, &color);
-    return ass_bswap32((uint32_t) color);
-}
-
-/**
- * \brief find style by name as in \r
- * \param track track
- * \param name style name
- * \param len style name length
- * \return style in track->styles
- * Returns NULL if no style has the given name.
- */
-static ASS_Style *lookup_style_strict(ASS_Track *track, char *name, size_t len)
-{
-    int i;
-    for (i = track->n_styles - 1; i >= 0; --i) {
-        if (strncmp(track->styles[i].Name, name, len) == 0 &&
-            track->styles[i].Name[len] == '\0')
-            return track->styles + i;
-    }
-    ass_msg(track->library, MSGL_WARN,
-            "[%p]: Warning: no style named '%.*s' found",
-            track, (int) len, name);
-    return NULL;
-}
-
 /**
  * \brief Parse style override tags.
  * \param p string to parse
@@ -280,10 +239,9 @@ static ASS_Style *lookup_style_strict(ASS_Track *track, char *name, size_t len)
  *            of a number of spaces immediately preceding '}' or ')'
  * \param pwr multiplier for some tag effects (comes from \t tags)
  */
-char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
-                     bool nested)
+char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr,
+                 bool nested)
 {
-    ASS_Renderer *render_priv = state->renderer;
     for (char *q; p < end; p = q) {
         while (*p != '\\' && p != end)
             ++p;
@@ -354,52 +312,52 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
             double val;
             if (nargs) {
                 val = argtod(*args);
-                val = state->border_x * (1 - pwr) + val * pwr;
+                val = render_priv->state.border_x * (1 - pwr) + val * pwr;
                 val = (val < 0) ? 0 : val;
             } else
-                val = state->style->Outline;
-            state->border_x = val;
+                val = render_priv->state.style->Outline;
+            render_priv->state.border_x = val;
         } else if (tag("ybord")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                val = state->border_y * (1 - pwr) + val * pwr;
+                val = render_priv->state.border_y * (1 - pwr) + val * pwr;
                 val = (val < 0) ? 0 : val;
             } else
-                val = state->style->Outline;
-            state->border_y = val;
+                val = render_priv->state.style->Outline;
+            render_priv->state.border_y = val;
         } else if (tag("xshad")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                val = state->shadow_x * (1 - pwr) + val * pwr;
+                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
             } else
-                val = state->style->Shadow;
-            state->shadow_x = val;
+                val = render_priv->state.style->Shadow;
+            render_priv->state.shadow_x = val;
         } else if (tag("yshad")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                val = state->shadow_y * (1 - pwr) + val * pwr;
+                val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;
             } else
-                val = state->style->Shadow;
-            state->shadow_y = val;
+                val = render_priv->state.style->Shadow;
+            render_priv->state.shadow_y = val;
         } else if (tag("fax")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                state->fax =
-                    val * pwr + state->fax * (1 - pwr);
+                render_priv->state.fax =
+                    val * pwr + render_priv->state.fax * (1 - pwr);
             } else
-                state->fax = 0.;
+                render_priv->state.fax = 0.;
         } else if (tag("fay")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                state->fay =
-                    val * pwr + state->fay * (1 - pwr);
+                render_priv->state.fay =
+                    val * pwr + render_priv->state.fay * (1 - pwr);
             } else
-                state->fay = 0.;
+                render_priv->state.fay = 0.;
         } else if (complex_tag("iclip")) {
             if (nargs == 4) {
                 int32_t x0, y0, x1, y1;
@@ -407,83 +365,83 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 y0 = argtoi32(args[1]);
                 x1 = argtoi32(args[2]);
                 y1 = argtoi32(args[3]);
-                state->clip_x0 =
-                    state->clip_x0 * (1 - pwr) + x0 * pwr;
-                state->clip_x1 =
-                    state->clip_x1 * (1 - pwr) + x1 * pwr;
-                state->clip_y0 =
-                    state->clip_y0 * (1 - pwr) + y0 * pwr;
-                state->clip_y1 =
-                    state->clip_y1 * (1 - pwr) + y1 * pwr;
-                state->clip_mode = 1;
-            } else if (!state->clip_drawing_text.str) {
-                if (parse_vector_clip(state, args, nargs))
-                    state->clip_drawing_mode = 1;
+                render_priv->state.clip_x0 =
+                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
+                render_priv->state.clip_x1 =
+                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
+                render_priv->state.clip_y0 =
+                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
+                render_priv->state.clip_y1 =
+                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
+                render_priv->state.clip_mode = 1;
+            } else if (!render_priv->state.clip_drawing_text.str) {
+                if (parse_vector_clip(render_priv, args, nargs))
+                    render_priv->state.clip_drawing_mode = 1;
             }
         } else if (tag("blur")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                val = state->blur * (1 - pwr) + val * pwr;
+                val = render_priv->state.blur * (1 - pwr) + val * pwr;
                 val = (val < 0) ? 0 : val;
                 val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
-                state->blur = val;
+                render_priv->state.blur = val;
             } else
-                state->blur = 0.0;
+                render_priv->state.blur = 0.0;
             // ASS standard tags
         } else if (tag("fscx")) {
             double val;
             if (nargs) {
                 val = argtod(*args) / 100;
-                val = state->scale_x * (1 - pwr) + val * pwr;
+                val = render_priv->state.scale_x * (1 - pwr) + val * pwr;
                 val = (val < 0) ? 0 : val;
             } else
-                val = state->style->ScaleX;
-            state->scale_x = val;
+                val = render_priv->state.style->ScaleX;
+            render_priv->state.scale_x = val;
         } else if (tag("fscy")) {
             double val;
             if (nargs) {
                 val = argtod(*args) / 100;
-                val = state->scale_y * (1 - pwr) + val * pwr;
+                val = render_priv->state.scale_y * (1 - pwr) + val * pwr;
                 val = (val < 0) ? 0 : val;
             } else
-                val = state->style->ScaleY;
-            state->scale_y = val;
+                val = render_priv->state.style->ScaleY;
+            render_priv->state.scale_y = val;
         } else if (tag("fsc")) {
-            state->scale_x = state->style->ScaleX;
-            state->scale_y = state->style->ScaleY;
+            render_priv->state.scale_x = render_priv->state.style->ScaleX;
+            render_priv->state.scale_y = render_priv->state.style->ScaleY;
         } else if (tag("fsp")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                state->hspacing =
-                    state->hspacing * (1 - pwr) + val * pwr;
+                render_priv->state.hspacing =
+                    render_priv->state.hspacing * (1 - pwr) + val * pwr;
             } else
-                state->hspacing = state->style->Spacing;
+                render_priv->state.hspacing = render_priv->state.style->Spacing;
         } else if (tag("fs")) {
             double val = 0;
             if (nargs) {
                 val = argtod(*args);
                 if (*args->start == '+' || *args->start == '-')
-                    val = state->font_size * (1 + pwr * val / 10);
+                    val = render_priv->state.font_size * (1 + pwr * val / 10);
                 else
-                    val = state->font_size * (1 - pwr) + val * pwr;
+                    val = render_priv->state.font_size * (1 - pwr) + val * pwr;
             }
             if (val <= 0)
-                val = state->style->FontSize;
-            state->font_size = val;
+                val = render_priv->state.style->FontSize;
+            render_priv->state.font_size = val;
         } else if (tag("bord")) {
             double val, xval, yval;
             if (nargs) {
                 val = argtod(*args);
-                xval = state->border_x * (1 - pwr) + val * pwr;
-                yval = state->border_y * (1 - pwr) + val * pwr;
+                xval = render_priv->state.border_x * (1 - pwr) + val * pwr;
+                yval = render_priv->state.border_y * (1 - pwr) + val * pwr;
                 xval = (xval < 0) ? 0 : xval;
                 yval = (yval < 0) ? 0 : yval;
             } else
-                xval = yval = state->style->Outline;
-            state->border_x = xval;
-            state->border_y = yval;
+                xval = yval = render_priv->state.style->Outline;
+            render_priv->state.border_x = xval;
+            render_priv->state.border_y = yval;
         } else if (complex_tag("move")) {
             double x1, x2, y1, y2;
             int32_t t1, t2, delta_t, t;
@@ -508,10 +466,10 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 continue;
             if (t1 <= 0 && t2 <= 0) {
                 t1 = 0;
-                t2 = state->event->Duration;
+                t2 = render_priv->state.event->Duration;
             }
             delta_t = (uint32_t) t2 - t1;
-            t = render_priv->time - state->event->Start;
+            t = render_priv->time - render_priv->state.event->Start;
             if (t <= t1)
                 k = 0.;
             else if (t >= t2)
@@ -520,86 +478,86 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 k = ((double) (int32_t) ((uint32_t) t - t1)) / delta_t;
             x = k * (x2 - x1) + x1;
             y = k * (y2 - y1) + y1;
-            if (!(state->evt_type & EVENT_POSITIONED)) {
-                state->pos_x = x;
-                state->pos_y = y;
-                state->detect_collisions = 0;
-                state->evt_type |= EVENT_POSITIONED;
+            if (!(render_priv->state.evt_type & EVENT_POSITIONED)) {
+                render_priv->state.pos_x = x;
+                render_priv->state.pos_y = y;
+                render_priv->state.detect_collisions = 0;
+                render_priv->state.evt_type |= EVENT_POSITIONED;
             }
         } else if (tag("frx")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                state->frx =
-                    val * pwr + state->frx * (1 - pwr);
+                render_priv->state.frx =
+                    val * pwr + render_priv->state.frx * (1 - pwr);
             } else
-                state->frx = 0.;
+                render_priv->state.frx = 0.;
         } else if (tag("fry")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                state->fry =
-                    val * pwr + state->fry * (1 - pwr);
+                render_priv->state.fry =
+                    val * pwr + render_priv->state.fry * (1 - pwr);
             } else
-                state->fry = 0.;
+                render_priv->state.fry = 0.;
         } else if (tag("frz") || tag("fr")) {
             double val;
             if (nargs) {
                 val = argtod(*args);
-                state->frz =
-                    val * pwr + state->frz * (1 - pwr);
+                render_priv->state.frz =
+                    val * pwr + render_priv->state.frz * (1 - pwr);
             } else
-                state->frz =
-                    state->style->Angle;
+                render_priv->state.frz =
+                    render_priv->state.style->Angle;
         } else if (tag("fn")) {
             char *start = args->start;
             if (nargs && strncmp(start, "0", args->end - start)) {
                 skip_spaces(&start);
-                state->family.str = start;
-                state->family.len = args->end - start;
+                render_priv->state.family.str = start;
+                render_priv->state.family.len = args->end - start;
             } else {
-                state->family.str = state->style->FontName;
-                state->family.len = strlen(state->style->FontName);
+                render_priv->state.family.str = render_priv->state.style->FontName;
+                render_priv->state.family.len = strlen(render_priv->state.style->FontName);
             }
-            ass_update_font(state);
+            update_font(render_priv);
         } else if (tag("alpha")) {
             int i;
             if (nargs) {
                 int32_t a = parse_alpha_tag(args->start);
                 for (i = 0; i < 4; ++i)
-                    change_alpha(&state->c[i], a, pwr);
+                    change_alpha(&render_priv->state.c[i], a, pwr);
             } else {
-                change_alpha(&state->c[0],
-                             _a(state->style->PrimaryColour), 1);
-                change_alpha(&state->c[1],
-                             _a(state->style->SecondaryColour), 1);
-                change_alpha(&state->c[2],
-                             _a(state->style->OutlineColour), 1);
-                change_alpha(&state->c[3],
-                             _a(state->style->BackColour), 1);
+                change_alpha(&render_priv->state.c[0],
+                             _a(render_priv->state.style->PrimaryColour), 1);
+                change_alpha(&render_priv->state.c[1],
+                             _a(render_priv->state.style->SecondaryColour), 1);
+                change_alpha(&render_priv->state.c[2],
+                             _a(render_priv->state.style->OutlineColour), 1);
+                change_alpha(&render_priv->state.c[3],
+                             _a(render_priv->state.style->BackColour), 1);
             }
             // FIXME: simplify
         } else if (tag("an")) {
             int32_t val = argtoi32(*args);
-            if ((state->parsed_tags & PARSED_A) == 0) {
+            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {
                 if (val >= 1 && val <= 9)
-                    state->alignment = numpad2align(val);
+                    render_priv->state.alignment = numpad2align(val);
                 else
-                    state->alignment =
-                        state->style->Alignment;
-                state->parsed_tags |= PARSED_A;
+                    render_priv->state.alignment =
+                        render_priv->state.style->Alignment;
+                render_priv->state.parsed_tags |= PARSED_A;
             }
         } else if (tag("a")) {
             int32_t val = argtoi32(*args);
-            if ((state->parsed_tags & PARSED_A) == 0) {
+            if ((render_priv->state.parsed_tags & PARSED_A) == 0) {
                 if (val >= 1 && val <= 11)
                     // take care of a vsfilter quirk:
                     // handle illegal \a8 and \a4 like \a5
-                    state->alignment = ((val & 3) == 0) ? 5 : val;
+                    render_priv->state.alignment = ((val & 3) == 0) ? 5 : val;
                 else
-                    state->alignment =
-                        state->style->Alignment;
-                state->parsed_tags |= PARSED_A;
+                    render_priv->state.alignment =
+                        render_priv->state.style->Alignment;
+                render_priv->state.parsed_tags |= PARSED_A;
             }
         } else if (complex_tag("pos")) {
             double v1, v2;
@@ -608,14 +566,14 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 v2 = argtod(args[1]);
             } else
                 continue;
-            if (state->evt_type & EVENT_POSITIONED) {
+            if (render_priv->state.evt_type & EVENT_POSITIONED) {
                 ass_msg(render_priv->library, MSGL_V, "Subtitle has a new \\pos "
                        "after \\move or \\pos, ignoring");
             } else {
-                state->evt_type |= EVENT_POSITIONED;
-                state->detect_collisions = 0;
-                state->pos_x = v1;
-                state->pos_y = v2;
+                render_priv->state.evt_type |= EVENT_POSITIONED;
+                render_priv->state.detect_collisions = 0;
+                render_priv->state.pos_x = v1;
+                render_priv->state.pos_y = v2;
             }
         } else if (complex_tag("fade") || complex_tag("fad")) {
             int32_t a1, a2, a3;
@@ -642,15 +600,15 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 continue;
             if (t1 == -1 && t4 == -1) {
                 t1 = 0;
-                t4 = state->event->Duration;
+                t4 = render_priv->state.event->Duration;
                 t3 = (uint32_t) t4 - t3;
             }
-            if ((state->parsed_tags & PARSED_FADE) == 0) {
-                state->fade =
+            if ((render_priv->state.parsed_tags & PARSED_FADE) == 0) {
+                render_priv->state.fade =
                     interpolate_alpha(render_priv->time -
-                            state->event->Start, t1, t2,
+                            render_priv->state.event->Start, t1, t2,
                             t3, t4, a1, a2, a3);
-                state->parsed_tags |= PARSED_FADE;
+                render_priv->state.parsed_tags |= PARSED_FADE;
             }
         } else if (complex_tag("org")) {
             double v1, v2;
@@ -659,11 +617,11 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 v2 = argtod(args[1]);
             } else
                 continue;
-            if (!state->have_origin) {
-                state->org_x = v1;
-                state->org_y = v2;
-                state->have_origin = 1;
-                state->detect_collisions = 0;
+            if (!render_priv->state.have_origin) {
+                render_priv->state.org_x = v1;
+                render_priv->state.org_y = v2;
+                render_priv->state.have_origin = 1;
+                render_priv->state.detect_collisions = 0;
             }
         } else if (complex_tag("t")) {
             double accel;
@@ -689,11 +647,11 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 t2 = 0;
                 accel = 1.;
             }
-            state->detect_collisions = 0;
+            render_priv->state.detect_collisions = 0;
             if (t2 == 0)
-                t2 = state->event->Duration;
+                t2 = render_priv->state.event->Duration;
             delta_t = (uint32_t) t2 - t1;
-            t = render_priv->time - state->event->Start;        // FIXME: move to render_context
+            t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context
             if (t < t1)
                 k = 0.;
             else if (t >= t2)
@@ -713,7 +671,7 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
             p = args[cnt].start;
             if (args[cnt].end < end) {
                 assert(!nested);
-                p = ass_parse_tags(state, p, args[cnt].end, k, true);
+                p = parse_tags(render_priv, p, args[cnt].end, k, true);
             } else {
                 assert(q == end);
                 // No other tags can possibly follow this \t tag,
@@ -731,199 +689,192 @@ char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
                 y0 = argtoi32(args[1]);
                 x1 = argtoi32(args[2]);
                 y1 = argtoi32(args[3]);
-                state->clip_x0 =
-                    state->clip_x0 * (1 - pwr) + x0 * pwr;
-                state->clip_x1 =
-                    state->clip_x1 * (1 - pwr) + x1 * pwr;
-                state->clip_y0 =
-                    state->clip_y0 * (1 - pwr) + y0 * pwr;
-                state->clip_y1 =
-                    state->clip_y1 * (1 - pwr) + y1 * pwr;
-                state->clip_mode = 0;
-            } else if (!state->clip_drawing_text.str) {
-                if (parse_vector_clip(state, args, nargs))
-                    state->clip_drawing_mode = 0;
+                render_priv->state.clip_x0 =
+                    render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
+                render_priv->state.clip_x1 =
+                    render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
+                render_priv->state.clip_y0 =
+                    render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
+                render_priv->state.clip_y1 =
+                    render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
+                render_priv->state.clip_mode = 0;
+            } else if (!render_priv->state.clip_drawing_text.str) {
+                if (parse_vector_clip(render_priv, args, nargs))
+                    render_priv->state.clip_drawing_mode = 0;
             }
         } else if (tag("c") || tag("1c")) {
             if (nargs) {
                 uint32_t val = parse_color_tag(args->start);
-                change_color(&state->c[0], val, pwr);
+                change_color(&render_priv->state.c[0], val, pwr);
             } else
-                change_color(&state->c[0],
-                             state->style->PrimaryColour, 1);
+                change_color(&render_priv->state.c[0],
+                             render_priv->state.style->PrimaryColour, 1);
         } else if (tag("2c")) {
             if (nargs) {
                 uint32_t val = parse_color_tag(args->start);
-                change_color(&state->c[1], val, pwr);
+                change_color(&render_priv->state.c[1], val, pwr);
             } else
-                change_color(&state->c[1],
-                             state->style->SecondaryColour, 1);
+                change_color(&render_priv->state.c[1],
+                             render_priv->state.style->SecondaryColour, 1);
         } else if (tag("3c")) {
             if (nargs) {
                 uint32_t val = parse_color_tag(args->start);
-                change_color(&state->c[2], val, pwr);
+                change_color(&render_priv->state.c[2], val, pwr);
             } else
-                change_color(&state->c[2],
-                             state->style->OutlineColour, 1);
+                change_color(&render_priv->state.c[2],
+                             render_priv->state.style->OutlineColour, 1);
         } else if (tag("4c")) {
             if (nargs) {
                 uint32_t val = parse_color_tag(args->start);
-                change_color(&state->c[3], val, pwr);
+                change_color(&render_priv->state.c[3], val, pwr);
             } else
-                change_color(&state->c[3],
-                             state->style->BackColour, 1);
+                change_color(&render_priv->state.c[3],
+                             render_priv->state.style->BackColour, 1);
         } else if (tag("1a")) {
             if (nargs) {
                 uint32_t val = parse_alpha_tag(args->start);
-                change_alpha(&state->c[0], val, pwr);
+                change_alpha(&render_priv->state.c[0], val, pwr);
             } else
-                change_alpha(&state->c[0],
-                             _a(state->style->PrimaryColour), 1);
+                change_alpha(&render_priv->state.c[0],
+                             _a(render_priv->state.style->PrimaryColour), 1);
         } else if (tag("2a")) {
             if (nargs) {
                 uint32_t val = parse_alpha_tag(args->start);
-                change_alpha(&state->c[1], val, pwr);
+                change_alpha(&render_priv->state.c[1], val, pwr);
             } else
-                change_alpha(&state->c[1],
-                             _a(state->style->SecondaryColour), 1);
+                change_alpha(&render_priv->state.c[1],
+                             _a(render_priv->state.style->SecondaryColour), 1);
         } else if (tag("3a")) {
             if (nargs) {
                 uint32_t val = parse_alpha_tag(args->start);
-                change_alpha(&state->c[2], val, pwr);
+                change_alpha(&render_priv->state.c[2], val, pwr);
             } else
-                change_alpha(&state->c[2],
-                             _a(state->style->OutlineColour), 1);
+                change_alpha(&render_priv->state.c[2],
+                             _a(render_priv->state.style->OutlineColour), 1);
         } else if (tag("4a")) {
             if (nargs) {
                 uint32_t val = parse_alpha_tag(args->start);
-                change_alpha(&state->c[3], val, pwr);
+                change_alpha(&render_priv->state.c[3], val, pwr);
             } else
-                change_alpha(&state->c[3],
-                             _a(state->style->BackColour), 1);
+                change_alpha(&render_priv->state.c[3],
+                             _a(render_priv->state.style->BackColour), 1);
         } else if (tag("r")) {
             if (nargs) {
                 int len = args->end - args->start;
-                ass_reset_render_context(state,
+                reset_render_context(render_priv,
                         lookup_style_strict(render_priv->track, args->start, len));
             } else
-                ass_reset_render_context(state, NULL);
+                reset_render_context(render_priv, NULL);
         } else if (tag("be")) {
             double dval;
             if (nargs) {
                 int32_t val;
                 dval = argtod(*args);
                 // VSFilter always adds +0.5, even if the value is negative
-                val = dtoi32(state->be * (1 - pwr) + dval * pwr + 0.5);
+                val = dtoi32(render_priv->state.be * (1 - pwr) + dval * pwr + 0.5);
                 // Clamp to a safe upper limit, since high values need excessive CPU
                 val = (val < 0) ? 0 : val;
                 val = (val > MAX_BE) ? MAX_BE : val;
-                state->be = val;
+                render_priv->state.be = val;
             } else
-                state->be = 0;
+                render_priv->state.be = 0;
         } else if (tag("b")) {
             int32_t val = argtoi32(*args);
             if (!nargs || !(val == 0 || val == 1 || val >= 100))
-                val = state->style->Bold;
-            state->bold = val;
-            ass_update_font(state);
+                val = render_priv->state.style->Bold;
+            render_priv->state.bold = val;
+            update_font(render_priv);
         } else if (tag("i")) {
             int32_t val = argtoi32(*args);
             if (!nargs || !(val == 0 || val == 1))
-                val = state->style->Italic;
-            state->italic = val;
-            ass_update_font(state);
-        } else if (tag("kt")) {
-            // v4++
-            double val = 0;
-            if (nargs)
-                val = argtod(*args) * 10;
-            state->effect_skip_timing = dtoi32(val);
-            state->effect_timing = 0;
-            state->reset_effect = true;
+                val = render_priv->state.style->Italic;
+            render_priv->state.italic = val;
+            update_font(render_priv);
         } else if (tag("kf") || tag("K")) {
             double val = 100;
             if (nargs)
                 val = argtod(*args);
-            state->effect_type = EF_KARAOKE_KF;
-            state->effect_skip_timing +=
-                    (uint32_t) state->effect_timing;
-            state->effect_timing = dtoi32(val * 10);
+            render_priv->state.effect_type = EF_KARAOKE_KF;
+            if (render_priv->state.effect_timing)
+                render_priv->state.effect_skip_timing +=
+                    render_priv->state.effect_timing;
+            render_priv->state.effect_timing = val * 10;
         } else if (tag("ko")) {
             double val = 100;
             if (nargs)
                 val = argtod(*args);
-            state->effect_type = EF_KARAOKE_KO;
-            state->effect_skip_timing +=
-                    (uint32_t) state->effect_timing;
-            state->effect_timing = dtoi32(val * 10);
+            render_priv->state.effect_type = EF_KARAOKE_KO;
+            if (render_priv->state.effect_timing)
+                render_priv->state.effect_skip_timing +=
+                    render_priv->state.effect_timing;
+            render_priv->state.effect_timing = val * 10;
         } else if (tag("k")) {
             double val = 100;
             if (nargs)
                 val = argtod(*args);
-            state->effect_type = EF_KARAOKE;
-            state->effect_skip_timing +=
-                    (uint32_t) state->effect_timing;
-            state->effect_timing = dtoi32(val * 10);
+            render_priv->state.effect_type = EF_KARAOKE;
+            if (render_priv->state.effect_timing)
+                render_priv->state.effect_skip_timing +=
+                    render_priv->state.effect_timing;
+            render_priv->state.effect_timing = dtoi32(val * 10);
         } else if (tag("shad")) {
             double val, xval, yval;
             if (nargs) {
                 val = argtod(*args);
-                xval = state->shadow_x * (1 - pwr) + val * pwr;
-                yval = state->shadow_y * (1 - pwr) + val * pwr;
+                xval = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
+                yval = render_priv->state.shadow_y * (1 - pwr) + val * pwr;
                 // VSFilter compatibility: clip for \shad but not for \[xy]shad
                 xval = (xval < 0) ? 0 : xval;
                 yval = (yval < 0) ? 0 : yval;
             } else
-                xval = yval = state->style->Shadow;
-            state->shadow_x = xval;
-            state->shadow_y = yval;
+                xval = yval = render_priv->state.style->Shadow;
+            render_priv->state.shadow_x = xval;
+            render_priv->state.shadow_y = yval;
         } else if (tag("s")) {
             int32_t val = argtoi32(*args);
             if (!nargs || !(val == 0 || val == 1))
-                val = state->style->StrikeOut;
+                val = render_priv->state.style->StrikeOut;
             if (val)
-                state->flags |= DECO_STRIKETHROUGH;
+                render_priv->state.flags |= DECO_STRIKETHROUGH;
             else
-                state->flags &= ~DECO_STRIKETHROUGH;
+                render_priv->state.flags &= ~DECO_STRIKETHROUGH;
         } else if (tag("u")) {
             int32_t val = argtoi32(*args);
             if (!nargs || !(val == 0 || val == 1))
-                val = state->style->Underline;
+                val = render_priv->state.style->Underline;
             if (val)
-                state->flags |= DECO_UNDERLINE;
+                render_priv->state.flags |= DECO_UNDERLINE;
             else
-                state->flags &= ~DECO_UNDERLINE;
+                render_priv->state.flags &= ~DECO_UNDERLINE;
         } else if (tag("pbo")) {
             double val = argtod(*args);
-            state->pbo = val;
+            render_priv->state.pbo = val;
         } else if (tag("p")) {
             int32_t val = argtoi32(*args);
             val = (val < 0) ? 0 : val;
-            state->drawing_scale = val;
+            render_priv->state.drawing_scale = val;
         } else if (tag("q")) {
             int32_t val = argtoi32(*args);
             if (!nargs || !(val >= 0 && val <= 3))
                 val = render_priv->track->WrapStyle;
-            state->wrap_style = val;
+            render_priv->state.wrap_style = val;
         } else if (tag("fe")) {
             int32_t val;
             if (nargs)
                 val = argtoi32(*args);
             else
-                val = state->style->Encoding;
-            state->font_encoding = val;
+                val = render_priv->state.style->Encoding;
+            render_priv->state.font_encoding = val;
         }
     }
 
     return p;
 }
 
-void ass_apply_transition_effects(RenderContext *state)
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event)
 {
-    ASS_Renderer *render_priv = state->renderer;
     int v[4];
     int cnt;
-    ASS_Event *event = state->event;
     char *p = event->Effect;
 
     if (!p || !*p)
@@ -934,46 +885,33 @@ void ass_apply_transition_effects(RenderContext *state)
         v[cnt++] = atoi(++p);
     }
 
-    ASS_Vector layout_res = ass_layout_res(render_priv);
     if (strncmp(event->Effect, "Banner;", 7) == 0) {
-        double delay;
+        int delay;
         if (cnt < 1) {
             ass_msg(render_priv->library, MSGL_V,
                     "Error parsing effect: '%s'", event->Effect);
             return;
         }
         if (cnt >= 2 && v[1])   // left-to-right
-            state->scroll_direction = SCROLL_LR;
+            render_priv->state.scroll_direction = SCROLL_LR;
         else                    // right-to-left
-            state->scroll_direction = SCROLL_RL;
+            render_priv->state.scroll_direction = SCROLL_RL;
 
         delay = v[0];
-        // VSF works in storage coordinates, but scales delay to PlayRes canvas
-        // before applying max(scaled_ delay, 1). This means, if scaled_delay < 1
-        // (esp. delay=0) we end up with 1 ms per _storage pixel_ without any
-        // PlayRes scaling.
-        // The way libass deals with delay, it is automatically relative to the
-        // PlayRes canvas, so we only want to "unscale" the small delay values.
-        //
-        // VSF also casts the scaled delay to int, which if not emulated leads to
-        // easily noticeable deviations from VSFilter as the effect goes on.
-        // To achieve both we need to keep our Playres-relative delay with high precision,
-        // but must temporarily convert to storage-relative and truncate and take the
-        // maxuimum there, before converting back.
-        double scale_x = ((double) layout_res.x) / render_priv->track->PlayResX;
-        delay = ((int) FFMAX(delay / scale_x, 1)) * scale_x;
-        state->scroll_shift =
-            (render_priv->time - event->Start) / delay;
-        state->evt_type |= EVENT_HSCROLL;
-        state->detect_collisions = 0;
-        state->wrap_style = 2;
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv->state.scroll_shift =
+            (render_priv->time - render_priv->state.event->Start) / delay;
+        render_priv->state.evt_type |= EVENT_HSCROLL;
+        render_priv->state.detect_collisions = 0;
+        render_priv->state.wrap_style = 2;
         return;
     }
 
     if (strncmp(event->Effect, "Scroll up;", 10) == 0) {
-        state->scroll_direction = SCROLL_BT;
+        render_priv->state.scroll_direction = SCROLL_BT;
     } else if (strncmp(event->Effect, "Scroll down;", 12) == 0) {
-        state->scroll_direction = SCROLL_TB;
+        render_priv->state.scroll_direction = SCROLL_TB;
     } else {
         ass_msg(render_priv->library, MSGL_DBG2,
                 "Unknown transition effect: '%s'", event->Effect);
@@ -981,7 +919,7 @@ void ass_apply_transition_effects(RenderContext *state)
     }
     // parse scroll up/down parameters
     {
-        double delay;
+        int delay;
         int y0, y1;
         if (cnt < 3) {
             ass_msg(render_priv->library, MSGL_V,
@@ -989,11 +927,10 @@ void ass_apply_transition_effects(RenderContext *state)
             return;
         }
         delay = v[2];
-        // See explanation for Banner
-        double scale_y = ((double) layout_res.y) / render_priv->track->PlayResY;
-        delay = ((int) FFMAX(delay / scale_y, 1)) * scale_y;
-        state->scroll_shift =
-            (render_priv->time - event->Start) / delay;
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv->state.scroll_shift =
+            (render_priv->time - render_priv->state.event->Start) / delay;
         if (v[0] < v[1]) {
             y0 = v[0];
             y1 = v[1];
@@ -1001,17 +938,17 @@ void ass_apply_transition_effects(RenderContext *state)
             y0 = v[1];
             y1 = v[0];
         }
-        state->scroll_y0 = y0;
-        state->scroll_y1 = y1;
-        state->evt_type |= EVENT_VSCROLL;
-        state->detect_collisions = 0;
+        render_priv->state.scroll_y0 = y0;
+        render_priv->state.scroll_y1 = y1;
+        render_priv->state.evt_type |= EVENT_VSCROLL;
+        render_priv->state.detect_collisions = 0;
     }
 
 }
 
 /**
  * \brief determine karaoke effects
- * Karaoke effects cannot be calculated during parse stage (ass_get_next_char()),
+ * Karaoke effects cannot be calculated during parse stage (get_next_char()),
  * so they are done in a separate step.
  * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's
  * (the first glyph of the karaoke word)'s effect_type and effect_timing.
@@ -1020,34 +957,26 @@ void ass_apply_transition_effects(RenderContext *state)
  * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
  * (left part is filled with PrimaryColour, right one - with SecondaryColour).
  */
-void ass_process_karaoke_effects(RenderContext *state)
+void process_karaoke_effects(ASS_Renderer *render_priv)
 {
-    TextInfo *text_info = state->text_info;
-    long long tm_current = state->renderer->time - state->event->Start;
+    long long tm_current = render_priv->time - render_priv->state.event->Start;
 
-    int32_t timing = 0, skip_timing = 0;
+    int timing = 0, skip_timing = 0;
     Effect effect_type = EF_NONE;
     GlyphInfo *last_boundary = NULL;
-    bool has_reset = false;
-    for (int i = 0; i <= text_info->length; i++) {
-        if (i < text_info->length &&
-            !text_info->glyphs[i].starts_new_run) {
-
-            if (text_info->glyphs[i].reset_effect) {
-                has_reset = true;
-                skip_timing = 0;
-            }
-
+    for (int i = 0; i <= render_priv->text_info.length; i++) {
+        if (i < render_priv->text_info.length &&
+            !render_priv->text_info.glyphs[i].starts_new_run) {
             // VSFilter compatibility: if we have \k12345\k0 without a run
             // break, subsequent text is still part of the same karaoke word,
             // the current word's starting and ending time stay unchanged,
             // but the starting time of the next karaoke word is advanced.
-            skip_timing += (uint32_t) text_info->glyphs[i].effect_skip_timing;
+            skip_timing += render_priv->text_info.glyphs[i].effect_skip_timing;
             continue;
         }
 
         GlyphInfo *start = last_boundary;
-        GlyphInfo *end = text_info->glyphs + i;
+        GlyphInfo *end = render_priv->text_info.glyphs + i;
         last_boundary = end;
         if (!start)
             continue;
@@ -1057,14 +986,10 @@ void ass_process_karaoke_effects(RenderContext *state)
         if (effect_type == EF_NONE)
             continue;
 
-        if (start->reset_effect)
-            timing = 0;
-
         long long tm_start = timing + start->effect_skip_timing;
         long long tm_end = tm_start + start->effect_timing;
-        timing = !has_reset * tm_end + skip_timing;
+        timing = tm_end + skip_timing;
         skip_timing = 0;
-        has_reset = false;
 
         if (effect_type != EF_KARAOKE_KF)
             tm_end = tm_start;
@@ -1111,7 +1036,7 @@ void ass_process_karaoke_effects(RenderContext *state)
  * \return ucs4 code of the next char
  * On return str points to the unparsed part of the string
  */
-unsigned ass_get_next_char(RenderContext *state, char **str)
+unsigned get_next_char(ASS_Renderer *render_priv, char **str)
 {
     char *p = *str;
     unsigned chr;
@@ -1122,7 +1047,7 @@ unsigned ass_get_next_char(RenderContext *state, char **str)
     }
     if (*p == '\\') {
         if ((p[1] == 'N') || ((p[1] == 'n') &&
-                              (state->wrap_style == 2))) {
+                              (render_priv->state.wrap_style == 2))) {
             p += 2;
             *str = p;
             return '\n';
@@ -1151,10 +1076,10 @@ unsigned ass_get_next_char(RenderContext *state, char **str)
 
 // Return 1 if the event contains tags that will apply overrides the selective
 // style override code should not touch. Return 0 otherwise.
-int ass_event_has_hard_overrides(char *str)
+int event_has_hard_overrides(char *str)
 {
     // look for \pos and \move tags inside {...}
-    // mirrors ass_get_next_char, but is faster and doesn't change any global state
+    // mirrors get_next_char, but is faster and doesn't change any global state
     while (*str) {
         if (str[0] == '\\' && str[1] != '\0') {
             str += 2;
diff --git a/libass/ass_parse.h b/libass/ass_parse.h
index 6c96eb1..bf72b78 100644
--- a/libass/ass_parse.h
+++ b/libass/ass_parse.h
@@ -19,8 +19,6 @@
 #ifndef LIBASS_PARSE_H
 #define LIBASS_PARSE_H
 
-#include "ass_render.h"
-
 #define BLUR_MAX_RADIUS 100.0
 
 #define _r(c)   ((c) >> 24)
@@ -28,14 +26,16 @@
 #define _b(c)   (((c) >> 8) & 0xFF)
 #define _a(c)   ((c) & 0xFF)
 
-void ass_update_font(RenderContext *state);
-void ass_apply_transition_effects(RenderContext *state);
-void ass_process_karaoke_effects(RenderContext *state);
-unsigned ass_get_next_char(RenderContext *state, char **str);
-char *ass_parse_tags(RenderContext *state, char *p, char *end, double pwr,
-                     bool nested);
-int ass_event_has_hard_overrides(char *str);
-void ass_apply_fade(uint32_t *clr, int fade);
+void update_font(ASS_Renderer *render_priv);
+double ensure_font_size(ASS_Renderer *priv, double size);
+void apply_transition_effects(ASS_Renderer *render_priv, ASS_Event *event);
+void process_karaoke_effects(ASS_Renderer *render_priv);
+unsigned get_next_char(ASS_Renderer *render_priv, char **str);
+char *parse_tags(ASS_Renderer *render_priv, char *p, char *end, double pwr,
+                 bool nested);
+int event_has_hard_overrides(char *str);
+extern void change_alpha(uint32_t *var, int32_t new, double pwr);
+extern uint32_t mult_alpha(uint32_t a, uint32_t b);
 
 
 #endif /* LIBASS_PARSE_H */
diff --git a/libass/ass_priv.h b/libass/ass_priv.h
index e4f9869..43a89c8 100644
--- a/libass/ass_priv.h
+++ b/libass/ass_priv.h
@@ -41,11 +41,8 @@ typedef enum {
     SINFO_SCALEDBORDER = 1 << 5,
     SINFO_COLOURMATRIX = 1 << 6,
     SINFO_KERNING      = 1 << 7,
-    SINFO_SCRIPTTYPE   = 1 << 8,
-    SINFO_LAYOUTRESX   = 1 << 9,
-    SINFO_LAYOUTRESY   = 1 << 10,
     // for legacy detection
-    GENBY_FFMPEG       = 1 << 14
+    GENBY_FFMPEG       = 1 << 8
     // max 32 enumerators
 } ScriptInfo;
 
diff --git a/libass/ass_rasterizer.c b/libass/ass_rasterizer.c
index 0ac45d1..36d7883 100644
--- a/libass/ass_rasterizer.c
+++ b/libass/ass_rasterizer.c
@@ -51,7 +51,7 @@ static inline int ilog2(uint32_t n)
 }
 
 
-bool ass_rasterizer_init(const BitmapEngine *engine, RasterizerData *rst, int outline_error)
+bool rasterizer_init(const BitmapEngine *engine, RasterizerData *rst, int outline_error)
 {
     rst->outline_error = outline_error;
     rst->linebuf[0] = rst->linebuf[1] = NULL;
@@ -89,7 +89,7 @@ static inline bool check_capacity(RasterizerData *rst, int index, size_t delta)
     return true;
 }
 
-void ass_rasterizer_done(RasterizerData *rst)
+void rasterizer_done(RasterizerData *rst)
 {
     free(rst->linebuf[0]);
     free(rst->linebuf[1]);
@@ -262,8 +262,8 @@ static bool add_cubic(RasterizerData *rst, const ASS_Vector *pt)
 }
 
 
-bool ass_rasterizer_set_outline(RasterizerData *rst,
-                                const ASS_Outline *path, bool extra)
+bool rasterizer_set_outline(RasterizerData *rst,
+                            const ASS_Outline *path, bool extra)
 {
     if (!extra) {
         rectangle_reset(&rst->bbox);
@@ -676,7 +676,7 @@ static bool rasterizer_fill_level(const BitmapEngine *engine, RasterizerData *rs
         else
             engine->fill_halfplane(rst->tile, width, line1->a, line1->b, line1->c,
                                    flags1 & FLAG_REVERSE ? -line1->scale : line1->scale);
-        engine->merge(buf, stride, rst->tile);
+        engine->merge_tile(buf, stride, rst->tile);
         rst->size[index] = offs;
         return true;
     }
@@ -719,9 +719,9 @@ static bool rasterizer_fill_level(const BitmapEngine *engine, RasterizerData *rs
     return true;
 }
 
-bool ass_rasterizer_fill(const BitmapEngine *engine, RasterizerData *rst,
-                         uint8_t *buf, int x0, int y0,
-                         int width, int height, ptrdiff_t stride)
+bool rasterizer_fill(const BitmapEngine *engine, RasterizerData *rst,
+                     uint8_t *buf, int x0, int y0,
+                     int width, int height, ptrdiff_t stride)
 {
     assert(width > 0 && height > 0);
     assert(!(width  & ((1 << engine->tile_order) - 1)));
diff --git a/libass/ass_rasterizer.h b/libass/ass_rasterizer.h
index b94d3e0..21c3420 100644
--- a/libass/ass_rasterizer.h
+++ b/libass/ass_rasterizer.h
@@ -56,8 +56,8 @@ typedef struct {
     uint8_t *tile;
 } RasterizerData;
 
-bool ass_rasterizer_init(const BitmapEngine *engine, RasterizerData *rst, int outline_error);
-void ass_rasterizer_done(RasterizerData *rst);
+bool rasterizer_init(const BitmapEngine *engine, RasterizerData *rst, int outline_error);
+void rasterizer_done(RasterizerData *rst);
 
 /**
  * \brief Convert outline to polyline and calculate exact bounds
@@ -65,8 +65,8 @@ void ass_rasterizer_done(RasterizerData *rst);
  * \param extra in: true if path is second border outline
  * \return false on error
  */
-bool ass_rasterizer_set_outline(RasterizerData *rst,
-                                const ASS_Outline *path, bool extra);
+bool rasterizer_set_outline(RasterizerData *rst,
+                            const ASS_Outline *path, bool extra);
 
 /**
  * \brief Polyline rasterization function
@@ -76,9 +76,9 @@ bool ass_rasterizer_set_outline(RasterizerData *rst,
  * \return false on error
  * Deletes preprocessed polyline after work.
  */
-bool ass_rasterizer_fill(const BitmapEngine *engine, RasterizerData *rst,
-                         uint8_t *buf, int x0, int y0,
-                         int width, int height, ptrdiff_t stride);
+bool rasterizer_fill(const BitmapEngine *engine, RasterizerData *rst,
+                     uint8_t *buf, int x0, int y0,
+                     int width, int height, ptrdiff_t stride);
 
 
 #endif /* LIBASS_RASTERIZER_H */
diff --git a/libass/ass_render.c b/libass/ass_render.c
index f95479c..a8be31b 100644
--- a/libass/ass_render.c
+++ b/libass/ass_render.c
@@ -24,10 +24,6 @@
 #include <string.h>
 #include <stdbool.h>
 
-#ifdef CONFIG_UNIBREAK
-#include <linebreak.h>
-#endif
-
 #include "ass.h"
 #include "ass_outline.h"
 #include "ass_render.h"
@@ -48,34 +44,6 @@
 #define BLUR_PRECISION (1.0 / 256)  // blur error as fraction of full input range
 
 
-static bool text_info_init(TextInfo* text_info)
-{
-    text_info->max_bitmaps = MAX_BITMAPS_INITIAL;
-    text_info->max_glyphs = MAX_GLYPHS_INITIAL;
-    text_info->max_lines = MAX_LINES_INITIAL;
-    text_info->n_bitmaps = 0;
-    text_info->combined_bitmaps = calloc(MAX_BITMAPS_INITIAL, sizeof(CombinedBitmapInfo));
-    text_info->glyphs = calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));
-    text_info->event_text = calloc(MAX_GLYPHS_INITIAL, sizeof(FriBidiChar));
-    text_info->breaks = malloc(MAX_GLYPHS_INITIAL);
-    text_info->lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));
-
-    if (!text_info->combined_bitmaps || !text_info->glyphs || !text_info->lines ||
-        !text_info->breaks || !text_info->event_text)
-        return false;
-
-    return true;
-}
-
-static void text_info_done(TextInfo* text_info)
-{
-    free(text_info->glyphs);
-    free(text_info->event_text);
-    free(text_info->breaks);
-    free(text_info->lines);
-    free(text_info->combined_bitmaps);
-}
-
 ASS_Renderer *ass_renderer_init(ASS_Library *library)
 {
     int error;
@@ -106,39 +74,47 @@ ASS_Renderer *ass_renderer_init(ASS_Library *library)
     priv->ftlibrary = ft;
     // images_root and related stuff is zero-filled in calloc
 
-    unsigned flags = ASS_CPU_FLAG_ALL;
-#if CONFIG_LARGE_TILES
-    flags |= ASS_FLAG_LARGE_TILES;
+#if CONFIG_ASM && ARCH_X86
+    bool sse2, avx2;
+    ass_cpu_capabilities(&sse2, &avx2);
+    if (avx2)
+        priv->engine = &ass_bitmap_engine_avx2;
+    else if (sse2)
+        priv->engine = &ass_bitmap_engine_sse2;
+    else
+        priv->engine = &ass_bitmap_engine_c;
+#else
+    priv->engine = &ass_bitmap_engine_c;
 #endif
-    priv->engine = ass_bitmap_engine_init(flags);
 
-    if (!ass_rasterizer_init(&priv->engine, &priv->state.rasterizer, RASTERIZER_PRECISION))
+    if (!rasterizer_init(priv->engine, &priv->rasterizer, RASTERIZER_PRECISION))
         goto fail;
 
     priv->cache.font_cache = ass_font_cache_create();
     priv->cache.bitmap_cache = ass_bitmap_cache_create();
     priv->cache.composite_cache = ass_composite_cache_create();
     priv->cache.outline_cache = ass_outline_cache_create();
-    priv->cache.metrics_cache = ass_glyph_metrics_cache_create();
-    if (!priv->cache.font_cache || !priv->cache.bitmap_cache || !priv->cache.composite_cache || !priv->cache.outline_cache || !priv->cache.metrics_cache)
+    if (!priv->cache.font_cache || !priv->cache.bitmap_cache || !priv->cache.composite_cache || !priv->cache.outline_cache)
         goto fail;
 
     priv->cache.glyph_max = GLYPH_CACHE_MAX;
     priv->cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;
     priv->cache.composite_max_size = COMPOSITE_CACHE_MAX_SIZE;
 
-    if (!text_info_init(&priv->text_info))
+    priv->text_info.max_bitmaps = MAX_BITMAPS_INITIAL;
+    priv->text_info.max_glyphs = MAX_GLYPHS_INITIAL;
+    priv->text_info.max_lines = MAX_LINES_INITIAL;
+    priv->text_info.n_bitmaps = 0;
+    priv->text_info.combined_bitmaps = calloc(MAX_BITMAPS_INITIAL, sizeof(CombinedBitmapInfo));
+    priv->text_info.glyphs = calloc(MAX_GLYPHS_INITIAL, sizeof(GlyphInfo));
+    priv->text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(LineInfo));
+    if (!priv->text_info.combined_bitmaps || !priv->text_info.glyphs || !priv->text_info.lines)
         goto fail;
 
-    priv->user_override_style.Name = "OverrideStyle"; // name insignificant
-
-    priv->state.renderer = priv;
-    priv->state.text_info = &priv->text_info;
-
     priv->settings.font_size_coeff = 1.;
     priv->settings.selective_style_overrides = ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE;
 
-    if (!(priv->state.shaper = ass_shaper_new(priv->cache.metrics_cache)))
+    if (!(priv->shaper = ass_shaper_new()))
         goto fail;
 
     ass_shaper_info(library);
@@ -166,19 +142,20 @@ void ass_renderer_done(ASS_Renderer *render_priv)
     ass_cache_done(render_priv->cache.composite_cache);
     ass_cache_done(render_priv->cache.bitmap_cache);
     ass_cache_done(render_priv->cache.outline_cache);
-    ass_cache_done(render_priv->cache.metrics_cache);
-    ass_shaper_free(render_priv->state.shaper);
+    ass_shaper_free(render_priv->shaper);
     ass_cache_done(render_priv->cache.font_cache);
 
-    ass_rasterizer_done(&render_priv->state.rasterizer);
+    rasterizer_done(&render_priv->rasterizer);
 
     if (render_priv->fontselect)
         ass_fontselect_free(render_priv->fontselect);
     if (render_priv->ftlibrary)
         FT_Done_FreeType(render_priv->ftlibrary);
     free(render_priv->eimg);
+    free(render_priv->text_info.glyphs);
+    free(render_priv->text_info.lines);
 
-    text_info_done(&render_priv->text_info);
+    free(render_priv->text_info.combined_bitmaps);
 
     free(render_priv->settings.default_font);
     free(render_priv->settings.default_family);
@@ -225,29 +202,27 @@ static ASS_Image *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
  */
 static double x2scr_pos(ASS_Renderer *render_priv, double x)
 {
-    return x * render_priv->frame_content_width / render_priv->par_scale_x / render_priv->track->PlayResX +
+    return x * render_priv->orig_width / render_priv->font_scale_x / render_priv->track->PlayResX +
         render_priv->settings.left_margin;
 }
-static double x2scr_left(RenderContext *state, double x)
+static double x2scr_left(ASS_Renderer *render_priv, double x)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    if (state->explicit || !render_priv->settings.use_margins)
+    if (render_priv->state.explicit || !render_priv->settings.use_margins)
         return x2scr_pos(render_priv, x);
-    return x * render_priv->fit_width / render_priv->par_scale_x /
+    return x * render_priv->fit_width / render_priv->font_scale_x /
         render_priv->track->PlayResX;
 }
-static double x2scr_right(RenderContext *state, double x)
+static double x2scr_right(ASS_Renderer *render_priv, double x)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    if (state->explicit || !render_priv->settings.use_margins)
+    if (render_priv->state.explicit || !render_priv->settings.use_margins)
         return x2scr_pos(render_priv, x);
-    return x * render_priv->fit_width / render_priv->par_scale_x /
+    return x * render_priv->fit_width / render_priv->font_scale_x /
         render_priv->track->PlayResX +
         (render_priv->width - render_priv->fit_width);
 }
 static double x2scr_pos_scaled(ASS_Renderer *render_priv, double x)
 {
-    return x * render_priv->frame_content_width / render_priv->track->PlayResX +
+    return x * render_priv->orig_width / render_priv->track->PlayResX +
         render_priv->settings.left_margin;
 }
 /**
@@ -255,13 +230,12 @@ static double x2scr_pos_scaled(ASS_Renderer *render_priv, double x)
  */
 static double y2scr_pos(ASS_Renderer *render_priv, double y)
 {
-    return y * render_priv->frame_content_height / render_priv->track->PlayResY +
+    return y * render_priv->orig_height / render_priv->track->PlayResY +
         render_priv->settings.top_margin;
 }
-static double y2scr(RenderContext *state, double y)
+static double y2scr(ASS_Renderer *render_priv, double y)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    if (state->explicit || !render_priv->settings.use_margins)
+    if (render_priv->state.explicit || !render_priv->settings.use_margins)
         return y2scr_pos(render_priv, y);
     return y * render_priv->fit_height /
         render_priv->track->PlayResY +
@@ -269,19 +243,17 @@ static double y2scr(RenderContext *state, double y)
 }
 
 // the same for toptitles
-static double y2scr_top(RenderContext *state, double y)
+static double y2scr_top(ASS_Renderer *render_priv, double y)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    if (state->explicit || !render_priv->settings.use_margins)
+    if (render_priv->state.explicit || !render_priv->settings.use_margins)
         return y2scr_pos(render_priv, y);
     return y * render_priv->fit_height /
         render_priv->track->PlayResY;
 }
 // the same for subtitles
-static double y2scr_sub(RenderContext *state, double y)
+static double y2scr_sub(ASS_Renderer *render_priv, double y)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    if (state->explicit || !render_priv->settings.use_margins)
+    if (render_priv->state.explicit || !render_priv->settings.use_margins)
         return y2scr_pos(render_priv, y);
     return y * render_priv->fit_height /
         render_priv->track->PlayResY +
@@ -301,13 +273,12 @@ static double y2scr_sub(RenderContext *state, double y)
  * In an additional pass, the rectangles need to be split up left/right for
  * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).
  */
-static ASS_Image **render_glyph_i(RenderContext *state,
+static ASS_Image **render_glyph_i(ASS_Renderer *render_priv,
                                   Bitmap *bm, int dst_x, int dst_y,
                                   uint32_t color, uint32_t color2, int brk,
                                   ASS_Image **tail, unsigned type,
                                   CompositeHashValue *source)
 {
-    ASS_Renderer *render_priv = state->renderer;
     int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
     Rect r[4];
     ASS_Image *img;
@@ -326,10 +297,10 @@ static ASS_Image **render_glyph_i(RenderContext *state,
     y0 = 0;
     x1 = bm->w;
     y1 = bm->h;
-    cx0 = state->clip_x0 - dst_x;
-    cy0 = state->clip_y0 - dst_y;
-    cx1 = state->clip_x1 - dst_x;
-    cy1 = state->clip_y1 - dst_y;
+    cx0 = render_priv->state.clip_x0 - dst_x;
+    cy0 = render_priv->state.clip_y0 - dst_y;
+    cx1 = render_priv->state.clip_x1 - dst_x;
+    cy1 = render_priv->state.clip_y1 - dst_y;
 
     // calculate rectangles and discard invalid ones while we're at it.
     i = 0;
@@ -407,13 +378,13 @@ static ASS_Image **render_glyph_i(RenderContext *state,
  * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
  */
 static ASS_Image **
-render_glyph(RenderContext *state, Bitmap *bm, int dst_x, int dst_y,
+render_glyph(ASS_Renderer *render_priv, Bitmap *bm, int dst_x, int dst_y,
              uint32_t color, uint32_t color2, int brk, ASS_Image **tail,
              unsigned type, CompositeHashValue *source)
 {
     // Inverse clipping in use?
-    if (state->clip_mode)
-        return render_glyph_i(state, bm, dst_x, dst_y, color, color2,
+    if (render_priv->state.clip_mode)
+        return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,
                               brk, tail, type, source);
 
     // brk is absolute
@@ -423,17 +394,16 @@ render_glyph(RenderContext *state, Bitmap *bm, int dst_x, int dst_y,
     int clip_x0, clip_y0, clip_x1, clip_y1;
     int tmp;
     ASS_Image *img;
-    ASS_Renderer *render_priv = state->renderer;
 
     dst_x += bm->left;
     dst_y += bm->top;
     brk -= dst_x;
 
     // clipping
-    clip_x0 = FFMINMAX(state->clip_x0, 0, render_priv->width);
-    clip_y0 = FFMINMAX(state->clip_y0, 0, render_priv->height);
-    clip_x1 = FFMINMAX(state->clip_x1, 0, render_priv->width);
-    clip_y1 = FFMINMAX(state->clip_y1, 0, render_priv->height);
+    clip_x0 = FFMINMAX(render_priv->state.clip_x0, 0, render_priv->width);
+    clip_y0 = FFMINMAX(render_priv->state.clip_y0, 0, render_priv->height);
+    clip_x1 = FFMINMAX(render_priv->state.clip_x1, 0, render_priv->width);
+    clip_y1 = FFMINMAX(render_priv->state.clip_y1, 0, render_priv->height);
     b_x0 = 0;
     b_y0 = 0;
     b_x1 = bm->w;
@@ -682,22 +652,20 @@ static inline size_t bitmap_size(const Bitmap *bm)
  * applicable. The blended bitmaps are added to a free list which is freed
  * at the start of a new frame.
  */
-static void blend_vector_clip(RenderContext *state, ASS_Image *head)
+static void blend_vector_clip(ASS_Renderer *render_priv, ASS_Image *head)
 {
-    if (!state->clip_drawing_text.str)
+    if (!render_priv->state.clip_drawing_text.str)
         return;
 
-    ASS_Renderer *render_priv = state->renderer;
-
     OutlineHashKey ol_key;
     ol_key.type = OUTLINE_DRAWING;
-    ol_key.u.drawing.text = state->clip_drawing_text;
+    ol_key.u.drawing.text = render_priv->state.clip_drawing_text;
 
     double m[3][3] = {{0}};
-    int32_t scale_base = lshiftwrapi(1, state->clip_drawing_scale - 1);
-    double w = scale_base > 0 ? (1.0 / scale_base) : 0;
-    m[0][0] = state->screen_scale_x * w;
-    m[1][1] = state->screen_scale_y * w;
+    int32_t scale_base = lshiftwrapi(1, render_priv->state.clip_drawing_scale - 1);
+    double w = scale_base > 0 ? (render_priv->font_scale / scale_base) : 0;
+    m[0][0] = render_priv->font_scale_x * w;
+    m[1][1] = w;
     m[2][2] = 1;
 
     m[0][2] = int_to_d6(render_priv->settings.left_margin);
@@ -711,7 +679,7 @@ static void blend_vector_clip(RenderContext *state, ASS_Image *head)
         ass_cache_dec_ref(key.outline);
         return;
     }
-    Bitmap *clip_bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, state);
+    Bitmap *clip_bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);
     if (!clip_bm)
         return;
 
@@ -748,8 +716,8 @@ static void blend_vector_clip(RenderContext *state, ASS_Image *head)
         bleft = left - bx;
         btop = top - by;
 
-        unsigned align = 1 << render_priv->engine.align_order;
-        if (state->clip_drawing_mode) {
+        unsigned align = 1 << render_priv->engine->align_order;
+        if (render_priv->state.clip_drawing_mode) {
             // Inverse clip
             if (ax + aw < bx || ay + ah < by || ax > bx + bw ||
                 ay > by + bh || !h || !w) {
@@ -763,9 +731,9 @@ static void blend_vector_clip(RenderContext *state, ASS_Image *head)
 
             // Blend together
             memcpy(nbuffer, abuffer, ((ah - 1) * as) + aw);
-            render_priv->engine.imul_bitmaps(nbuffer + atop * as + aleft, as,
-                                             bbuffer + btop * bs + bleft, bs,
-                                             w, h);
+            render_priv->engine->imul_bitmaps(nbuffer + atop * as + aleft, as,
+                                              bbuffer + btop * bs + bleft, bs,
+                                              w, h);
         } else {
             // Regular clip
             if (ax + aw < bx || ay + ah < by || ax > bx + bw ||
@@ -781,10 +749,10 @@ static void blend_vector_clip(RenderContext *state, ASS_Image *head)
                 break;
 
             // Blend together
-            render_priv->engine.mul_bitmaps(nbuffer, ns,
-                                            abuffer + atop * as + aleft, as,
-                                            bbuffer + btop * bs + bleft, bs,
-                                            w, h);
+            render_priv->engine->mul_bitmaps(nbuffer, ns,
+                                             abuffer + atop * as + aleft, as,
+                                             bbuffer + btop * bs + bleft, bs,
+                                             w, h);
             cur->dst_x += aleft;
             cur->dst_y += atop;
             cur->w = w;
@@ -805,20 +773,20 @@ static void blend_vector_clip(RenderContext *state, ASS_Image *head)
  * \brief Convert TextInfo struct to ASS_Image list
  * Splits glyphs in halves when needed (for \kf karaoke).
  */
-static ASS_Image *render_text(RenderContext *state)
+static ASS_Image *render_text(ASS_Renderer *render_priv)
 {
     ASS_Image *head;
     ASS_Image **tail = &head;
-    unsigned n_bitmaps = state->text_info->n_bitmaps;
-    CombinedBitmapInfo *bitmaps = state->text_info->combined_bitmaps;
+    unsigned n_bitmaps = render_priv->text_info.n_bitmaps;
+    CombinedBitmapInfo *bitmaps = render_priv->text_info.combined_bitmaps;
 
     for (unsigned i = 0; i < n_bitmaps; i++) {
         CombinedBitmapInfo *info = &bitmaps[i];
-        if (!info->bm_s || state->border_style == 4)
+        if (!info->bm_s || render_priv->state.border_style == 4)
             continue;
 
         tail =
-            render_glyph(state, info->bm_s, info->x, info->y, info->c[3], 0,
+            render_glyph(render_priv, info->bm_s, info->x, info->y, info->c[3], 0,
                          1000000, tail, IMAGE_TYPE_SHADOW, info->image);
     }
 
@@ -832,7 +800,7 @@ static ASS_Image *render_text(RenderContext *state)
             // do nothing
         } else {
             tail =
-                render_glyph(state, info->bm_o, info->x, info->y, info->c[2],
+                render_glyph(render_priv, info->bm_o, info->x, info->y, info->c[2],
                              0, 1000000, tail, IMAGE_TYPE_OUTLINE, info->image);
         }
     }
@@ -846,22 +814,22 @@ static ASS_Image *render_text(RenderContext *state)
                 || (info->effect_type == EF_KARAOKE_KO)) {
             if (info->effect_timing > 0)
                 tail =
-                    render_glyph(state, info->bm, info->x, info->y,
+                    render_glyph(render_priv, info->bm, info->x, info->y,
                                  info->c[0], 0, 1000000, tail,
                                  IMAGE_TYPE_CHARACTER, info->image);
             else
                 tail =
-                    render_glyph(state, info->bm, info->x, info->y,
+                    render_glyph(render_priv, info->bm, info->x, info->y,
                                  info->c[1], 0, 1000000, tail,
                                  IMAGE_TYPE_CHARACTER, info->image);
         } else if (info->effect_type == EF_KARAOKE_KF) {
             tail =
-                render_glyph(state, info->bm, info->x, info->y, info->c[0],
+                render_glyph(render_priv, info->bm, info->x, info->y, info->c[0],
                              info->c[1], info->effect_timing, tail,
                              IMAGE_TYPE_CHARACTER, info->image);
         } else
             tail =
-                render_glyph(state, info->bm, info->x, info->y, info->c[0],
+                render_glyph(render_priv, info->bm, info->x, info->y, info->c[0],
                              0, 1000000, tail, IMAGE_TYPE_CHARACTER, info->image);
     }
 
@@ -869,7 +837,7 @@ static ASS_Image *render_text(RenderContext *state)
         ass_cache_dec_ref(bitmaps[i].image);
 
     *tail = 0;
-    blend_vector_clip(state, head);
+    blend_vector_clip(render_priv, head);
 
     return head;
 }
@@ -894,20 +862,21 @@ static void compute_string_bbox(TextInfo *text, ASS_DRect *bbox)
         bbox->x_min = bbox->x_max = bbox->y_min = bbox->y_max = 0;
 }
 
-static ASS_Style *handle_selective_style_overrides(RenderContext *state,
+static ASS_Style *handle_selective_style_overrides(ASS_Renderer *render_priv,
                                                    ASS_Style *rstyle)
 {
     // The script style is the one the event was declared with.
-    ASS_Renderer *render_priv = state->renderer;
     ASS_Style *script = render_priv->track->styles +
-                        state->event->Style;
+                        render_priv->state.event->Style;
     // The user style was set with ass_set_selective_style_override().
     ASS_Style *user = &render_priv->user_override_style;
-    ASS_Style *new = &state->override_style_temp_storage;
-    int explicit = state->explicit;
+    ASS_Style *new = &render_priv->state.override_style_temp_storage;
+    int explicit = render_priv->state.explicit;
     int requested = render_priv->settings.selective_style_overrides;
     double scale;
 
+    user->Name = "OverrideStyle"; // name insignificant
+
     // Either the event's style, or the style forced with a \r tag.
     if (!rstyle)
         rstyle = script;
@@ -917,7 +886,7 @@ static ASS_Style *handle_selective_style_overrides(RenderContext *state,
     // script's style that are deemed necessary.
     *new = *rstyle;
 
-    state->apply_font_scale =
+    render_priv->state.apply_font_scale =
         !explicit || !(requested & ASS_OVERRIDE_BIT_SELECTIVE_FONT_SCALE);
 
     // On positioned events, do not apply most overrides.
@@ -987,72 +956,35 @@ static ASS_Style *handle_selective_style_overrides(RenderContext *state,
     if (!new->FontName)
         new->FontName = rstyle->FontName;
 
-    state->style = new;
-    state->overrides = requested;
+    render_priv->state.style = new;
+    render_priv->state.overrides = requested;
 
     return new;
 }
 
-ASS_Vector ass_layout_res(ASS_Renderer *render_priv)
-{
-    ASS_Track *track = render_priv->track;
-    if (track->LayoutResX > 0 && track->LayoutResY > 0)
-        return (ASS_Vector) { track->LayoutResX, track->LayoutResY };
-
-    ASS_Settings *settings = &render_priv->settings;
-    if (settings->storage_width > 0 && settings->storage_height > 0)
-        return (ASS_Vector) { settings->storage_width, settings->storage_height };
-
-    if (settings->par <= 0 || settings->par == 1 ||
-            !render_priv->frame_content_width || !render_priv->frame_content_height)
-        return (ASS_Vector) { track->PlayResX, track->PlayResY };
-    if (settings->par > 1)
-        return (ASS_Vector) {
-            FFMAX(1, lround(track->PlayResY * render_priv->frame_content_width
-                    / render_priv->frame_content_height / settings->par)),
-            track->PlayResY
-        };
-    else
-        return (ASS_Vector) {
-            track->PlayResX,
-            FFMAX(1, lround(track->PlayResX * render_priv->frame_content_height
-                    / render_priv->frame_content_width * settings->par))
-        };
-}
-
-static void init_font_scale(RenderContext *state)
+static void init_font_scale(ASS_Renderer *render_priv)
 {
-    ASS_Renderer *render_priv = state->renderer;
     ASS_Settings *settings_priv = &render_priv->settings;
 
-    double font_scr_w = render_priv->frame_content_width;
-    double font_scr_h = render_priv->frame_content_height;
-    if (!state->explicit && render_priv->settings.use_margins) {
-        font_scr_w = render_priv->fit_width;
+    double font_scr_h = render_priv->orig_height;
+    if (!render_priv->state.explicit && render_priv->settings.use_margins)
         font_scr_h = render_priv->fit_height;
-    }
-
-    state->screen_scale_x = font_scr_w / render_priv->track->PlayResX;
-    state->screen_scale_y = font_scr_h / render_priv->track->PlayResY;
 
-    ASS_Vector layout_res = ass_layout_res(render_priv);
-    state->blur_scale_x = font_scr_w / layout_res.x;
-    state->blur_scale_y = font_scr_h / layout_res.y;
-    if (render_priv->track->ScaledBorderAndShadow) {
-        state->border_scale_x = state->screen_scale_x;
-        state->border_scale_y = state->screen_scale_y;
-    } else {
-        state->border_scale_x = state->blur_scale_x;
-        state->border_scale_y = state->blur_scale_y;
-    }
+    render_priv->font_scale = font_scr_h / render_priv->track->PlayResY;
+    if (settings_priv->storage_height)
+        render_priv->blur_scale = font_scr_h / settings_priv->storage_height;
+    else
+        render_priv->blur_scale = font_scr_h / render_priv->track->PlayResY;
+    if (render_priv->track->ScaledBorderAndShadow)
+        render_priv->border_scale =
+            font_scr_h / render_priv->track->PlayResY;
+    else
+        render_priv->border_scale = render_priv->blur_scale;
 
-    if (state->apply_font_scale) {
-        state->screen_scale_x *= settings_priv->font_size_coeff;
-        state->screen_scale_y *= settings_priv->font_size_coeff;
-        state->border_scale_x *= settings_priv->font_size_coeff;
-        state->border_scale_y *= settings_priv->font_size_coeff;
-        state->blur_scale_x *= settings_priv->font_size_coeff;
-        state->blur_scale_y *= settings_priv->font_size_coeff;
+    if (render_priv->state.apply_font_scale) {
+        render_priv->font_scale *= settings_priv->font_size_coeff;
+        render_priv->border_scale *= settings_priv->font_size_coeff;
+        render_priv->blur_scale *= settings_priv->font_size_coeff;
     }
 }
 
@@ -1060,98 +992,94 @@ static void init_font_scale(RenderContext *state)
  * \brief partially reset render_context to style values
  * Works like {\r}: resets some style overrides
  */
-void ass_reset_render_context(RenderContext *state, ASS_Style *style)
+void reset_render_context(ASS_Renderer *render_priv, ASS_Style *style)
 {
-    style = handle_selective_style_overrides(state, style);
+    style = handle_selective_style_overrides(render_priv, style);
 
-    init_font_scale(state);
+    init_font_scale(render_priv);
 
-    state->c[0] = style->PrimaryColour;
-    state->c[1] = style->SecondaryColour;
-    state->c[2] = style->OutlineColour;
-    state->c[3] = style->BackColour;
-    state->flags =
+    render_priv->state.c[0] = style->PrimaryColour;
+    render_priv->state.c[1] = style->SecondaryColour;
+    render_priv->state.c[2] = style->OutlineColour;
+    render_priv->state.c[3] = style->BackColour;
+    render_priv->state.flags =
         (style->Underline ? DECO_UNDERLINE : 0) |
         (style->StrikeOut ? DECO_STRIKETHROUGH : 0);
-    state->font_size = style->FontSize;
-
-    state->family.str = style->FontName;
-    state->family.len = strlen(style->FontName);
-    state->treat_family_as_pattern = style->treat_fontname_as_pattern;
-    state->bold = style->Bold;
-    state->italic = style->Italic;
-    ass_update_font(state);
-
-    state->border_style = style->BorderStyle;
-    state->border_x = style->Outline;
-    state->border_y = style->Outline;
-    state->scale_x = style->ScaleX;
-    state->scale_y = style->ScaleY;
-    state->hspacing = style->Spacing;
-    state->be = 0;
-    state->blur = style->Blur;
-    state->shadow_x = style->Shadow;
-    state->shadow_y = style->Shadow;
-    state->frx = state->fry = 0.;
-    state->frz = style->Angle;
-    state->fax = state->fay = 0.;
-    state->font_encoding = style->Encoding;
+    render_priv->state.font_size = style->FontSize;
+
+    render_priv->state.family.str = style->FontName;
+    render_priv->state.family.len = strlen(style->FontName);
+    render_priv->state.treat_family_as_pattern = style->treat_fontname_as_pattern;
+    render_priv->state.bold = style->Bold;
+    render_priv->state.italic = style->Italic;
+    update_font(render_priv);
+
+    render_priv->state.border_style = style->BorderStyle;
+    render_priv->state.border_x = style->Outline;
+    render_priv->state.border_y = style->Outline;
+    render_priv->state.scale_x = style->ScaleX;
+    render_priv->state.scale_y = style->ScaleY;
+    render_priv->state.hspacing = style->Spacing;
+    render_priv->state.be = 0;
+    render_priv->state.blur = style->Blur;
+    render_priv->state.shadow_x = style->Shadow;
+    render_priv->state.shadow_y = style->Shadow;
+    render_priv->state.frx = render_priv->state.fry = 0.;
+    render_priv->state.frz = style->Angle;
+    render_priv->state.fax = render_priv->state.fay = 0.;
+    render_priv->state.font_encoding = style->Encoding;
 }
 
 /**
- * \brief Start new event. Reset state.
+ * \brief Start new event. Reset render_priv->state.
  */
 static void
-init_render_context(RenderContext *state, ASS_Event *event)
+init_render_context(ASS_Renderer *render_priv, ASS_Event *event)
 {
-    ASS_Renderer *render_priv = state->renderer;
+    render_priv->state.event = event;
+    render_priv->state.parsed_tags = 0;
+    render_priv->state.evt_type = EVENT_NORMAL;
 
-    state->event = event;
-    state->parsed_tags = 0;
-    state->evt_type = EVENT_NORMAL;
+    render_priv->state.wrap_style = render_priv->track->WrapStyle;
 
-    state->wrap_style = render_priv->track->WrapStyle;
+    render_priv->state.pos_x = 0;
+    render_priv->state.pos_y = 0;
+    render_priv->state.org_x = 0;
+    render_priv->state.org_y = 0;
+    render_priv->state.have_origin = 0;
+    render_priv->state.clip_x0 = 0;
+    render_priv->state.clip_y0 = 0;
+    render_priv->state.clip_x1 = render_priv->track->PlayResX;
+    render_priv->state.clip_y1 = render_priv->track->PlayResY;
+    render_priv->state.clip_mode = 0;
+    render_priv->state.detect_collisions = 1;
+    render_priv->state.fade = 0;
+    render_priv->state.drawing_scale = 0;
+    render_priv->state.pbo = 0;
+    render_priv->state.effect_type = EF_NONE;
+    render_priv->state.effect_timing = 0;
+    render_priv->state.effect_skip_timing = 0;
 
-    state->pos_x = 0;
-    state->pos_y = 0;
-    state->org_x = 0;
-    state->org_y = 0;
-    state->have_origin = 0;
-    state->clip_x0 = 0;
-    state->clip_y0 = 0;
-    state->clip_x1 = render_priv->track->PlayResX;
-    state->clip_y1 = render_priv->track->PlayResY;
-    state->clip_mode = 0;
-    state->detect_collisions = 1;
-    state->fade = 0;
-    state->drawing_scale = 0;
-    state->pbo = 0;
-    state->effect_type = EF_NONE;
-    state->effect_timing = 0;
-    state->effect_skip_timing = 0;
-    state->reset_effect = false;
+    apply_transition_effects(render_priv, event);
+    render_priv->state.explicit = render_priv->state.evt_type != EVENT_NORMAL ||
+                                  event_has_hard_overrides(event->Text);
 
-    ass_apply_transition_effects(state);
-    state->explicit = state->evt_type != EVENT_NORMAL ||
-                      ass_event_has_hard_overrides(event->Text);
-
-    ass_reset_render_context(state, NULL);
-    state->alignment = state->style->Alignment;
-    state->justify = state->style->Justify;
+    reset_render_context(render_priv, NULL);
+    render_priv->state.alignment = render_priv->state.style->Alignment;
+    render_priv->state.justify = render_priv->state.style->Justify;
 }
 
-static void free_render_context(RenderContext *state)
+static void free_render_context(ASS_Renderer *render_priv)
 {
-    ass_cache_dec_ref(state->font);
+    ass_cache_dec_ref(render_priv->state.font);
 
-    state->font = NULL;
-    state->family.str = NULL;
-    state->family.len = 0;
-    state->clip_drawing_text.str = NULL;
-    state->clip_drawing_text.len = 0;
+    render_priv->state.font = NULL;
+    render_priv->state.family.str = NULL;
+    render_priv->state.family.len = 0;
+    render_priv->state.clip_drawing_text.str = NULL;
+    render_priv->state.clip_drawing_text.len = 0;
 
-    if (state->text_info)
-        state->text_info->length = 0;
+    render_priv->text_info.length = 0;
 }
 
 /**
@@ -1162,9 +1090,8 @@ static void free_render_context(RenderContext *state)
  * and add them to cache.
  */
 static void
-get_outline_glyph(RenderContext *state, GlyphInfo *info)
+get_outline_glyph(ASS_Renderer *priv, GlyphInfo *info)
 {
-    ASS_Renderer *priv = state->renderer;
     OutlineHashValue *val;
     ASS_DVector scale, offset = {0};
 
@@ -1180,9 +1107,9 @@ get_outline_glyph(RenderContext *state, GlyphInfo *info)
         }
 
         int32_t scale_base = lshiftwrapi(1, info->drawing_scale - 1);
-        double w = scale_base > 0 ? (1.0 / scale_base) : 0;
-        scale.x = info->scale_x * w * state->screen_scale_x / priv->par_scale_x;
-        scale.y = info->scale_y * w * state->screen_scale_y;
+        double w = scale_base > 0 ? (priv->font_scale / scale_base) : 0;
+        scale.x = info->scale_x * w;
+        scale.y = info->scale_y * w;
         desc = 64 * info->drawing_pbo;
         asc = val->asc - desc;
 
@@ -1271,26 +1198,26 @@ size_t ass_outline_construct(void *key, void *value, void *priv)
                 break;
 
             ASS_Outline src;
-            if (!ass_outline_scale_pow2(&src, &k->outline->outline[0],
-                                        k->scale_ord_x, k->scale_ord_y))
+            if (!outline_scale_pow2(&src, &k->outline->outline[0],
+                                    k->scale_ord_x, k->scale_ord_y))
                 return 1;
-            if (!ass_outline_stroke(&v->outline[0], &v->outline[1], &src,
-                                    k->border.x * STROKER_PRECISION,
-                                    k->border.y * STROKER_PRECISION,
-                                    STROKER_PRECISION)) {
+            if (!outline_stroke(&v->outline[0], &v->outline[1], &src,
+                                k->border.x * STROKER_PRECISION,
+                                k->border.y * STROKER_PRECISION,
+                                STROKER_PRECISION)) {
                 ass_msg(render_priv->library, MSGL_WARN, "Cannot stroke outline");
-                ass_outline_free(&v->outline[0]);
-                ass_outline_free(&v->outline[1]);
-                ass_outline_free(&src);
+                outline_free(&v->outline[0]);
+                outline_free(&v->outline[1]);
+                outline_free(&src);
                 return 1;
             }
-            ass_outline_free(&src);
+            outline_free(&src);
             break;
         }
     case OUTLINE_BOX:
         {
             ASS_Outline *ol = &v->outline[0];
-            if (!ass_outline_alloc(ol, 4, 4))
+            if (!outline_alloc(ol, 4, 4))
                 return 1;
             ol->points[0].x = ol->points[3].x = 0;
             ol->points[1].x = ol->points[2].x = 64;
@@ -1308,8 +1235,8 @@ size_t ass_outline_construct(void *key, void *value, void *priv)
     }
 
     rectangle_reset(&v->cbox);
-    ass_outline_update_cbox(&v->outline[0], &v->cbox);
-    ass_outline_update_cbox(&v->outline[1], &v->cbox);
+    outline_update_cbox(&v->outline[0], &v->cbox);
+    outline_update_cbox(&v->outline[1], &v->cbox);
     if (v->cbox.x_min > v->cbox.x_max || v->cbox.y_min > v->cbox.y_max)
         v->cbox.x_min = v->cbox.y_min = v->cbox.x_max = v->cbox.y_max = 0;
     v->valid = true;
@@ -1319,11 +1246,9 @@ size_t ass_outline_construct(void *key, void *value, void *priv)
 /**
  * \brief Calculate outline transformation matrix
  */
-static void calc_transform_matrix(RenderContext *state,
+static void calc_transform_matrix(ASS_Renderer *render_priv,
                                   GlyphInfo *info, double m[3][3])
 {
-    ASS_Renderer *render_priv = state->renderer;
-
     double frx = ASS_PI / 180 * info->frx;
     double fry = ASS_PI / 180 * info->fry;
     double frz = ASS_PI / 180 * info->frz;
@@ -1355,11 +1280,11 @@ static void calc_transform_matrix(RenderContext *state,
         z4[i] = x2[i] * sy + z3[i] * cy;
     }
 
-    double dist = 20000 * state->blur_scale_y;
+    double dist = 20000 * render_priv->blur_scale;
     z4[2] += dist;
 
-    double scale_x = dist * render_priv->par_scale_x;
-    double offs_x = info->pos.x - info->shift.x * render_priv->par_scale_x;
+    double scale_x = dist * render_priv->font_scale_x;
+    double offs_x = info->pos.x - info->shift.x * render_priv->font_scale_x;
     double offs_y = info->pos.y - info->shift.y;
     for (int i = 0; i < 3; i++) {
         m[0][i] = z4[i] * offs_x + x4[i] * scale_x;
@@ -1377,13 +1302,11 @@ static void calc_transform_matrix(RenderContext *state,
  * They are returned in info->bm (glyph), info->bm_o (outline).
  */
 static void
-get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
+get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info,
                  int32_t *leftmost_x,
                  ASS_Vector *pos, ASS_Vector *pos_o,
                  ASS_DVector *offset, bool first, int flags)
 {
-    ASS_Renderer *render_priv = state->renderer;
-
     if (!info->outline || info->symbol == '\n' || info->symbol == 0 || info->skip) {
         ass_cache_dec_ref(info->outline);
         return;
@@ -1391,7 +1314,7 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
 
     double m1[3][3], m2[3][3], m[3][3];
     const ASS_Transform *tr = &info->transform;
-    calc_transform_matrix(state, info, m1);
+    calc_transform_matrix(render_priv, info, m1);
     for (int i = 0; i < 3; i++) {
         m2[i][0] = m1[i][0] * tr->scale.x;
         m2[i][1] = m1[i][1] * tr->scale.y;
@@ -1400,7 +1323,7 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
     memcpy(m, m2, sizeof(m));
 
     if (info->effect_type == EF_KARAOKE_KF)
-        ass_outline_update_min_transformed_x(&info->outline->outline[0], m, leftmost_x);
+        outline_update_min_transformed_x(&info->outline->outline[0], m, leftmost_x);
 
     BitmapHashKey key;
     key.outline = info->outline;
@@ -1408,7 +1331,7 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
         ass_cache_dec_ref(info->outline);
         return;
     }
-    info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, state);
+    info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);
     if (!info->bm || !info->bm->buffer) {
         ass_cache_dec_ref(info->bm);
         info->bm = NULL;
@@ -1422,11 +1345,8 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
 
         ol_key.type = OUTLINE_BOX;
 
-        ASS_DVector bord = {
-            64 * info->border_x * state->border_scale_x /
-                render_priv->par_scale_x,
-            64 * info->border_y * state->border_scale_y,
-        };
+        double w = 64 * render_priv->border_scale;
+        ASS_DVector bord = { info->border_x * w, info->border_y * w };
         double width = info->hspacing_scaled + info->advance.x;
         double height = info->asc + info->desc;
 
@@ -1463,11 +1383,9 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
         BorderHashKey *k = &ol_key.u.border;
         k->outline = info->outline;
 
-        double bord_x =
-            64 * state->border_scale_x * info->border_x / tr->scale.x /
-                render_priv->par_scale_x;
-        double bord_y =
-            64 * state->border_scale_y * info->border_y / tr->scale.y;
+        double w = 64 * render_priv->border_scale;
+        double bord_x = w * info->border_x / tr->scale.x;
+        double bord_y = w * info->border_y / tr->scale.y;
 
         const ASS_Rect *bbox = &info->outline->cbox;
         // Estimate bounding box half size after stroking
@@ -1481,7 +1399,7 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
         double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]);
 
         double z0 = m[2][2] - mzx * dx - mzy * dy;
-        double w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);
+        w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE);
 
         // Notation from quantize_transform().
         // Note that goal here is to estimate acceptable error for stroking, i. e. D(x) and D(y).
@@ -1535,7 +1453,7 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
         ass_cache_dec_ref(key.outline);
         return;
     }
-    info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, state);
+    info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv);
     if (!info->bm_o || !info->bm_o->buffer) {
         ass_cache_dec_ref(info->bm_o);
         info->bm_o = NULL;
@@ -1544,14 +1462,9 @@ get_bitmap_glyph(RenderContext *state, GlyphInfo *info,
         *pos = *pos_o;
 }
 
-static inline size_t outline_size(const ASS_Outline* outline)
-{
-    return sizeof(ASS_Vector) * outline->n_points + outline->n_segments;
-}
-
 size_t ass_bitmap_construct(void *key, void *value, void *priv)
 {
-    RenderContext *state = priv;
+    ASS_Renderer *render_priv = priv;
     BitmapHashKey *k = key;
     Bitmap *bm = value;
 
@@ -1560,38 +1473,36 @@ size_t ass_bitmap_construct(void *key, void *value, void *priv)
 
     ASS_Outline outline[2];
     if (k->matrix_z.x || k->matrix_z.y) {
-        ass_outline_transform_3d(&outline[0], &k->outline->outline[0], m);
-        ass_outline_transform_3d(&outline[1], &k->outline->outline[1], m);
+        outline_transform_3d(&outline[0], &k->outline->outline[0], m);
+        outline_transform_3d(&outline[1], &k->outline->outline[1], m);
     } else {
-        ass_outline_transform_2d(&outline[0], &k->outline->outline[0], m);
-        ass_outline_transform_2d(&outline[1], &k->outline->outline[1], m);
+        outline_transform_2d(&outline[0], &k->outline->outline[0], m);
+        outline_transform_2d(&outline[1], &k->outline->outline[1], m);
     }
 
-    if (!ass_outline_to_bitmap(state, bm, &outline[0], &outline[1]))
+    if (!outline_to_bitmap(render_priv, bm, &outline[0], &outline[1]))
         memset(bm, 0, sizeof(*bm));
-    ass_outline_free(&outline[0]);
-    ass_outline_free(&outline[1]);
+    outline_free(&outline[0]);
+    outline_free(&outline[1]);
 
-    return sizeof(BitmapHashKey) + sizeof(Bitmap) + bitmap_size(bm) +
-           sizeof(OutlineHashValue) + outline_size(&k->outline->outline[0]) + outline_size(&k->outline->outline[1]);
+    return sizeof(BitmapHashKey) + sizeof(Bitmap) + bitmap_size(bm);
 }
 
-static void measure_text_on_eol(RenderContext *state, double scale, int cur_line,
+static void measure_text_on_eol(ASS_Renderer *render_priv, double scale, int cur_line,
                                 int max_asc, int max_desc,
                                 double max_border_x, double max_border_y)
 {
-    TextInfo *text_info = state->text_info;
-    text_info->lines[cur_line].asc  = scale * max_asc;
-    text_info->lines[cur_line].desc = scale * max_desc;
-    text_info->height += scale * max_asc + scale * max_desc;
+    render_priv->text_info.lines[cur_line].asc  = scale * max_asc;
+    render_priv->text_info.lines[cur_line].desc = scale * max_desc;
+    render_priv->text_info.height += scale * max_asc + scale * max_desc;
     // For *VSFilter compatibility do biased rounding on max_border*
     // https://github.com/Cyberbeing/xy-VSFilter/blob/xy_sub_filter_rc4@%7B2020-05-17%7D/src/subtitles/RTS.cpp#L1465
-    text_info->border_bottom = (int) (state->border_scale_y * max_border_y + 0.5);
+    render_priv->text_info.border_bottom = (int) (render_priv->border_scale * max_border_y + 0.5);
     if (cur_line == 0)
-        text_info->border_top = text_info->border_bottom;
+        render_priv->text_info.border_top = render_priv->text_info.border_bottom;
     // VSFilter takes max \bordx into account for collision, even if far from edge
-    text_info->border_x = FFMAX(text_info->border_x,
-            (int) (state->border_scale_x * max_border_x + 0.5));
+    render_priv->text_info.border_x = FFMAX(render_priv->text_info.border_x,
+            (int) (render_priv->border_scale * max_border_x + 0.5));
 }
 
 
@@ -1605,10 +1516,9 @@ static void measure_text_on_eol(RenderContext *state, double scale, int cur_line
  *   lines[].asc
  *   lines[].desc
  */
-static void measure_text(RenderContext *state)
+static void measure_text(ASS_Renderer *render_priv)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    TextInfo *text_info = state->text_info;
+    TextInfo *text_info = &render_priv->text_info;
     text_info->height = 0;
     text_info->border_x = 0;
 
@@ -1619,7 +1529,7 @@ static void measure_text(RenderContext *state)
     bool empty_trimmed_line = true;
     for (int i = 0; i < text_info->length; i++) {
         if (text_info->glyphs[i].linebreak) {
-            measure_text_on_eol(state, scale, cur_line,
+            measure_text_on_eol(render_priv, scale, cur_line,
                     max_asc, max_desc, max_border_x, max_border_y);
             empty_trimmed_line = true;
             max_asc = max_desc = 0;
@@ -1647,7 +1557,7 @@ static void measure_text(RenderContext *state)
             scale = 1.0 / 64;
     }
     assert(cur_line == text_info->n_lines - 1);
-    measure_text_on_eol(state, scale, cur_line,
+    measure_text_on_eol(render_priv, scale, cur_line,
             max_asc, max_desc, max_border_x, max_border_y);
     text_info->height += cur_line * render_priv->settings.line_spacing;
 }
@@ -1657,11 +1567,11 @@ static void measure_text(RenderContext *state)
  */
 #define IS_WHITESPACE(x) ((x->symbol == ' ' || x->symbol == '\n') \
                           && !x->linebreak)
-static void trim_whitespace(RenderContext *state)
+static void trim_whitespace(ASS_Renderer *render_priv)
 {
     int i, j;
     GlyphInfo *cur;
-    TextInfo *ti = state->text_info;
+    TextInfo *ti = &render_priv->text_info;
 
     // Mark trailing spaces
     i = ti->length - 1;
@@ -1717,154 +1627,122 @@ static void trim_whitespace(RenderContext *state)
 }
 #undef IS_WHITESPACE
 
-#ifdef CONFIG_UNIBREAK
-    #define ALLOWBREAK(glyph, index) (unibrks ? unibrks[index] == LINEBREAK_ALLOWBREAK : glyph == ' ')
-    #define FORCEBREAK(glyph, index) (unibrks ? unibrks[index] == LINEBREAK_MUSTBREAK  : glyph == '\n')
-#else
-    #define ALLOWBREAK(glyph, index) (glyph == ' ')
-    #define FORCEBREAK(glyph, index) (glyph == '\n')
-#endif
-
-/*
- * Starts a new line on the first breakable character after overflow
+/**
+ * \brief rearrange text between lines
+ * \param max_text_width maximal text line width in pixels
+ * The algo is similar to the one in libvo/sub.c:
+ * 1. Place text, wrapping it when current line is full
+ * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
+ * the difference in lengths between this two lines.
+ * The result may not be optimal, but usually is good enough.
+ *
+ * FIXME: implement style 0 and 3 correctly
  */
 static void
-wrap_lines_naive(RenderContext *state, double max_text_width, char *unibrks)
+wrap_lines_smart(ASS_Renderer *render_priv, double max_text_width)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    TextInfo *text_info = state->text_info;
-    GlyphInfo *s1  = text_info->glyphs; // current line start
-    int last_breakable = -1;
-    int break_type = 0;
-
+    int i;
+    GlyphInfo *cur, *s1, *e1, *s2, *s3;
+    int last_space;
+    int break_type;
+    int exit;
+    double pen_shift_x;
+    double pen_shift_y;
+    int cur_line;
+    TextInfo *text_info = &render_priv->text_info;
+
+    last_space = -1;
     text_info->n_lines = 1;
-    for (int i = 0; i < text_info->length; ++i) {
-        GlyphInfo *cur = text_info->glyphs + i;
+    break_type = 0;
+    s1 = text_info->glyphs;     // current line start
+    for (i = 0; i < text_info->length; ++i) {
         int break_at = -1;
-        double s_offset = d6_to_double(s1->bbox.x_min + s1->pos.x);
-        double len = d6_to_double(cur->bbox.x_max + cur->pos.x) - s_offset;
+        double s_offset, len;
+        cur = text_info->glyphs + i;
+        s_offset = d6_to_double(s1->bbox.x_min + s1->pos.x);
+        len = d6_to_double(cur->bbox.x_max + cur->pos.x) - s_offset;
 
-        if (FORCEBREAK(cur->symbol, i)) {
+        if (cur->symbol == '\n') {
             break_type = 2;
             break_at = i;
             ass_msg(render_priv->library, MSGL_DBG2,
                     "forced line break at %d", break_at);
-        } else if (len >= max_text_width &&
-                   cur->symbol != ' ' /* get trimmed */ &&
-                   (state->wrap_style != 2)) {
+        } else if (cur->symbol == ' ') {
+            last_space = i;
+        } else if (len >= max_text_width
+                   && (render_priv->state.wrap_style != 2)) {
             break_type = 1;
-            break_at = last_breakable;
+            break_at = last_space;
             if (break_at >= 0)
                 ass_msg(render_priv->library, MSGL_DBG2, "line break at %d",
                         break_at);
         }
-        if (ALLOWBREAK(cur->symbol, i)) {
-            last_breakable = i;
-        }
 
         if (break_at != -1) {
             // need to use one more line
             // marking break_at+1 as start of a new line
             int lead = break_at + 1;    // the first symbol of the new line
             if (text_info->n_lines >= text_info->max_lines) {
-                // Try to raise the maximum number of lines
-                bool success = false;
-                if (text_info->max_lines <= INT_MAX / 2) {
-                    text_info->max_lines *= 2;
-                    success = ASS_REALLOC_ARRAY(text_info->lines, text_info->max_lines);
-                }
-                // If realloc fails it's screwed and due to error-info not propagating (FIXME),
-                // the best we can do is to avoid UB by discarding the previous break
-                if (!success) {
-                    s1->linebreak = 0;
-                    text_info->n_lines--;
-                }
+                // Raise maximum number of lines
+                text_info->max_lines *= 2;
+                text_info->lines = realloc(text_info->lines,
+                                           sizeof(LineInfo) *
+                                           text_info->max_lines);
             }
             if (lead < text_info->length) {
                 text_info->glyphs[lead].linebreak = break_type;
-                last_breakable = -1;
+                last_space = -1;
                 s1 = text_info->glyphs + lead;
                 text_info->n_lines++;
             }
         }
     }
-}
-
-/*
- * Rewind from a linestart position back to the first non-whitespace (0x20)
- * character. Trailing ASCII whitespace gets trimmed in rendering.
- * Assumes both arguments are part of the same array.
- */
-static inline GlyphInfo *rewind_trailing_spaces(GlyphInfo *start1, GlyphInfo* start2)
-{
-    GlyphInfo *g = start2;
-    do {
-        --g;
-    } while ((g > start1) && (g->symbol == ' '));
-    return g;
-}
-
-/*
- * Shift soft linebreaks to balance out line lengths
- * Does not change the linebreak count
- * FIXME: implement style 0 and 3 correctly
- */
-static void
-wrap_lines_rebalance(RenderContext *state, double max_text_width, char *unibrks)
-{
-    TextInfo *text_info = state->text_info;
-    int exit = 0;
-
 #define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))
-    while (!exit && state->wrap_style != 1) {
+    exit = 0;
+    while (!exit && render_priv->state.wrap_style != 1) {
         exit = 1;
-        GlyphInfo  *s1, *s2, *s3;
         s3 = text_info->glyphs;
         s1 = s2 = 0;
-        for (int i = 0; i <= text_info->length; ++i) {
-            GlyphInfo *cur = text_info->glyphs + i;
+        for (i = 0; i <= text_info->length; ++i) {
+            cur = text_info->glyphs + i;
             if ((i == text_info->length) || cur->linebreak) {
                 s1 = s2;
                 s2 = s3;
                 s3 = cur;
                 if (s1 && (s2->linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'
                     double l1, l2, l1_new, l2_new;
+                    GlyphInfo *w = s2;
 
-                    // Find last word of line and trim surrounding whitespace before measuring
-                    // (whitespace ' ' will also get trimmed in rendering)
-                    GlyphInfo *w = rewind_trailing_spaces(s1, s2);
-                    GlyphInfo *e1_old = w;
-                    while ((w > s1) && (!ALLOWBREAK(w->symbol, w - text_info->glyphs))) {
+                    do {
+                        --w;
+                    } while ((w > s1) && (w->symbol == ' '));
+                    while ((w > s1) && (w->symbol != ' ')) {
                         --w;
                     }
-                    GlyphInfo *e1 = w;
+                    e1 = w;
                     while ((e1 > s1) && (e1->symbol == ' ')) {
                         --e1;
                     }
                     if (w->symbol == ' ')
                         ++w;
-                    if (w == s1)
-                        continue; // Merging linebreaks is never beneficial
 
-                    GlyphInfo *e2 = rewind_trailing_spaces(s2, s3);
-
-                    l1 = d6_to_double(
-                        (e1_old->bbox.x_max + e1_old->pos.x) -
+                    l1 = d6_to_double(((s2 - 1)->bbox.x_max + (s2 - 1)->pos.x) -
                         (s1->bbox.x_min + s1->pos.x));
-                    l2 = d6_to_double(
-                        (e2->bbox.x_max + e2->pos.x) -
+                    l2 = d6_to_double(((s3 - 1)->bbox.x_max + (s3 - 1)->pos.x) -
                         (s2->bbox.x_min + s2->pos.x));
                     l1_new = d6_to_double(
                         (e1->bbox.x_max + e1->pos.x) -
                         (s1->bbox.x_min + s1->pos.x));
                     l2_new = d6_to_double(
-                        (e2->bbox.x_max + e2->pos.x) -
+                        ((s3 - 1)->bbox.x_max + (s3 - 1)->pos.x) -
                         (w->bbox.x_min + w->pos.x));
 
                     if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {
-                        w->linebreak = 1;
+                        if (w->linebreak || w == text_info->glyphs)
+                            text_info->n_lines--;
+                        if (w != text_info->glyphs)
+                            w->linebreak = 1;
                         s2->linebreak = 0;
-                        s2 = w;
                         exit = 0;
                     }
                 }
@@ -1876,24 +1754,23 @@ wrap_lines_rebalance(RenderContext *state, double max_text_width, char *unibrks)
     }
     assert(text_info->n_lines >= 1);
 #undef DIFF
-}
 
-static void
-wrap_lines_measure(RenderContext *state, char *unibrks)
-{
-    TextInfo *text_info = state->text_info;
-    int cur_line = 1;
-    int i = 0;
+    trim_whitespace(render_priv);
+    measure_text(render_priv);
 
-    while (i < text_info->length && text_info->glyphs[i].skip)
-        ++i;
-    double pen_shift_x = d6_to_double(-text_info->glyphs[i].pos.x);
-    double pen_shift_y = 0.;
+    cur_line = 1;
+
+    i = 0;
+    cur = text_info->glyphs + i;
+    while (i < text_info->length && cur->skip)
+        cur = text_info->glyphs + ++i;
+    pen_shift_x = d6_to_double(-cur->pos.x);
+    pen_shift_y = 0.;
 
     for (i = 0; i < text_info->length; ++i) {
-        GlyphInfo *cur = text_info->glyphs + i;
+        cur = text_info->glyphs + i;
         if (cur->linebreak) {
-            while (i < text_info->length && cur->skip && !FORCEBREAK(cur->symbol, i))
+            while (i < text_info->length && cur->skip && cur->symbol != '\n')
                 cur = text_info->glyphs + ++i;
             double height =
                 text_info->lines[cur_line - 1].desc +
@@ -1903,62 +1780,21 @@ wrap_lines_measure(RenderContext *state, char *unibrks)
             text_info->lines[cur_line].offset = i;
             cur_line++;
             pen_shift_x = d6_to_double(-cur->pos.x);
-            pen_shift_y += height + state->renderer->settings.line_spacing;
+            pen_shift_y += height + render_priv->settings.line_spacing;
         }
         cur->pos.x += double_to_d6(pen_shift_x);
         cur->pos.y += double_to_d6(pen_shift_y);
     }
     text_info->lines[cur_line - 1].len =
         text_info->length - text_info->lines[cur_line - 1].offset;
-}
 
-#undef ALLOWBREAK
-#undef FORCEBREAK
-
-/**
- * \brief rearrange text between lines
- * \param max_text_width maximal text line width in pixels
- * The algo is similar to the one in libvo/sub.c:
- * 1. Place text, wrapping it when current line is full
- * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
- * the difference in lengths between this two lines.
- * The result may not be optimal, but usually is good enough.
- *
- * FIXME: implement style 0 and 3 correctly
- */
-static void
-wrap_lines_smart(RenderContext *state, double max_text_width)
-{
-    char *unibrks = NULL;
-
-#ifdef CONFIG_UNIBREAK
-    ASS_Renderer *render_priv = state->renderer;
-    TextInfo *text_info = state->text_info;
-    if (render_priv->track->parser_priv->feature_flags & FEATURE_MASK(ASS_FEATURE_WRAP_UNICODE)) {
-        unibrks = text_info->breaks;
-        set_linebreaks_utf32(
-            text_info->event_text, text_info->length,
-            render_priv->track->Language, unibrks);
-#if UNIBREAK_VERSION < 0x0500UL
-        // Prior to 5.0 libunibreaks always ended text with LINE_BREAKMUSTBREAK, matching
-        // Unicode spec, but messing with our text-overflow detection.
-        // Thus reevaluate the last char in a different context.
-        // (Later versions set either MUSTBREAK or the newly added INDETERMINATE)
-        unibrks[text_info->length - 1] = is_line_breakable(
-            text_info->event_text[text_info->length - 1],
-            ' ',
-            render_priv->track->Language
-        );
-#endif
+#if 0
+    // print line info
+    for (i = 0; i < text_info->n_lines; i++) {
+        printf("line %d offset %d length %d\n", i, text_info->lines[i].offset,
+                text_info->lines[i].len);
     }
 #endif
-
-    wrap_lines_naive(state, max_text_width, unibrks);
-    wrap_lines_rebalance(state, max_text_width, unibrks);
-
-    trim_whitespace(state);
-    measure_text(state);
-    wrap_lines_measure(state, unibrks);
 }
 
 /**
@@ -2019,10 +1855,6 @@ fix_glyph_scaling(ASS_Renderer *priv, GlyphInfo *glyph)
         // to freetype. Normalize scale_y to 1.0.
         ft_size = glyph->scale_y * glyph->font_size;
     }
-
-    if (!ft_size || !glyph->font_size)
-        return;
-
     double mul = glyph->font_size / ft_size;
     glyph->scale_fix = 1 / mul;
     glyph->scale_x *= mul;
@@ -2031,14 +1863,13 @@ fix_glyph_scaling(ASS_Renderer *priv, GlyphInfo *glyph)
 }
 
 // Initial run splitting based purely on the characters' styles
-static void split_style_runs(RenderContext *state)
+static void split_style_runs(ASS_Renderer *render_priv)
 {
-    TextInfo *text_info = state->text_info;
-    Effect last_effect_type = text_info->glyphs[0].effect_type;
-    text_info->glyphs[0].starts_new_run = true;
-    for (int i = 1; i < text_info->length; i++) {
-        GlyphInfo *info = text_info->glyphs + i;
-        GlyphInfo *last = text_info->glyphs + (i - 1);
+    Effect last_effect_type = render_priv->text_info.glyphs[0].effect_type;
+    render_priv->text_info.glyphs[0].starts_new_run = true;
+    for (int i = 1; i < render_priv->text_info.length; i++) {
+        GlyphInfo *info = render_priv->text_info.glyphs + i;
+        GlyphInfo *last = render_priv->text_info.glyphs + (i - 1);
         Effect effect_type = info->effect_type;
         info->starts_new_run =
             info->effect_timing ||  // but ignore effect_skip_timing
@@ -2077,10 +1908,9 @@ static void split_style_runs(RenderContext *state)
 
 // Parse event text.
 // Fill render_priv->text_info.
-static bool parse_events(RenderContext *state, ASS_Event *event)
+static bool parse_events(ASS_Renderer *render_priv, ASS_Event *event)
 {
-    TextInfo *text_info = state->text_info;
-    ASS_Renderer *render_priv = state->renderer;
+    TextInfo *text_info = &render_priv->text_info;
 
     char *p = event->Text, *q;
 
@@ -2093,10 +1923,10 @@ static bool parse_events(RenderContext *state, ASS_Event *event)
         unsigned code = 0;
         while (*p) {
             if ((*p == '{') && (q = strchr(p, '}'))) {
-                p = ass_parse_tags(state, p, q, 1., false);
+                p = parse_tags(render_priv, p, q, 1., false);
                 assert(*p == '}');
                 p++;
-            } else if (state->drawing_scale) {
+            } else if (render_priv->state.drawing_scale) {
                 q = p;
                 if (*p == '{')
                     q++;
@@ -2108,7 +1938,7 @@ static bool parse_events(RenderContext *state, ASS_Event *event)
                 p = q;
                 break;
             } else {
-                code = ass_get_next_char(state, &p);
+                code = get_next_char(render_priv, &p);
                 break;
             }
         }
@@ -2117,18 +1947,15 @@ static bool parse_events(RenderContext *state, ASS_Event *event)
             break;
 
         // face could have been changed in get_next_char
-        if (!state->font)
+        if (!render_priv->state.font)
             goto fail;
 
         if (text_info->length >= text_info->max_glyphs) {
             // Raise maximum number of glyphs
-            int new_max = 2 * FFMIN(FFMAX(text_info->max_glyphs, text_info->length / 2 + 1),
-                                    INT_MAX / 2);
+            int new_max = 2 * FFMIN(text_info->max_glyphs, INT_MAX / 2);
             if (text_info->length >= new_max)
                 goto fail;
-            if (!ASS_REALLOC_ARRAY(text_info->glyphs, new_max) ||
-                    !ASS_REALLOC_ARRAY(text_info->event_text, new_max) ||
-                    !ASS_REALLOC_ARRAY(text_info->breaks, new_max))
+            if (!ASS_REALLOC_ARRAY(text_info->glyphs, new_max))
                 goto fail;
             text_info->max_glyphs = new_max;
         }
@@ -2141,86 +1968,85 @@ static bool parse_events(RenderContext *state, ASS_Event *event)
         // Parse drawing
         if (drawing_text.str) {
             info->drawing_text = drawing_text;
-            info->drawing_scale = state->drawing_scale;
-            info->drawing_pbo = state->pbo;
+            info->drawing_scale = render_priv->state.drawing_scale;
+            info->drawing_pbo = render_priv->state.pbo;
         }
 
         // Fill glyph information
         info->symbol = code;
-        info->font = state->font;
+        info->font = render_priv->state.font;
         if (!drawing_text.str)
             ass_cache_inc_ref(info->font);
         for (int i = 0; i < 4; i++) {
-            uint32_t clr = state->c[i];
+            uint32_t clr = render_priv->state.c[i];
+            // VSFilter compatibility: apply fade only when it's positive
             info->a_pre_fade[i] = _a(clr);
-            ass_apply_fade(&clr, state->fade);
+            if (render_priv->state.fade > 0)
+                change_alpha(&clr,
+                             mult_alpha(_a(clr), render_priv->state.fade), 1.);
             info->c[i] = clr;
         }
 
-        info->effect_type = state->effect_type;
-        info->effect_timing = state->effect_timing;
-        info->effect_skip_timing = state->effect_skip_timing;
-        info->reset_effect = state->reset_effect;
-        // VSFilter compatibility: font glyphs use PlayResY scaling in both dimensions
+        info->effect_type = render_priv->state.effect_type;
+        info->effect_timing = render_priv->state.effect_timing;
+        info->effect_skip_timing = render_priv->state.effect_skip_timing;
         info->font_size =
-            fabs(state->font_size * state->screen_scale_y);
-        info->be = state->be;
-        info->blur = state->blur;
-        info->shadow_x = state->shadow_x;
-        info->shadow_y = state->shadow_y;
-        info->scale_x = state->scale_x;
-        info->scale_y = state->scale_y;
-        info->border_style = state->border_style;
-        info->border_x = state->border_x;
-        info->border_y = state->border_y;
-        info->hspacing = state->hspacing;
-        info->bold = state->bold;
-        info->italic = state->italic;
-        info->flags = state->flags;
+            fabs(render_priv->state.font_size * render_priv->font_scale);
+        info->be = render_priv->state.be;
+        info->blur = render_priv->state.blur;
+        info->shadow_x = render_priv->state.shadow_x;
+        info->shadow_y = render_priv->state.shadow_y;
+        info->scale_x = render_priv->state.scale_x;
+        info->scale_y = render_priv->state.scale_y;
+        info->border_style = render_priv->state.border_style;
+        info->border_x = render_priv->state.border_x;
+        info->border_y = render_priv->state.border_y;
+        info->hspacing = render_priv->state.hspacing;
+        info->bold = render_priv->state.bold;
+        info->italic = render_priv->state.italic;
+        info->flags = render_priv->state.flags;
         if (info->font->desc.vertical && code >= VERTICAL_LOWER_BOUND)
             info->flags |= DECO_ROTATE;
-        info->frx = state->frx;
-        info->fry = state->fry;
-        info->frz = state->frz;
-        info->fax = state->fax;
-        info->fay = state->fay;
-        info->fade = state->fade;
+        info->frx = render_priv->state.frx;
+        info->fry = render_priv->state.fry;
+        info->frz = render_priv->state.frz;
+        info->fax = render_priv->state.fax;
+        info->fay = render_priv->state.fay;
+        info->fade = render_priv->state.fade;
 
         info->hspacing_scaled = 0;
         info->scale_fix = 1;
 
         if (!drawing_text.str) {
             info->hspacing_scaled = double_to_d6(info->hspacing *
-                    state->screen_scale_x / render_priv->par_scale_x *
-                    info->scale_x);
+                    render_priv->font_scale * info->scale_x);
             fix_glyph_scaling(render_priv, info);
         }
 
         text_info->length++;
 
-        state->effect_type = EF_NONE;
-        state->effect_timing = 0;
-        state->effect_skip_timing = 0;
-        state->reset_effect = false;
+        render_priv->state.effect_type = EF_NONE;
+        render_priv->state.effect_timing = 0;
+        render_priv->state.effect_skip_timing = 0;
     }
 
     return true;
 
 fail:
-    free_render_context(state);
+    free_render_context(render_priv);
     return false;
 }
 
 // Process render_priv->text_info and load glyph outlines.
-static void retrieve_glyphs(RenderContext *state)
+static void retrieve_glyphs(ASS_Renderer *render_priv)
 {
-    GlyphInfo *glyphs = state->text_info->glyphs;
+    GlyphInfo *glyphs = render_priv->text_info.glyphs;
     int i;
 
-    for (i = 0; i < state->text_info->length; i++) {
+    for (i = 0; i < render_priv->text_info.length; i++) {
         GlyphInfo *info = glyphs + i;
         do {
-            get_outline_glyph(state, info);
+            get_outline_glyph(render_priv, info);
             info = info->next;
         } while (info);
         info = glyphs + i;
@@ -2242,11 +2068,11 @@ static void retrieve_glyphs(RenderContext *state)
 }
 
 // Preliminary layout (for line wrapping)
-static void preliminary_layout(RenderContext *state)
+static void preliminary_layout(ASS_Renderer *render_priv)
 {
     ASS_Vector pen = { 0, 0 };
-    for (int i = 0; i < state->text_info->length; i++) {
-        GlyphInfo *info = state->text_info->glyphs + i;
+    for (int i = 0; i < render_priv->text_info.length; i++) {
+        GlyphInfo *info = render_priv->text_info.glyphs + i;
         ASS_Vector cluster_pen = pen;
         do {
             info->pos.x = cluster_pen.x;
@@ -2257,22 +2083,21 @@ static void preliminary_layout(RenderContext *state)
 
             info = info->next;
         } while (info);
-        info = state->text_info->glyphs + i;
+        info = render_priv->text_info.glyphs + i;
         pen.x += info->cluster_advance.x;
         pen.y += info->cluster_advance.y;
     }
 }
 
 // Reorder text into visual order
-static void reorder_text(RenderContext *state)
+static void reorder_text(ASS_Renderer *render_priv)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    TextInfo *text_info = state->text_info;
-    FriBidiStrIndex *cmap = ass_shaper_reorder(state->shaper, text_info);
+    TextInfo *text_info = &render_priv->text_info;
+    FriBidiStrIndex *cmap = ass_shaper_reorder(render_priv->shaper, text_info);
     if (!cmap) {
         ass_msg(render_priv->library, MSGL_ERR, "Failed to reorder text");
-        ass_shaper_cleanup(state->shaper, text_info);
-        free_render_context(state);
+        ass_shaper_cleanup(render_priv->shaper, text_info);
+        free_render_context(render_priv);
         return;
     }
 
@@ -2303,11 +2128,10 @@ static void reorder_text(RenderContext *state)
     }
 }
 
-static void apply_baseline_shear(RenderContext *state)
+static void apply_baseline_shear(ASS_Renderer *render_priv)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    TextInfo *text_info = state->text_info;
-    FriBidiStrIndex *cmap = ass_shaper_get_reorder_map(state->shaper);
+    TextInfo *text_info = &render_priv->text_info;
+    FriBidiStrIndex *cmap = ass_shaper_get_reorder_map(render_priv->shaper);
     int32_t shear = 0;
     bool whole_text_layout =
         render_priv->track->parser_priv->feature_flags &
@@ -2327,18 +2151,18 @@ static void apply_baseline_shear(RenderContext *state)
     }
 }
 
-static void align_lines(RenderContext *state, double max_text_width)
+static void align_lines(ASS_Renderer *render_priv, double max_text_width)
 {
-    TextInfo *text_info = state->text_info;
+    TextInfo *text_info = &render_priv->text_info;
     GlyphInfo *glyphs = text_info->glyphs;
     int i, j;
     double width = 0;
     int last_break = -1;
-    int halign = state->alignment & 3;
-    int justify = state->justify;
+    int halign = render_priv->state.alignment & 3;
+    int justify = render_priv->state.justify;
     double max_width = 0;
 
-    if (state->evt_type & EVENT_HSCROLL) {
+    if (render_priv->state.evt_type & EVENT_HSCROLL) {
         justify = halign;
         halign = HALIGN_LEFT;
     }
@@ -2398,30 +2222,29 @@ static void align_lines(RenderContext *state, double max_text_width)
     }
 }
 
-static void calculate_rotation_params(RenderContext *state, ASS_DRect *bbox,
+static void calculate_rotation_params(ASS_Renderer *render_priv, ASS_DRect *bbox,
                                       double device_x, double device_y)
 {
-    ASS_Renderer *render_priv = state->renderer;
     ASS_DVector center;
-    if (state->have_origin) {
-        center.x = x2scr_pos(render_priv, state->org_x);
-        center.y = y2scr_pos(render_priv, state->org_y);
+    if (render_priv->state.have_origin) {
+        center.x = x2scr_pos(render_priv, render_priv->state.org_x);
+        center.y = y2scr_pos(render_priv, render_priv->state.org_y);
     } else {
         double bx = 0., by = 0.;
-        get_base_point(bbox, state->alignment, &bx, &by);
+        get_base_point(bbox, render_priv->state.alignment, &bx, &by);
         center.x = device_x + bx;
         center.y = device_y + by;
     }
 
-    TextInfo *text_info = state->text_info;
+    TextInfo *text_info = &render_priv->text_info;
     for (int i = 0; i < text_info->length; i++) {
         GlyphInfo *info = text_info->glyphs + i;
         while (info) {
             info->shift.x = info->pos.x + double_to_d6(device_x - center.x +
-                    info->shadow_x * state->border_scale_x /
-                    render_priv->par_scale_x);
+                    info->shadow_x * render_priv->border_scale /
+                    render_priv->font_scale_x);
             info->shift.y = info->pos.y + double_to_d6(device_y - center.y +
-                    info->shadow_y * state->border_scale_y);
+                    info->shadow_y * render_priv->border_scale);
             info = info->next;
         }
     }
@@ -2477,13 +2300,12 @@ static double restore_blur(int qblur)
 }
 
 // Convert glyphs to bitmaps, combine them, apply blur, generate shadows.
-static void render_and_combine_glyphs(RenderContext *state,
+static void render_and_combine_glyphs(ASS_Renderer *render_priv,
                                       double device_x, double device_y)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    TextInfo *text_info = state->text_info;
+    TextInfo *text_info = &render_priv->text_info;
     int left = render_priv->settings.left_margin;
-    device_x = (device_x - left) * render_priv->par_scale_x + left;
+    device_x = (device_x - left) * render_priv->font_scale_x + left;
     unsigned nb_bitmaps = 0;
     bool new_run = true;
     CombinedBitmapInfo *combined_info = text_info->combined_bitmaps;
@@ -2542,17 +2364,14 @@ static void render_and_combine_glyphs(RenderContext *state,
                 filter->flags = flags;
                 filter->be = info->be;
 
-                int32_t shadow_mask_x, shadow_mask_y;
-                double blur_radius_scale = 2 / sqrt(log(256));
-                double blur_scale_x = state->blur_scale_x * blur_radius_scale;
-                double blur_scale_y = state->blur_scale_y * blur_radius_scale;
-                filter->blur_x = quantize_blur(info->blur * blur_scale_x, &shadow_mask_x);
-                filter->blur_y = quantize_blur(info->blur * blur_scale_y, &shadow_mask_y);
+                int32_t shadow_mask;
+                double blur_scale = render_priv->blur_scale * (2 / sqrt(log(256)));
+                filter->blur = quantize_blur(info->blur * blur_scale, &shadow_mask);
                 if (flags & FILTER_NONZERO_SHADOW) {
-                    int32_t x = double_to_d6(info->shadow_x * state->border_scale_x);
-                    int32_t y = double_to_d6(info->shadow_y * state->border_scale_y);
-                    filter->shadow.x = (x + (shadow_mask_x >> 1)) & ~shadow_mask_x;
-                    filter->shadow.y = (y + (shadow_mask_y >> 1)) & ~shadow_mask_y;
+                    int32_t x = double_to_d6(info->shadow_x * render_priv->border_scale);
+                    int32_t y = double_to_d6(info->shadow_y * render_priv->border_scale);
+                    filter->shadow.x = (x + (shadow_mask >> 1)) & ~shadow_mask;
+                    filter->shadow.y = (y + (shadow_mask >> 1)) & ~shadow_mask;
                 } else
                     filter->shadow.x = filter->shadow.y = 0;
 
@@ -2574,9 +2393,9 @@ static void render_and_combine_glyphs(RenderContext *state,
             assert(current_info);
 
             ASS_Vector pos, pos_o;
-            info->pos.x = double_to_d6(device_x + d6_to_double(info->pos.x) * render_priv->par_scale_x);
+            info->pos.x = double_to_d6(device_x + d6_to_double(info->pos.x) * render_priv->font_scale_x);
             info->pos.y = double_to_d6(device_y) + info->pos.y;
-            get_bitmap_glyph(state, info, &current_info->leftmost_x, &pos, &pos_o,
+            get_bitmap_glyph(render_priv, info, &current_info->leftmost_x, &pos, &pos_o,
                              &offset, !current_info->bitmap_count, flags);
 
             if (!info->bm && !info->bm_o) {
@@ -2614,7 +2433,7 @@ static void render_and_combine_glyphs(RenderContext *state,
 
         if (info->effect_type == EF_KARAOKE_KF)
             info->effect_timing = lround(d6_to_double(info->leftmost_x) +
-                d6_to_double(info->effect_timing) * render_priv->par_scale_x);
+                d6_to_double(info->effect_timing) * render_priv->font_scale_x);
 
         for (int j = 0; j < info->bitmap_count; j++) {
             info->bitmaps[j].pos.x -= info->x;
@@ -2651,34 +2470,6 @@ static inline void rectangle_combine(ASS_Rect *rect, const Bitmap *bm, ASS_Vecto
     rectangle_update(rect, pos.x, pos.y, pos.x + bm->w, pos.y + bm->h);
 }
 
-/*
- * To find these values, simulate blur on the border between two
- * half-planes, one zero-filled (background) and the other filled
- * with the maximum supported value (foreground). Keep incrementing
- * the \be argument. The necessary padding is the distance by which
- * the blurred foreground image extends beyond the original border
- * and into the background. Initially it increases along with \be,
- * but very soon it grinds to a halt. At some point, the blurred
- * image actually reaches a stationary point and stays unchanged
- * forever after, simply _shifting_ by one pixel for each \be
- * step--moving in the direction of the non-zero half-plane and
- * thus decreasing the necessary padding (although the large
- * padding is still needed for intermediate results). In practice,
- * images are finite rather than infinite like half-planes, but
- * this can only decrease the required padding. Half-planes filled
- * with extreme values are the theoretical limit of the worst case.
- * Make sure to use the right pixel value range in the simulation!
- */
-int ass_be_padding(int be)
-{
-    if (be <= 3)
-        return be;
-    if (be <= 7)
-        return 4;
-    return 5;
-}
-
-
 size_t ass_composite_construct(void *key, void *value, void *priv)
 {
     ASS_Renderer *render_priv = priv;
@@ -2706,15 +2497,15 @@ size_t ass_composite_construct(void *key, void *value, void *priv)
         }
     }
 
-    int bord = ass_be_padding(k->filter.be);
+    int bord = be_padding(k->filter.be);
     if (!bord && n_bm == 1) {
-        ass_copy_bitmap(&render_priv->engine, &v->bm, last->bm);
+        copy_bitmap(render_priv->engine, &v->bm, last->bm);
         v->bm.left += last->pos.x;
         v->bm.top  += last->pos.y;
-    } else if (n_bm && ass_alloc_bitmap(&render_priv->engine, &v->bm,
-                                        rect.x_max - rect.x_min + 2 * bord,
-                                        rect.y_max - rect.y_min + 2 * bord,
-                                        true)) {
+    } else if (n_bm && alloc_bitmap(render_priv->engine, &v->bm,
+                                    rect.x_max - rect.x_min + 2 * bord,
+                                    rect.y_max - rect.y_min + 2 * bord,
+                                    true)) {
         Bitmap *dst = &v->bm;
         dst->left = rect.x_min - bord;
         dst->top  = rect.y_min - bord;
@@ -2727,19 +2518,19 @@ size_t ass_composite_construct(void *key, void *value, void *priv)
             assert(x >= 0 && x + src->w <= dst->w);
             assert(y >= 0 && y + src->h <= dst->h);
             unsigned char *buf = dst->buffer + y * dst->stride + x;
-            render_priv->engine.add_bitmaps(buf, dst->stride,
-                                            src->buffer, src->stride,
-                                            src->w, src->h);
+            render_priv->engine->add_bitmaps(buf, dst->stride,
+                                             src->buffer, src->stride,
+                                             src->w, src->h);
         }
     }
     if (!bord && n_bm_o == 1) {
-        ass_copy_bitmap(&render_priv->engine, &v->bm_o, last_o->bm_o);
+        copy_bitmap(render_priv->engine, &v->bm_o, last_o->bm_o);
         v->bm_o.left += last_o->pos_o.x;
         v->bm_o.top  += last_o->pos_o.y;
-    } else if (n_bm_o && ass_alloc_bitmap(&render_priv->engine, &v->bm_o,
-                                          rect_o.x_max - rect_o.x_min + 2 * bord,
-                                          rect_o.y_max - rect_o.y_min + 2 * bord,
-                                          true)) {
+    } else if (n_bm_o && alloc_bitmap(render_priv->engine, &v->bm_o,
+                                      rect_o.x_max - rect_o.x_min + 2 * bord,
+                                      rect_o.y_max - rect_o.y_min + 2 * bord,
+                                      true)) {
         Bitmap *dst = &v->bm_o;
         dst->left = rect_o.x_min - bord;
         dst->top  = rect_o.y_min - bord;
@@ -2752,56 +2543,53 @@ size_t ass_composite_construct(void *key, void *value, void *priv)
             assert(x >= 0 && x + src->w <= dst->w);
             assert(y >= 0 && y + src->h <= dst->h);
             unsigned char *buf = dst->buffer + y * dst->stride + x;
-            render_priv->engine.add_bitmaps(buf, dst->stride,
-                                            src->buffer, src->stride,
-                                            src->w, src->h);
+            render_priv->engine->add_bitmaps(buf, dst->stride,
+                                             src->buffer, src->stride,
+                                             src->w, src->h);
         }
     }
 
     int flags = k->filter.flags;
-    double r2x = restore_blur(k->filter.blur_x);
-    double r2y = restore_blur(k->filter.blur_y);
+    double r2 = restore_blur(k->filter.blur);
     if (!(flags & FILTER_NONZERO_BORDER) || (flags & FILTER_BORDER_STYLE_3))
-        ass_synth_blur(&render_priv->engine, &v->bm, k->filter.be, r2x, r2y);
-    ass_synth_blur(&render_priv->engine, &v->bm_o, k->filter.be, r2x, r2y);
+        ass_synth_blur(render_priv->engine, &v->bm, k->filter.be, r2);
+    ass_synth_blur(render_priv->engine, &v->bm_o, k->filter.be, r2);
 
     if (!(flags & FILTER_FILL_IN_BORDER) && !(flags & FILTER_FILL_IN_SHADOW))
-        ass_fix_outline(&v->bm, &v->bm_o);
+        fix_outline(&v->bm, &v->bm_o);
 
     if (flags & FILTER_NONZERO_SHADOW) {
         if (flags & FILTER_NONZERO_BORDER) {
-            ass_copy_bitmap(&render_priv->engine, &v->bm_s, &v->bm_o);
+            copy_bitmap(render_priv->engine, &v->bm_s, &v->bm_o);
             if ((flags & FILTER_FILL_IN_BORDER) && !(flags & FILTER_FILL_IN_SHADOW))
-                ass_fix_outline(&v->bm, &v->bm_s);
+                fix_outline(&v->bm, &v->bm_s);
         } else if (flags & FILTER_BORDER_STYLE_3) {
             v->bm_s = v->bm_o;
             memset(&v->bm_o, 0, sizeof(v->bm_o));
         } else {
-            ass_copy_bitmap(&render_priv->engine, &v->bm_s, &v->bm);
+            copy_bitmap(render_priv->engine, &v->bm_s, &v->bm);
         }
 
         // Works right even for negative offsets
         // '>>' rounds toward negative infinity, '&' returns correct remainder
         v->bm_s.left += k->filter.shadow.x >> 6;
         v->bm_s.top  += k->filter.shadow.y >> 6;
-        ass_shift_bitmap(&v->bm_s, k->filter.shadow.x & SUBPIXEL_MASK, k->filter.shadow.y & SUBPIXEL_MASK);
+        shift_bitmap(&v->bm_s, k->filter.shadow.x & SUBPIXEL_MASK, k->filter.shadow.y & SUBPIXEL_MASK);
     }
 
     if ((flags & FILTER_FILL_IN_SHADOW) && !(flags & FILTER_FILL_IN_BORDER))
-        ass_fix_outline(&v->bm, &v->bm_o);
+        fix_outline(&v->bm, &v->bm_o);
 
     return sizeof(CompositeHashKey) + sizeof(CompositeHashValue) +
-        k->bitmap_count * sizeof(BitmapRef) +
         bitmap_size(&v->bm) + bitmap_size(&v->bm_o) + bitmap_size(&v->bm_s);
 }
 
-static void add_background(RenderContext *state, EventImages *event_images)
+static void add_background(ASS_Renderer *render_priv, EventImages *event_images)
 {
-    ASS_Renderer *render_priv = state->renderer;
-    int size_x = state->shadow_x > 0 ?
-        lround(state->shadow_x * state->border_scale_x) : 0;
-    int size_y = state->shadow_y > 0 ?
-        lround(state->shadow_y * state->border_scale_y) : 0;
+    int size_x = render_priv->state.shadow_x > 0 ?
+        lround(render_priv->state.shadow_x * render_priv->border_scale) : 0;
+    int size_y = render_priv->state.shadow_y > 0 ?
+        lround(render_priv->state.shadow_y * render_priv->border_scale) : 0;
     int left    = event_images->left - size_x;
     int top     = event_images->top  - size_y;
     int right   = event_images->left + event_images->width  + size_x;
@@ -2819,7 +2607,7 @@ static void add_background(RenderContext *state, EventImages *event_images)
         return;
     memset(nbuffer, 0xFF, w * h);
     ASS_Image *img = my_draw_bitmap(nbuffer, w, h, w, left, top,
-                                    state->c[3], NULL);
+                                    render_priv->state.c[3], NULL);
     if (img) {
         img->next = event_images->imgs;
         event_images->imgs = img;
@@ -2833,10 +2621,9 @@ static void add_background(RenderContext *state, EventImages *event_images)
  * Process event, appending resulting ASS_Image's to images_root.
  */
 static bool
-ass_render_event(RenderContext *state, ASS_Event *event,
+ass_render_event(ASS_Renderer *render_priv, ASS_Event *event,
                  EventImages *event_images)
 {
-    ASS_Renderer *render_priv = state->renderer;
     if (event->Style >= render_priv->track->n_styles) {
         ass_msg(render_priv->library, MSGL_WARN, "No style found");
         return false;
@@ -2846,65 +2633,65 @@ ass_render_event(RenderContext *state, ASS_Event *event,
         return false;
     }
 
-    free_render_context(state);
-    init_render_context(state, event);
+    free_render_context(render_priv);
+    init_render_context(render_priv, event);
 
-    if (!parse_events(state, event))
+    if (!parse_events(render_priv, event))
         return false;
 
-    TextInfo *text_info = state->text_info;
+    TextInfo *text_info = &render_priv->text_info;
     if (text_info->length == 0) {
         // no valid symbols in the event; this can be smth like {comment}
-        free_render_context(state);
+        free_render_context(render_priv);
         return false;
     }
 
-    split_style_runs(state);
+    split_style_runs(render_priv);
 
     // Find shape runs and shape text
-    ass_shaper_set_base_direction(state->shaper,
-            ass_resolve_base_direction(state->font_encoding));
-    ass_shaper_find_runs(state->shaper, render_priv, text_info->glyphs,
+    ass_shaper_set_base_direction(render_priv->shaper,
+            resolve_base_direction(render_priv->state.font_encoding));
+    ass_shaper_find_runs(render_priv->shaper, render_priv, text_info->glyphs,
             text_info->length);
-    if (!ass_shaper_shape(state->shaper, text_info)) {
+    if (!ass_shaper_shape(render_priv->shaper, text_info)) {
         ass_msg(render_priv->library, MSGL_ERR, "Failed to shape text");
-        free_render_context(state);
+        free_render_context(render_priv);
         return false;
     }
 
-    retrieve_glyphs(state);
+    retrieve_glyphs(render_priv);
 
-    preliminary_layout(state);
+    preliminary_layout(render_priv);
 
-    int valign = state->alignment & 12;
+    int valign = render_priv->state.alignment & 12;
 
     int MarginL =
-        (event->MarginL) ? event->MarginL : state->style->MarginL;
+        (event->MarginL) ? event->MarginL : render_priv->state.style->MarginL;
     int MarginR =
-        (event->MarginR) ? event->MarginR : state->style->MarginR;
+        (event->MarginR) ? event->MarginR : render_priv->state.style->MarginR;
     int MarginV =
-        (event->MarginV) ? event->MarginV : state->style->MarginV;
+        (event->MarginV) ? event->MarginV : render_priv->state.style->MarginV;
 
     // calculate max length of a line
     double max_text_width =
-        x2scr_right(state, render_priv->track->PlayResX - MarginR) -
-        x2scr_left(state, MarginL);
+        x2scr_right(render_priv, render_priv->track->PlayResX - MarginR) -
+        x2scr_left(render_priv, MarginL);
 
     // wrap lines
-    wrap_lines_smart(state, max_text_width);
+    wrap_lines_smart(render_priv, max_text_width);
 
     // depends on glyph x coordinates being monotonous within runs, so it should be done before reorder
-    ass_process_karaoke_effects(state);
+    process_karaoke_effects(render_priv);
 
-    reorder_text(state);
+    reorder_text(render_priv);
 
-    align_lines(state, max_text_width);
+    align_lines(render_priv, max_text_width);
 
     // determing text bounding box
     ASS_DRect bbox;
     compute_string_bbox(text_info, &bbox);
 
-    apply_baseline_shear(state);
+    apply_baseline_shear(render_priv);
 
     // determine device coordinates for text
     double device_x = 0;
@@ -2912,65 +2699,65 @@ ass_render_event(RenderContext *state, ASS_Event *event,
 
     // handle positioned events first: an event can be both positioned and
     // scrolling, and the scrolling effect overrides the position on one axis
-    if (state->evt_type & EVENT_POSITIONED) {
+    if (render_priv->state.evt_type & EVENT_POSITIONED) {
         double base_x = 0;
         double base_y = 0;
-        get_base_point(&bbox, state->alignment, &base_x, &base_y);
+        get_base_point(&bbox, render_priv->state.alignment, &base_x, &base_y);
         device_x =
-            x2scr_pos(render_priv, state->pos_x) - base_x;
+            x2scr_pos(render_priv, render_priv->state.pos_x) - base_x;
         device_y =
-            y2scr_pos(render_priv, state->pos_y) - base_y;
+            y2scr_pos(render_priv, render_priv->state.pos_y) - base_y;
     }
 
     // x coordinate
-    if (state->evt_type & EVENT_HSCROLL) {
-        if (state->scroll_direction == SCROLL_RL)
+    if (render_priv->state.evt_type & EVENT_HSCROLL) {
+        if (render_priv->state.scroll_direction == SCROLL_RL)
             device_x =
                 x2scr_pos(render_priv,
                       render_priv->track->PlayResX -
-                      state->scroll_shift);
-        else if (state->scroll_direction == SCROLL_LR)
+                      render_priv->state.scroll_shift);
+        else if (render_priv->state.scroll_direction == SCROLL_LR)
             device_x =
-                x2scr_pos(render_priv, state->scroll_shift) -
+                x2scr_pos(render_priv, render_priv->state.scroll_shift) -
                 (bbox.x_max - bbox.x_min);
-    } else if (!(state->evt_type & EVENT_POSITIONED)) {
-        device_x = x2scr_left(state, MarginL);
+    } else if (!(render_priv->state.evt_type & EVENT_POSITIONED)) {
+        device_x = x2scr_left(render_priv, MarginL);
     }
 
     // y coordinate
-    if (state->evt_type & EVENT_VSCROLL) {
-        if (state->scroll_direction == SCROLL_TB)
+    if (render_priv->state.evt_type & EVENT_VSCROLL) {
+        if (render_priv->state.scroll_direction == SCROLL_TB)
             device_y =
-                y2scr(state,
-                      state->scroll_y0 +
-                      state->scroll_shift) -
+                y2scr(render_priv,
+                      render_priv->state.scroll_y0 +
+                      render_priv->state.scroll_shift) -
                 bbox.y_max;
-        else if (state->scroll_direction == SCROLL_BT)
+        else if (render_priv->state.scroll_direction == SCROLL_BT)
             device_y =
-                y2scr(state,
-                      state->scroll_y1 -
-                      state->scroll_shift) -
+                y2scr(render_priv,
+                      render_priv->state.scroll_y1 -
+                      render_priv->state.scroll_shift) -
                 bbox.y_min;
-    } else if (!(state->evt_type & EVENT_POSITIONED)) {
+    } else if (!(render_priv->state.evt_type & EVENT_POSITIONED)) {
         if (valign == VALIGN_TOP) {     // toptitle
             device_y =
-                y2scr_top(state,
+                y2scr_top(render_priv,
                           MarginV) + text_info->lines[0].asc;
         } else if (valign == VALIGN_CENTER) {   // midtitle
             double scr_y =
-                y2scr(state, render_priv->track->PlayResY / 2.0);
+                y2scr(render_priv, render_priv->track->PlayResY / 2.0);
             device_y = scr_y - (bbox.y_max + bbox.y_min) / 2.0;
         } else {                // subtitle
-            double line_pos = state->explicit ?
+            double line_pos = render_priv->state.explicit ?
                 0 : render_priv->settings.line_position;
             double scr_top, scr_bottom, scr_y0;
             if (valign != VALIGN_SUB)
                 ass_msg(render_priv->library, MSGL_V,
                        "Invalid valign, assuming 0 (subtitle)");
             scr_bottom =
-                y2scr_sub(state,
+                y2scr_sub(render_priv,
                           render_priv->track->PlayResY - MarginV);
-            scr_top = y2scr_top(state, 0); //xxx not always 0?
+            scr_top = y2scr_top(render_priv, 0); //xxx not always 0?
             device_y = scr_bottom + (scr_top - scr_bottom) * line_pos / 100.0;
             device_y -= text_info->height;
             device_y += text_info->lines[0].asc;
@@ -2985,47 +2772,47 @@ ass_render_event(RenderContext *state, ASS_Event *event,
     }
 
     // fix clip coordinates
-    if (state->explicit || !render_priv->settings.use_margins) {
-        state->clip_x0 =
-            lround(x2scr_pos_scaled(render_priv, state->clip_x0));
-        state->clip_x1 =
-            lround(x2scr_pos_scaled(render_priv, state->clip_x1));
-        state->clip_y0 =
-            lround(y2scr_pos(render_priv, state->clip_y0));
-        state->clip_y1 =
-            lround(y2scr_pos(render_priv, state->clip_y1));
-
-        if (state->explicit) {
+    if (render_priv->state.explicit || !render_priv->settings.use_margins) {
+        render_priv->state.clip_x0 =
+            x2scr_pos_scaled(render_priv, render_priv->state.clip_x0);
+        render_priv->state.clip_x1 =
+            x2scr_pos_scaled(render_priv, render_priv->state.clip_x1);
+        render_priv->state.clip_y0 =
+            y2scr_pos(render_priv, render_priv->state.clip_y0);
+        render_priv->state.clip_y1 =
+            y2scr_pos(render_priv, render_priv->state.clip_y1);
+
+        if (render_priv->state.explicit) {
             // we still need to clip against screen boundaries
-            int zx = render_priv->settings.left_margin;
-            int zy = render_priv->settings.top_margin;
-            int sx = zx + render_priv->frame_content_width;
-            int sy = zy + render_priv->frame_content_height;
-
-            state->clip_x0 = FFMAX(state->clip_x0, zx);
-            state->clip_y0 = FFMAX(state->clip_y0, zy);
-            state->clip_x1 = FFMIN(state->clip_x1, sx);
-            state->clip_y1 = FFMIN(state->clip_y1, sy);
+            double zx = x2scr_pos_scaled(render_priv, 0);
+            double zy = y2scr_pos(render_priv, 0);
+            double sx = x2scr_pos_scaled(render_priv, render_priv->track->PlayResX);
+            double sy = y2scr_pos(render_priv, render_priv->track->PlayResY);
+
+            render_priv->state.clip_x0 = FFMAX(render_priv->state.clip_x0, zx);
+            render_priv->state.clip_y0 = FFMAX(render_priv->state.clip_y0, zy);
+            render_priv->state.clip_x1 = FFMIN(render_priv->state.clip_x1, sx);
+            render_priv->state.clip_y1 = FFMIN(render_priv->state.clip_y1, sy);
         }
     } else {
         // no \clip (explicit==0) and use_margins => only clip to screen with margins
-        state->clip_x0 = 0;
-        state->clip_y0 = 0;
-        state->clip_x1 = render_priv->settings.frame_width;
-        state->clip_y1 = render_priv->settings.frame_height;
+        render_priv->state.clip_x0 = 0;
+        render_priv->state.clip_y0 = 0;
+        render_priv->state.clip_x1 = render_priv->settings.frame_width;
+        render_priv->state.clip_y1 = render_priv->settings.frame_height;
     }
 
-    if (state->evt_type & EVENT_VSCROLL) {
-        int y0 = lround(y2scr_pos(render_priv, state->scroll_y0));
-        int y1 = lround(y2scr_pos(render_priv, state->scroll_y1));
+    if (render_priv->state.evt_type & EVENT_VSCROLL) {
+        double y0 = y2scr_pos(render_priv, render_priv->state.scroll_y0);
+        double y1 = y2scr_pos(render_priv, render_priv->state.scroll_y1);
 
-        state->clip_y0 = FFMAX(state->clip_y0, y0);
-        state->clip_y1 = FFMIN(state->clip_y1, y1);
+        render_priv->state.clip_y0 = FFMAX(render_priv->state.clip_y0, y0);
+        render_priv->state.clip_y1 = FFMIN(render_priv->state.clip_y1, y1);
     }
 
-    calculate_rotation_params(state, &bbox, device_x, device_y);
+    calculate_rotation_params(render_priv, &bbox, device_x, device_y);
 
-    render_and_combine_glyphs(state, device_x, device_y);
+    render_and_combine_glyphs(render_priv, device_x, device_y);
 
     memset(event_images, 0, sizeof(*event_images));
     // VSFilter does *not* shift lines with a border > margin to be within the
@@ -3034,20 +2821,20 @@ ass_render_event(RenderContext *state, ASS_Event *event,
     event_images->height =
         text_info->height + text_info->border_bottom + text_info->border_top;
     event_images->left =
-        (device_x + bbox.x_min) * render_priv->par_scale_x - text_info->border_x + 0.5;
+        (device_x + bbox.x_min) * render_priv->font_scale_x - text_info->border_x + 0.5;
     event_images->width =
-        (bbox.x_max - bbox.x_min) * render_priv->par_scale_x
+        (bbox.x_max - bbox.x_min) * render_priv->font_scale_x
         + 2 * text_info->border_x + 0.5;
-    event_images->detect_collisions = state->detect_collisions;
+    event_images->detect_collisions = render_priv->state.detect_collisions;
     event_images->shift_direction = (valign == VALIGN_SUB) ? -1 : 1;
     event_images->event = event;
-    event_images->imgs = render_text(state);
+    event_images->imgs = render_text(render_priv);
 
-    if (state->border_style == 4)
-        add_background(state, event_images);
+    if (render_priv->state.border_style == 4)
+        add_background(render_priv, event_images);
 
-    ass_shaper_cleanup(state->shaper, text_info);
-    free_render_context(state);
+    ass_shaper_cleanup(render_priv->shaper, text_info);
+    free_render_context(render_priv);
 
     return true;
 }
@@ -3062,21 +2849,6 @@ static void check_cache_limits(ASS_Renderer *priv, CacheStore *cache)
     ass_cache_cut(cache->outline_cache, cache->glyph_max);
 }
 
-static void setup_shaper(ASS_Shaper *shaper, ASS_Renderer *render_priv)
-{
-    ASS_Track *track = render_priv->track;
-
-    ass_shaper_set_kerning(shaper, track->Kerning);
-    ass_shaper_set_language(shaper, track->Language);
-    ass_shaper_set_level(shaper, render_priv->settings.shaper);
-#ifdef USE_FRIBIDI_EX_API
-    ass_shaper_set_bidi_brackets(shaper,
-            track->parser_priv->feature_flags & FEATURE_MASK(ASS_FEATURE_BIDI_BRACKETS));
-#endif
-    ass_shaper_set_whole_text_layout(shaper,
-            track->parser_priv->feature_flags & FEATURE_MASK(ASS_FEATURE_WHOLE_TEXT_LAYOUT));
-}
-
 /**
  * \brief Start a new frame
  */
@@ -3084,6 +2856,8 @@ static bool
 ass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,
                 long long now)
 {
+    ASS_Settings *settings_priv = &render_priv->settings;
+
     if (!render_priv->settings.frame_width
         && !render_priv->settings.frame_height)
         return false;               // library not initialized
@@ -3108,23 +2882,30 @@ ass_start_frame(ASS_Renderer *render_priv, ASS_Track *track,
             render_priv->fontselect, render_priv->num_emfonts);
     }
 
-    setup_shaper(render_priv->state.shaper, render_priv);
+    ass_shaper_set_kerning(render_priv->shaper, track->Kerning);
+    ass_shaper_set_language(render_priv->shaper, track->Language);
+    ass_shaper_set_level(render_priv->shaper, render_priv->settings.shaper);
+#ifdef USE_FRIBIDI_EX_API
+    ass_shaper_set_bidi_brackets(render_priv->shaper,
+            track->parser_priv->feature_flags & FEATURE_MASK(ASS_FEATURE_BIDI_BRACKETS));
+#endif
+    ass_shaper_set_whole_text_layout(render_priv->shaper,
+            track->parser_priv->feature_flags & FEATURE_MASK(ASS_FEATURE_WHOLE_TEXT_LAYOUT));
 
     // PAR correction
     double par = render_priv->settings.par;
-    bool lr_track = track->LayoutResX > 0 && track->LayoutResY > 0;
-    if (par == 0. || lr_track) {
-        if (render_priv->frame_content_width && render_priv->frame_content_height && (lr_track ||
-                (render_priv->settings.storage_width && render_priv->settings.storage_height))) {
-            double dar = ((double) render_priv->frame_content_width) /
-                         render_priv->frame_content_height;
-            ASS_Vector layout_res = ass_layout_res(render_priv);
-            double sar = ((double) layout_res.x) / layout_res.y;
+    if (par == 0.) {
+        if (render_priv->orig_width && render_priv->orig_height &&
+            settings_priv->storage_width && settings_priv->storage_height) {
+            double dar = ((double) render_priv->orig_width) /
+                         render_priv->orig_height;
+            double sar = ((double) settings_priv->storage_width) /
+                         settings_priv->storage_height;
             par = dar / sar;
         } else
             par = 1.0;
     }
-    render_priv->par_scale_x = par;
+    render_priv->font_scale_x = par;
 
     render_priv->prev_images_root = render_priv->images_root;
     render_priv->images_root = NULL;
@@ -3407,7 +3188,7 @@ ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
                     realloc(priv->eimg,
                             priv->eimg_size * sizeof(EventImages));
             }
-            if (ass_render_event(&priv->state, event, priv->eimg + cnt))
+            if (ass_render_event(priv, event, priv->eimg + cnt))
                 cnt++;
         }
     }
diff --git a/libass/ass_render.h b/libass/ass_render.h
index 3c717b8..116722b 100644
--- a/libass/ass_render.h
+++ b/libass/ass_render.h
@@ -22,7 +22,6 @@
 
 #include <inttypes.h>
 #include <stdbool.h>
-#include <fribidi.h>
 #include <ft2build.h>
 #include FT_FREETYPE_H
 #include FT_GLYPH_H
@@ -104,7 +103,7 @@ typedef struct {
     // during render_and_combine_glyphs: distance in subpixels from the karaoke origin.
     // after render_and_combine_glyphs: screen coordinate in pixels.
     // part of the glyph to the left of it is displayed in a different color.
-    int32_t effect_timing;
+    int effect_timing;
 
     // karaoke origin: screen coordinate of leftmost post-transform control point x in subpixels
     int32_t leftmost_x;
@@ -147,11 +146,10 @@ typedef struct glyph_info {
     ASS_Vector advance;         // 26.6
     ASS_Vector cluster_advance;
     Effect effect_type;
-    int32_t effect_timing;          // time duration of current karaoke word
-    // after ass_process_karaoke_effects: distance in subpixels from the karaoke origin.
+    int effect_timing;          // time duration of current karaoke word
+    // after process_karaoke_effects: distance in subpixels from the karaoke origin.
     // part of the glyph to the left of it is displayed in a different color.
-    int32_t effect_skip_timing;     // delay after the end of last karaoke word
-    bool reset_effect;
+    int effect_skip_timing;     // delay after the end of last karaoke word
     int asc, desc;              // font max ascender and descender
     int be;                     // blur edges
     double blur;                // gaussian blur
@@ -188,8 +186,6 @@ typedef struct {
 
 typedef struct {
     GlyphInfo *glyphs;
-    FriBidiChar *event_text;
-    char *breaks;
     int length;
     LineInfo *lines;
     int n_lines;
@@ -204,16 +200,9 @@ typedef struct {
     unsigned max_bitmaps;
 } TextInfo;
 
-#include "ass_shaper.h"
-
 // Renderer state.
 // Values like current font face, color, screen position, clipping and so on are stored here.
-struct render_context {
-    ASS_Renderer *renderer;
-    TextInfo *text_info;
-    ASS_Shaper *shaper;
-    RasterizerData rasterizer;
-
+typedef struct {
     ASS_Event *event;
     ASS_Style *style;
 
@@ -260,9 +249,8 @@ struct render_context {
     int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
 
     Effect effect_type;
-    int32_t effect_timing;
-    int32_t effect_skip_timing;
-    bool reset_effect;
+    int effect_timing;
+    int effect_skip_timing;
 
     enum {
         SCROLL_LR,              // left-to-right
@@ -270,7 +258,7 @@ struct render_context {
         SCROLL_TB,              // top-to-bottom
         SCROLL_BT
     } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
-    double scroll_shift;
+    int scroll_shift;
     int scroll_y0, scroll_y1;
 
     // face properties
@@ -287,28 +275,20 @@ struct render_context {
     int apply_font_scale;
     // whether this is assumed to be explicitly positioned
     int explicit;
-
-    double screen_scale_x;
-    double screen_scale_y;
-    double border_scale_x;
-    double border_scale_y;
-    double blur_scale_x;
-    double blur_scale_y;
-};
-
-typedef struct render_context RenderContext;
+} RenderContext;
 
 typedef struct {
     Cache *font_cache;
     Cache *outline_cache;
     Cache *bitmap_cache;
     Cache *composite_cache;
-    Cache *metrics_cache;
     size_t glyph_max;
     size_t bitmap_max_size;
     size_t composite_max_size;
 } CacheStore;
 
+#include "ass_shaper.h"
+
 struct ass_renderer {
     ASS_Library *library;
     FT_Library ftlibrary;
@@ -316,6 +296,7 @@ struct ass_renderer {
     size_t num_emfonts;
     ASS_Settings settings;
     int render_id;
+    ASS_Shaper *shaper;
 
     ASS_Image *images_root;     // rendering result is stored here
     ASS_Image *prev_images_root;
@@ -324,20 +305,24 @@ struct ass_renderer {
     int eimg_size;              // allocated buffer size
 
     // frame-global data
-    int width, height;          // screen dimensions (the whole frame from ass_set_frame_size)
-    int frame_content_height;   // content frame height ( = screen height - API margins )
-    int frame_content_width;    // content frame width ( = screen width - API margins )
-    double fit_height;          // content frame height without zoom & pan (fit to screen & letterboxed)
-    double fit_width;           // content frame width without zoom & pan (fit to screen & letterboxed)
+    int width, height;          // screen dimensions
+    int orig_height;            // frame height ( = screen height - margins )
+    int orig_width;             // frame width ( = screen width - margins )
+    double fit_height;          // frame height without zoom & pan (fit to screen & letterboxed)
+    double fit_width;           // frame width without zoom & pan (fit to screen & letterboxed)
     ASS_Track *track;
     long long time;             // frame's timestamp, ms
-    double par_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
+    double font_scale;
+    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
+    double border_scale;
+    double blur_scale;
 
     RenderContext state;
     TextInfo text_info;
     CacheStore cache;
 
-    BitmapEngine engine;
+    const BitmapEngine *engine;
+    RasterizerData rasterizer;
 
     ASS_Style user_override_style;
 };
@@ -354,10 +339,9 @@ typedef struct {
     int y1;
 } Rect;
 
-void ass_reset_render_context(RenderContext *state, ASS_Style *style);
+void reset_render_context(ASS_Renderer *render_priv, ASS_Style *style);
 void ass_frame_ref(ASS_Image *img);
 void ass_frame_unref(ASS_Image *img);
-ASS_Vector ass_layout_res(ASS_Renderer *render_priv);
 
 // XXX: this is actually in ass.c, includes should be fixed later on
 void ass_lazy_track_init(ASS_Library *lib, ASS_Track *track);
diff --git a/libass/ass_render_api.c b/libass/ass_render_api.c
index d3657d3..70cf174 100644
--- a/libass/ass_render_api.c
+++ b/libass/ass_render_api.c
@@ -33,26 +33,24 @@ static void ass_reconfigure(ASS_Renderer *priv)
 
     priv->width = settings->frame_width;
     priv->height = settings->frame_height;
-    priv->frame_content_width = settings->frame_width - settings->left_margin -
+    priv->orig_width = settings->frame_width - settings->left_margin -
         settings->right_margin;
-    priv->frame_content_height = settings->frame_height - settings->top_margin -
+    priv->orig_height = settings->frame_height - settings->top_margin -
         settings->bottom_margin;
     priv->fit_width =
-        (long long) priv->frame_content_width * priv->height >=
-        (long long) priv->frame_content_height * priv->width ?
+        (long long) priv->orig_width * priv->height >=
+        (long long) priv->orig_height * priv->width ?
             priv->width :
-            (double) priv->frame_content_width * priv->height / priv->frame_content_height;
+            (double) priv->orig_width * priv->height / priv->orig_height;
     priv->fit_height =
-        (long long) priv->frame_content_width * priv->height <=
-        (long long) priv->frame_content_height * priv->width ?
+        (long long) priv->orig_width * priv->height <=
+        (long long) priv->orig_height * priv->width ?
             priv->height :
-            (double) priv->frame_content_height * priv->width / priv->frame_content_width;
+            (double) priv->orig_height * priv->width / priv->orig_width;
 }
 
 void ass_set_frame_size(ASS_Renderer *priv, int w, int h)
 {
-    if (w < 0 || h < 0)
-        w = h = 0;
     if (priv->settings.frame_width != w || priv->settings.frame_height != h) {
         priv->settings.frame_width = w;
         priv->settings.frame_height = h;
@@ -62,8 +60,6 @@ void ass_set_frame_size(ASS_Renderer *priv, int w, int h)
 
 void ass_set_storage_size(ASS_Renderer *priv, int w, int h)
 {
-    if (w < 0 || h < 0)
-        w = h = 0;
     if (priv->settings.storage_width != w ||
         priv->settings.storage_height != h) {
         priv->settings.storage_width = w;
@@ -105,7 +101,6 @@ void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar)
 
 void ass_set_pixel_aspect(ASS_Renderer *priv, double par)
 {
-    if (par < 0) par = 0;
     if (priv->settings.par != par) {
         priv->settings.par = par;
         ass_reconfigure(priv);
@@ -154,7 +149,8 @@ void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
     ass_reconfigure(priv);
 
     ass_cache_empty(priv->cache.font_cache);
-    ass_cache_empty(priv->cache.metrics_cache);
+    if (priv->shaper)
+        ass_shaper_empty_cache(priv->shaper);
 
     if (priv->fontselect)
         ass_fontselect_free(priv->fontselect);
@@ -176,7 +172,6 @@ void ass_set_selective_style_override(ASS_Renderer *priv, ASS_Style *style)
     free(user_style->FontName);
     *user_style = *style;
     user_style->FontName = strdup(user_style->FontName);
-    ass_reconfigure(priv);
 }
 
 int ass_fonts_update(ASS_Renderer *render_priv)
diff --git a/libass/ass_shaper.c b/libass/ass_shaper.c
index 1d83757..6cb2ebf 100644
--- a/libass/ass_shaper.c
+++ b/libass/ass_shaper.c
@@ -49,8 +49,8 @@ struct ass_shaper {
     ASS_ShapingLevel shaping_level;
 
     // FriBidi log2vis
-    int n_codepoints, n_pars;
-    FriBidiChar *event_text; // just a reference, owned by text_info
+    int n_glyphs, n_pars;
+    FriBidiChar *event_text;
     FriBidiCharType *ctypes;
     FriBidiLevel *emblevels;
     FriBidiStrIndex *cmap;
@@ -97,30 +97,22 @@ void ass_shaper_info(ASS_Library *lib)
 }
 
 /**
- * \brief grow per-codepoint arrays, if needed
+ * \brief grow arrays, if needed
  * \param new_size requested size
  */
-static bool check_codepoint_allocations(ASS_Shaper *shaper, size_t new_size)
+static bool check_allocations(ASS_Shaper *shaper, size_t new_size, size_t n_pars)
 {
-    if (new_size > shaper->n_codepoints) {
-        if (!ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||
+    if (new_size > shaper->n_glyphs) {
+        if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) ||
+            !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) ||
 #ifdef USE_FRIBIDI_EX_API
             (shaper->bidi_brackets && !ASS_REALLOC_ARRAY(shaper->btypes, new_size)) ||
 #endif
             !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) ||
             !ASS_REALLOC_ARRAY(shaper->cmap, new_size))
             return false;
-        shaper->n_codepoints = new_size;
+        shaper->n_glyphs = new_size;
     }
-    return true;
-}
-
-/**
- * \brief grow per-bidi-paragraph arrays, if needed
- * \param n_pars requested size
- */
-static bool check_par_allocations(ASS_Shaper *shaper, size_t n_pars)
-{
     if (shaper->whole_text_layout && n_pars > shaper->n_pars) {
         if (!ASS_REALLOC_ARRAY(shaper->pbase_dir, n_pars))
             return false;
@@ -134,7 +126,9 @@ static bool check_par_allocations(ASS_Shaper *shaper, size_t n_pars)
  */
 void ass_shaper_free(ASS_Shaper *shaper)
 {
+    ass_cache_done(shaper->metrics_cache);
     free(shaper->features);
+    free(shaper->event_text);
     free(shaper->ctypes);
 #ifdef USE_FRIBIDI_EX_API
     free(shaper->btypes);
@@ -145,6 +139,11 @@ void ass_shaper_free(ASS_Shaper *shaper)
     free(shaper);
 }
 
+void ass_shaper_empty_cache(ASS_Shaper *shaper)
+{
+    ass_cache_empty(shaper->metrics_cache);
+}
+
 void ass_shaper_font_data_free(ASS_ShaperFontData *priv)
 {
     int i;
@@ -224,7 +223,7 @@ static void update_hb_size(hb_font_t *hb_font, FT_Face face)
  *
  */
 
-static FT_Glyph_Metrics *
+FT_Glyph_Metrics *
 get_cached_metrics(struct ass_shaper_metrics_data *metrics,
                    hb_codepoint_t unicode, hb_codepoint_t glyph)
 {
@@ -975,9 +974,13 @@ bool ass_shaper_shape(ASS_Shaper *shaper, TextInfo *text_info)
     int i, ret, last_break;
     FriBidiParType dir, *pdir;
     GlyphInfo *glyphs = text_info->glyphs;
-    shaper->event_text = text_info->event_text;
 
-    if (!check_codepoint_allocations(shaper, text_info->length))
+    int n_pars = 1;
+    for (i = 0; i < text_info->length - 1; i++)
+        if (glyphs[i].symbol == '\n')
+            n_pars++;
+
+    if (!check_allocations(shaper, text_info->length, n_pars))
         return false;
 
     for (i = 0; i < text_info->length; i++)
@@ -986,14 +989,6 @@ bool ass_shaper_shape(ASS_Shaper *shaper, TextInfo *text_info)
     fribidi_get_bidi_types(shaper->event_text,
             text_info->length, shaper->ctypes);
 
-    int n_pars = 1;
-    for (i = 0; i < text_info->length - 1; i++)
-        if (shaper->ctypes[i] == FRIBIDI_TYPE_BS)
-            n_pars++;
-
-    if (!check_par_allocations(shaper, n_pars))
-        return false;
-
 #ifdef USE_FRIBIDI_EX_API
     if (shaper->bidi_brackets) {
         fribidi_get_bracket_types(shaper->event_text,
@@ -1005,9 +1000,8 @@ bool ass_shaper_shape(ASS_Shaper *shaper, TextInfo *text_info)
     last_break = 0;
     pdir = shaper->pbase_dir;
     for (i = 0; i < text_info->length; i++) {
-        // Embedding levels must be calculated one bidi "paragraph" at a time
-        if (i == text_info->length - 1 ||
-                shaper->ctypes[i] == FRIBIDI_TYPE_BS ||
+        // embedding levels should be calculated paragraph by paragraph
+        if (glyphs[i].symbol == '\n' || i == text_info->length - 1 ||
                 (!shaper->whole_text_layout &&
                     (glyphs[i + 1].starts_new_run || glyphs[i].hspacing))) {
             dir = shaper->base_direction;
@@ -1043,10 +1037,8 @@ bool ass_shaper_shape(ASS_Shaper *shaper, TextInfo *text_info)
 /**
  * \brief Create a new shaper instance
  */
-ASS_Shaper *ass_shaper_new(Cache *metrics_cache)
+ASS_Shaper *ass_shaper_new(void)
 {
-    assert(metrics_cache);
-
     ASS_Shaper *shaper = calloc(sizeof(*shaper), 1);
     if (!shaper)
         return NULL;
@@ -1055,7 +1047,9 @@ ASS_Shaper *ass_shaper_new(Cache *metrics_cache)
 
     if (!init_features(shaper))
         goto error;
-    shaper->metrics_cache = metrics_cache;
+    shaper->metrics_cache = ass_glyph_metrics_cache_create();
+    if (!shaper->metrics_cache)
+        goto error;
 
     return shaper;
 
@@ -1104,11 +1098,7 @@ FriBidiStrIndex *ass_shaper_reorder(ASS_Shaper *shaper, TextInfo *text_info)
         shaper->pbase_dir : &shaper->base_direction;
     GlyphInfo *glyphs = text_info->glyphs;
     for (i = 0; i < text_info->length; i++) {
-        // Bidi "paragraph separators" may occur between line breaks:
-        // U+001C..1E even with ASS_FEATURE_WRAP_UNICODE,
-        // or U+000D, U+0085, U+2029 only without it
         if (i == text_info->length - 1 || glyphs[i + 1].linebreak ||
-                shaper->ctypes[i] == FRIBIDI_TYPE_BS ||
                 (!shaper->whole_text_layout &&
                     (glyphs[i + 1].starts_new_run || glyphs[i].hspacing))) {
             ret = fribidi_reorder_line(0,
@@ -1119,7 +1109,7 @@ FriBidiStrIndex *ass_shaper_reorder(ASS_Shaper *shaper, TextInfo *text_info)
                 return NULL;
 
             last_break = i + 1;
-            if (shaper->whole_text_layout && shaper->ctypes[i] == FRIBIDI_TYPE_BS)
+            if (shaper->whole_text_layout)
                 pdir++;
         }
     }
@@ -1139,7 +1129,7 @@ FriBidiStrIndex *ass_shaper_get_reorder_map(ASS_Shaper *shaper)
  * can be used for autodetection.
  * \param enc Windows font encoding
  */
-FriBidiParType ass_resolve_base_direction(int enc)
+FriBidiParType resolve_base_direction(int enc)
 {
     switch (enc) {
         case -1:
diff --git a/libass/ass_shaper.h b/libass/ass_shaper.h
index 819a3fd..66bfed0 100644
--- a/libass/ass_shaper.h
+++ b/libass/ass_shaper.h
@@ -24,15 +24,15 @@ typedef struct ass_shaper ASS_Shaper;
 #include <fribidi.h>
 #include <stdbool.h>
 #include "ass_render.h"
-#include "ass_cache.h"
 
 #if FRIBIDI_MAJOR_VERSION >= 1
 #define USE_FRIBIDI_EX_API
 #endif
 
 void ass_shaper_info(ASS_Library *lib);
-ASS_Shaper *ass_shaper_new(Cache *metrics_cache);
+ASS_Shaper *ass_shaper_new(void);
 void ass_shaper_free(ASS_Shaper *shaper);
+void ass_shaper_empty_cache(ASS_Shaper *shaper);
 void ass_shaper_set_kerning(ASS_Shaper *shaper, bool kern);
 void ass_shaper_find_runs(ASS_Shaper *shaper, ASS_Renderer *render_priv,
                           GlyphInfo *glyphs, size_t len);
@@ -47,7 +47,7 @@ bool ass_shaper_shape(ASS_Shaper *shaper, TextInfo *text_info);
 void ass_shaper_cleanup(ASS_Shaper *shaper, TextInfo *text_info);
 FriBidiStrIndex *ass_shaper_reorder(ASS_Shaper *shaper, TextInfo *text_info);
 FriBidiStrIndex *ass_shaper_get_reorder_map(ASS_Shaper *shaper);
-FriBidiParType ass_resolve_base_direction(int font_encoding);
+FriBidiParType resolve_base_direction(int font_encoding);
 
 void ass_shaper_font_data_free(ASS_ShaperFontData *priv);
 
diff --git a/libass/ass_types.h b/libass/ass_types.h
index e4cc222..9148e7f 100644
--- a/libass/ass_types.h
+++ b/libass/ass_types.h
@@ -150,85 +150,56 @@ typedef struct ass_event {
 } ASS_Event;
 
 /**
- * Support for (xy-)VSFilter mangled colors
+ * Support for (xy-)vsfilter mangled colors
  *
- * Generally, xy-VSFilter emulates the classic VSFilter behavior of
- * rendering directly into the (usually YCbCr) video. Classic
- * guliverkli(2)-VSFilter is hardcoded to use BT.601(TV) as target colorspace
- * when converting the subtitle RGB color to the video colorspace.
- * This led to odd results when other colorspaces were used, particular
- * once those became more common with the rise of HDTV video:
- * HDTV typically uses BT.709(TV), but VSFilter continued assuming
- * BT.601(TV) for conversion.
+ * Generally, xy-vsfilter emulates the classic vsfilter behavior of
+ * rendering directly into the (usually YCbCr) video. vsfilter is
+ * hardcoded to use BT.601(TV) as target colorspace when converting
+ * the subtitle RGB color to the video colorspace. This led to major
+ * breakage when HDTV video was introduced: HDTV typically uses
+ * BT.709(TV), but vsfilter still used BT.601(TV) for conversion.
  *
  * This means classic vsfilter will mangle colors as follows:
  *
+ *    screen_rgb = bt_709tv_to_rgb(rgb_to_bt601tv(ass_rgb))
+ *
+ * Or in general:
+ *
  *    screen_rgb = video_csp_to_rgb(rgb_to_bt601tv(ass_rgb))
  *
  * where video_csp is the colorspace of the video with which the
  * subtitle was muxed.
  *
- * Subtitle authors worked around this issue by adjusting the color
- * to look as intended *after* going through the mangling process. Still,
- * this behaviour isn't great and also limits the color range. Yet,
- * for backwards compatibility with existing files, the classic mangling
- * must be preserved for existing files to not break the display of
- * color-matched typesets created with older VSFilter versions. Thus,
- * on iniative of xy-VSFilter/XYSubFilter a new explicit "YCbCr Matrix"
- * header was introduced to allow new files to avoid this color mangling.
- * However due to a limitation of VSFilter API, VSFilters don't actually
- * know the real colorspace of the video they're rendering to, so the
- * header wasn't created as a simple "Use ColourMangling: yes/no", but instead
- * specifies exactly which colorspace to use for the initial conversion
- * from the subtitle's RGB values to the video's YCbCr. So we now got
+ * xy-vsfilter did not fix this, but instead introduced explicit
+ * rules how colors were mangled by adding a "YCbCr Matrix" header.
+ * If this header specifies a real colorspace (like BT.601(TV) etc.),
+ * xy-vsfilter behaves exactly like vsfilter, but using the specified
+ * colorspace for conversion of ASS input RGB to screen RGB:
  *
  *    screen_rgb = video_csp_to_rgb(rgb_to_ycbcr_header_csp(ass_rgb))
  *
- * with rgb_to_ycbcr_header_csp defaulting to TV-range BT.601.
- *
- * XySubFilter, whose API was planned during introduction of this header,
- * is not affected by this VSFilter-API limitation, so for it and other
- * renderers like libass an additional special value "None" was also added.
- * "None" tells the renderer to directly use untouched RGB values without
- * any conversion.
+ * Further, xy-vsfilter behaves like vsfilter with no changes if the header
+ * is missing.
  *
- * If the video itself is already in RGB natively, then no color mangling
- * happens regardless of the presence or value of a "YCbCr Matrix" header.
+ * The special value "None" means untouched RGB values. Keep in mind that
+ * some version of xy-vsfilter are buggy and don't interpret this correctly.
+ * It appears some people are advocating that this header value is
+ * intended for situations where exact colors do not matter.
  *
- * The above mangling process with special value "None" to opt out
- * of any color mangling is the recommended default behaviour.
- *
- * Keep in mind though, that xy-VSFilter cannot accurately implement this and
- * will instead resort to a guessing the video colorspace based on resolution
- * and then convert RGB to the guessed space.
- * Also some versions of MPC-HC's Internal Subtitle Renderer don't implement
- * "None" and use TV.601 for unknown, but the video colorspace for no or an
- * empty header (which can break old subtitles).
- *
- * Aegisub's (the main application to produce ASS subtitle scripts) behaviour
- * regarding colorspaces is unfortunately a bit confusing.
- * As of time of writing there still is a config option to force BT.601(TV)
- * in some active forks (which should not be used to author subs and serves
- * at most as a tool to check how now ancient VSFilters would have rendered the
- * subs), the automatically chosen colorspace may depend on the fork and the
- * videoprovider used and furthermore Aegisub likes to override
- * "YCbCr Matrix: None" with the autodetected space of a loaded video.
- * Supposedly some Aegisub versions had an option that "tries not to mangle the
- * colors". It was said that if the header is not set to BT.601(TV), the colors
- * were supposed not to be mangled, even if the header was not set to "None".
+ * Note that newer Aegisub versions (the main application to produce ASS
+ * subtitle scripts) have an option that tries not to mangle the colors. It
+ * is said that if the header is not set to BT.601(TV), the colors are
+ * supposed not to be mangled, even if the "YCbCr Matrix" header is not
+ * set to "None". In other words, the video colorspace as detected by
+ * Aegisub is the same as identified in the file header.
  *
  * In general, misinterpreting this header or not using it will lead to
  * slightly different subtitle colors, which can matter if the subtitle
  * attempts to match solid colored areas in the video.
- * It is recommended to stick to XySubFilter-like behaviour described above.
- * A highly motivated application may also expose options to users to  emulate
- * xy-VSFilter's resolution-depended guess or other (historic) mangling modes.
- * Completly ignoring the color mangling is likely to give bad results.
  *
  * Note that libass doesn't change colors based on this header. It
  * absolutely can't do that, because the video colorspace is required
- * in order to handle this as intended. API users must use the exposed
- * information to perform color mangling as described above.
+ * in order to handle this as intended by xy-vsfilter.
  */
 typedef enum ASS_YCbCrMatrix {
     YCBCR_DEFAULT = 0,  // Header missing
@@ -283,9 +254,6 @@ typedef struct ass_track {
     ASS_Library *library;
     ASS_ParserPriv *parser_priv;
 
-    int LayoutResX;  // overrides values from ass_set_storage_size and
-    int LayoutResY;  // also takes precendence over ass_set_pixel_aspect
-
     // New fields can be added here in new ABI-compatible library releases.
 } ASS_Track;
 
diff --git a/libass/ass_utils.c b/libass/ass_utils.c
index 2c7923d..a9db9be 100644
--- a/libass/ass_utils.c
+++ b/libass/ass_utils.c
@@ -23,6 +23,7 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include <stdint.h>
+#include <limits.h>
 #include <inttypes.h>
 
 #include "ass_library.h"
@@ -30,6 +31,48 @@
 #include "ass_utils.h"
 #include "ass_string.h"
 
+#if CONFIG_ASM && ARCH_X86
+
+#include "x86/cpuid.h"
+
+void ass_cpu_capabilities(bool *sse2, bool *avx2)
+{
+    *sse2 = false;
+    *avx2 = false;
+
+    if (!ass_has_cpuid())
+        return;
+
+    uint32_t eax = 0, ebx, ecx, edx;
+    ass_get_cpuid(&eax, &ebx, &ecx, &edx);
+    uint32_t max_leaf = eax;
+    bool avx = false;
+
+    if (max_leaf >= 1) {
+        eax = 1;
+        ass_get_cpuid(&eax, &ebx, &ecx, &edx);
+        if (edx & (1 << 26))  // SSE2
+            *sse2 = true;
+
+        if (ecx & (1 << 27) &&  // OSXSAVE
+            ecx & (1 << 28)) {  // AVX
+            uint32_t xcr0l, xcr0h;
+            ass_get_xgetbv(0, &xcr0l, &xcr0h);
+            if (xcr0l & (1 << 1) &&  // XSAVE for XMM
+                xcr0l & (1 << 2))    // XSAVE for YMM
+                    avx = true;
+        }
+    }
+
+    if (max_leaf >= 7) {
+        eax = 7;
+        ass_get_cpuid(&eax, &ebx, &ecx, &edx);
+        if (avx && ebx & (1 << 5))  // AVX2
+            *avx2 = true;
+    }
+}
+#endif // ASM
+
 // Fallbacks
 #ifndef HAVE_STRDUP
 char *ass_strdup_fallback(const char *str)
@@ -114,6 +157,187 @@ void *ass_try_realloc_array(void *ptr, size_t nmemb, size_t size)
     }
 }
 
+void skip_spaces(char **str)
+{
+    char *p = *str;
+    while ((*p == ' ') || (*p == '\t'))
+        ++p;
+    *str = p;
+}
+
+void rskip_spaces(char **str, char *limit)
+{
+    char *p = *str;
+    while ((p > limit) && ((p[-1] == ' ') || (p[-1] == '\t')))
+        --p;
+    *str = p;
+}
+
+static int read_digits(char **str, unsigned base, uint32_t *res)
+{
+    char *p = *str;
+    char *start = p;
+    uint32_t val = 0;
+
+    while (1) {
+        unsigned digit;
+        if (*p >= '0' && *p < FFMIN(base, 10) + '0')
+            digit = *p - '0';
+        else if (*p >= 'a' && *p < base - 10 + 'a')
+            digit = *p - 'a' + 10;
+        else if (*p >= 'A' && *p < base - 10 + 'A')
+            digit = *p - 'A' + 10;
+        else
+            break;
+        val = val * base + digit;
+        ++p;
+    }
+
+    *res = val;
+    *str = p;
+    return p != start;
+}
+
+/**
+ * \brief Convert a string to an integer reduced modulo 2**32
+ * Follows the rules for strtoul but reduces the number modulo 2**32
+ * instead of saturating it to 2**32 - 1.
+ */
+static int mystrtou32_modulo(char **p, unsigned base, uint32_t *res)
+{
+    // This emulates scanf with %d or %x format as it works on
+    // Windows, because that's what is used by VSFilter. In practice,
+    // scanf works the same way on other platforms too, but
+    // the standard leaves its behavior on overflow undefined.
+
+    // Unlike scanf and like strtoul, produce 0 for invalid inputs.
+
+    char *start = *p;
+    int sign = 1;
+
+    skip_spaces(p);
+
+    if (**p == '+')
+        ++*p;
+    else if (**p == '-')
+        sign = -1, ++*p;
+
+    if (base == 16 && !ass_strncasecmp(*p, "0x", 2))
+        *p += 2;
+
+    if (read_digits(p, base, res)) {
+        *res *= sign;
+        return 1;
+    } else {
+        *p = start;
+        return 0;
+    }
+}
+
+int32_t parse_alpha_tag(char *str)
+{
+    int32_t alpha = 0;
+
+    while (*str == '&' || *str == 'H')
+        ++str;
+
+    mystrtoi32(&str, 16, &alpha);
+    return alpha;
+}
+
+uint32_t parse_color_tag(char *str)
+{
+    int32_t color = 0;
+
+    while (*str == '&' || *str == 'H')
+        ++str;
+
+    mystrtoi32(&str, 16, &color);
+    return ass_bswap32((uint32_t) color);
+}
+
+uint32_t parse_color_header(char *str)
+{
+    uint32_t color = 0;
+    unsigned base;
+
+    if (!ass_strncasecmp(str, "&h", 2) || !ass_strncasecmp(str, "0x", 2)) {
+        str += 2;
+        base = 16;
+    } else
+        base = 10;
+
+    mystrtou32_modulo(&str, base, &color);
+    return ass_bswap32(color);
+}
+
+// Return a boolean value for a string
+char parse_bool(char *str)
+{
+    skip_spaces(&str);
+    return !ass_strncasecmp(str, "yes", 3) || strtol(str, NULL, 10) > 0;
+}
+
+int parse_ycbcr_matrix(char *str)
+{
+    skip_spaces(&str);
+    if (*str == '\0')
+        return YCBCR_DEFAULT;
+
+    char *end = str + strlen(str);
+    rskip_spaces(&end, str);
+
+    // Trim a local copy of the input that we know is safe to
+    // modify. The buffer is larger than any valid string + NUL,
+    // so we can simply chop off the rest of the input.
+    char buffer[16];
+    size_t n = FFMIN(end - str, sizeof buffer - 1);
+    memcpy(buffer, str, n);
+    buffer[n] = '\0';
+
+    if (!ass_strcasecmp(buffer, "none"))
+        return YCBCR_NONE;
+    if (!ass_strcasecmp(buffer, "tv.601"))
+        return YCBCR_BT601_TV;
+    if (!ass_strcasecmp(buffer, "pc.601"))
+        return YCBCR_BT601_PC;
+    if (!ass_strcasecmp(buffer, "tv.709"))
+        return YCBCR_BT709_TV;
+    if (!ass_strcasecmp(buffer, "pc.709"))
+        return YCBCR_BT709_PC;
+    if (!ass_strcasecmp(buffer, "tv.240m"))
+        return YCBCR_SMPTE240M_TV;
+    if (!ass_strcasecmp(buffer, "pc.240m"))
+        return YCBCR_SMPTE240M_PC;
+    if (!ass_strcasecmp(buffer, "tv.fcc"))
+        return YCBCR_FCC_TV;
+    if (!ass_strcasecmp(buffer, "pc.fcc"))
+        return YCBCR_FCC_PC;
+    return YCBCR_UNKNOWN;
+}
+
+/**
+ * \brief converts numpad-style align to align.
+ */
+int numpad2align(int val)
+{
+    if (val < -INT_MAX)
+        // Pick an alignment somewhat arbitrarily. VSFilter handles
+        // INT32_MIN as a mix of 1, 2 and 3, so prefer one of those values.
+        val = 2;
+    else if (val < 0)
+        val = -val;
+
+    int res = ((val - 1) % 3) + 1;  // horizontal alignment
+    if (val <= 3)
+        res |= VALIGN_SUB;
+    else if (val <= 6)
+        res |= VALIGN_CENTER;
+    else
+        res |= VALIGN_TOP;
+    return res;
+}
+
 void ass_msg(ASS_Library *priv, int lvl, const char *fmt, ...)
 {
     va_list va;
@@ -243,14 +467,14 @@ void ass_utf16be_to_utf8(char *dst, size_t dst_size, uint8_t *src, size_t src_si
 }
 
 /**
- * \brief find style by name the common way (\r matches differently)
+ * \brief find style by name
  * \param track track
  * \param name style name
  * \return index in track->styles
  * Returns 0 if no styles found => expects at least 1 style.
  * Parsing code always adds "Default" style in the beginning.
  */
-int ass_lookup_style(ASS_Track *track, char *name)
+int lookup_style(ASS_Track *track, char *name)
 {
     int i;
     // '*' seem to mean literally nothing;
@@ -271,3 +495,26 @@ int ass_lookup_style(ASS_Track *track, char *name)
             track, name, track->styles[i].Name);
     return i;
 }
+
+/**
+ * \brief find style by name as in \r
+ * \param track track
+ * \param name style name
+ * \param len style name length
+ * \return style in track->styles
+ * Returns NULL if no style has the given name.
+ */
+ASS_Style *lookup_style_strict(ASS_Track *track, char *name, size_t len)
+{
+    int i;
+    for (i = track->n_styles - 1; i >= 0; --i) {
+        if (strncmp(track->styles[i].Name, name, len) == 0 &&
+            track->styles[i].Name[len] == '\0')
+            return track->styles + i;
+    }
+    ass_msg(track->library, MSGL_WARN,
+            "[%p]: Warning: no style named '%.*s' found",
+            track, (int) len, name);
+    return NULL;
+}
+
diff --git a/libass/ass_utils.h b/libass/ass_utils.h
index a1beb76..3e239b5 100644
--- a/libass/ass_utils.h
+++ b/libass/ass_utils.h
@@ -27,7 +27,6 @@
 #include <string.h>
 #include <assert.h>
 #include <errno.h>
-#include <limits.h>
 #include <math.h>
 
 #include "ass.h"
@@ -51,6 +50,10 @@
 
 #define FEATURE_MASK(feat) (((uint32_t) 1) << (feat))
 
+#if CONFIG_ASM && ARCH_X86
+void ass_cpu_capabilities(bool *sse2, bool *avx2);
+#endif
+
 typedef struct {
     const char *str;
     size_t len;
@@ -90,6 +93,14 @@ void *ass_try_realloc_array(void *ptr, size_t nmemb, size_t size);
 #define ASS_REALLOC_ARRAY(ptr, count) \
     (errno = 0, (ptr) = ass_try_realloc_array(ptr, count, sizeof(*ptr)), !errno)
 
+void skip_spaces(char **str);
+void rskip_spaces(char **str, char *limit);
+int32_t parse_alpha_tag(char *str);
+uint32_t parse_color_tag(char *str);
+uint32_t parse_color_header(char *str);
+char parse_bool(char *str);
+int parse_ycbcr_matrix(char *str);
+int numpad2align(int val);
 unsigned ass_utf8_get_char(char **str);
 unsigned ass_utf8_put_char(char *dest, uint32_t ch);
 void ass_utf16be_to_utf8(char *dst, size_t dst_size, uint8_t *src, size_t src_size);
@@ -99,49 +110,12 @@ void ass_utf16be_to_utf8(char *dst, size_t dst_size, uint8_t *src, size_t src_si
     __attribute__ ((format (printf, 3, 4)))
 #endif
 void ass_msg(ASS_Library *priv, int lvl, const char *fmt, ...);
-int ass_lookup_style(ASS_Track *track, char *name);
+int lookup_style(ASS_Track *track, char *name);
+ASS_Style *lookup_style_strict(ASS_Track *track, char *name, size_t len);
 
 /* defined in ass_strtod.c */
 double ass_strtod(const char *string, char **endPtr);
 
-static inline void skip_spaces(char **str)
-{
-    char *p = *str;
-    while ((*p == ' ') || (*p == '\t'))
-        ++p;
-    *str = p;
-}
-
-static inline void rskip_spaces(char **str, char *limit)
-{
-    char *p = *str;
-    while ((p > limit) && ((p[-1] == ' ') || (p[-1] == '\t')))
-        --p;
-    *str = p;
-}
-
-/**
- * \brief converts numpad-style align to align.
- */
-static inline int numpad2align(int val)
-{
-    if (val < -INT_MAX)
-        // Pick an alignment somewhat arbitrarily. VSFilter handles
-        // INT32_MIN as a mix of 1, 2 and 3, so prefer one of those values.
-        val = 2;
-    else if (val < 0)
-        val = -val;
-
-    int res = ((val - 1) % 3) + 1;  // horizontal alignment
-    if (val <= 3)
-        res |= VALIGN_SUB;
-    else if (val <= 6)
-        res |= VALIGN_CENTER;
-    else
-        res |= VALIGN_TOP;
-    return res;
-}
-
 static inline size_t ass_align(size_t alignment, size_t s)
 {
     if (s > SIZE_MAX - (alignment - 1))
diff --git a/libass/c/c_be_blur.c b/libass/c/c_be_blur.c
index e2ee10f..7a61b6b 100644
--- a/libass/c/c_be_blur.c
+++ b/libass/c/c_be_blur.c
@@ -17,7 +17,7 @@
  */
 
 #include "config.h"
-#include "ass_compat.h"
+#include "..\ass_compat.h"
 
 #include <stddef.h>
 #include <stdint.h>
diff --git a/libass/c/c_blend_bitmaps.c b/libass/c/c_blend_bitmaps.c
index 95d189e..fc3fe9a 100644
--- a/libass/c/c_blend_bitmaps.c
+++ b/libass/c/c_blend_bitmaps.c
@@ -17,12 +17,12 @@
  */
 
 #include "config.h"
-#include "ass_compat.h"
+#include "..\ass_compat.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
-#include "ass_utils.h"
+#include "..\ass_utils.h"
 
 
 /**
diff --git a/libass/c/c_blur.c b/libass/c/c_blur.c
index 2c470f7..5ff0021 100644
--- a/libass/c/c_blur.c
+++ b/libass/c/c_blur.c
@@ -17,7 +17,7 @@
  */
 
 #include "config.h"
-#include "ass_compat.h"
+#include "..\ass_compat.h"
 
 #include <stddef.h>
 #include <stdint.h>
diff --git a/libass/c/c_rasterizer.c b/libass/c/c_rasterizer.c
index fe7fa9f..7c5b28b 100644
--- a/libass/c/c_rasterizer.c
+++ b/libass/c/c_rasterizer.c
@@ -17,11 +17,11 @@
  */
 
 #include "config.h"
-#include "ass_compat.h"
+#include "..\ass_compat.h"
 
 #include <assert.h>
 
-#include "ass_rasterizer.h"
+#include "..\ass_rasterizer.h"
 
 
 #define TILE_SIZE  16
diff --git a/libass/x86/be_blur.asm b/libass/x86/be_blur.asm
index 0b8b6b0..3f5bcb3 100644
--- a/libass/x86/be_blur.asm
+++ b/libass/x86/be_blur.asm
@@ -24,8 +24,8 @@ SECTION .text
 
 ;------------------------------------------------------------------------------
 ; BE_BLUR
-; void be_blur(uint8_t *buf, ptrdiff_t stride,
-;              size_t width, size_t height, uint16_t *tmp);
+; void be_blur(uint8_t *buf, intptr_t stride,
+;              intptr_t width, intptr_t height, uint16_t *tmp);
 ;------------------------------------------------------------------------------
 
 %macro BE_BLUR 0
@@ -230,7 +230,5 @@ cglobal be_blur, 5,7,8
 
 INIT_XMM sse2
 BE_BLUR
-INIT_XMM ssse3
-BE_BLUR
 INIT_YMM avx2
 BE_BLUR
diff --git a/libass/x86/blend_bitmaps.asm b/libass/x86/blend_bitmaps.asm
index cc4b81d..e5b8760 100644
--- a/libass/x86/blend_bitmaps.asm
+++ b/libass/x86/blend_bitmaps.asm
@@ -61,9 +61,9 @@ SECTION .text
 
 ;------------------------------------------------------------------------------
 ; ADD_BITMAPS
-; void add_bitmaps(uint8_t *dst, ptrdiff_t dst_stride,
-;                  const uint8_t *src, ptrdiff_t src_stride,
-;                  size_t width, size_t height);
+; void add_bitmaps(uint8_t *dst, intptr_t dst_stride,
+;                  uint8_t *src, intptr_t src_stride,
+;                  intptr_t width, intptr_t height);
 ;------------------------------------------------------------------------------
 
 %macro ADD_BITMAPS 0
@@ -114,9 +114,9 @@ ADD_BITMAPS
 
 ;------------------------------------------------------------------------------
 ; IMUL_BITMAPS
-; void imul_bitmaps(uint8_t *dst, ptrdiff_t dst_stride,
-;                   const uint8_t *src, ptrdiff_t src_stride,
-;                   size_t width, size_t height);
+; void imul_bitmaps(uint8_t *dst, intptr_t dst_stride,
+;                   uint8_t *src, intptr_t src_stride,
+;                   intptr_t width, intptr_t height);
 ;------------------------------------------------------------------------------
 
 %macro IMUL_BITMAPS 0
@@ -197,10 +197,10 @@ IMUL_BITMAPS
 
 ;------------------------------------------------------------------------------
 ; MUL_BITMAPS
-; void mul_bitmaps(uint8_t *dst, ptrdiff_t dst_stride,
-;                  const uint8_t *src1, ptrdiff_t src1_stride,
-;                  const uint8_t *src2, ptrdiff_t src2_stride,
-;                  size_t width, size_t height);
+; void mul_bitmaps(uint8_t *dst, intptr_t dst_stride,
+;                  uint8_t *src1, intptr_t src1_stride,
+;                  uint8_t *src2, intptr_t src2_stride,
+;                  intptr_t width, intptr_t height);
 ;------------------------------------------------------------------------------
 
 %macro MUL_BITMAPS 0
diff --git a/libass/x86/blur.asm b/libass/x86/blur.asm
index 90ecbc9..db9dfe8 100644
--- a/libass/x86/blur.asm
+++ b/libass/x86/blur.asm
@@ -38,13 +38,13 @@ dwords_lomask: times 8 dd 0xFFFF
 SECTION .text
 
 ;------------------------------------------------------------------------------
-; STRIPE_UNPACK 1:suffix
+; STRIPE_UNPACK
 ; void stripe_unpack(int16_t *dst, const uint8_t *src, ptrdiff_t src_stride,
-;                    size_t width, size_t height);
+;                    uintptr_t width, uintptr_t height);
 ;------------------------------------------------------------------------------
 
-%macro STRIPE_UNPACK 1
-cglobal stripe_unpack%1, 5,6,3
+%macro STRIPE_UNPACK 0
+cglobal stripe_unpack, 5,6,3
     lea r3, [2 * r3 + mmsize - 1]
     and r3, -mmsize
     mov r5, r3
@@ -109,18 +109,18 @@ cglobal stripe_unpack%1, 5,6,3
 %endmacro
 
 INIT_XMM sse2
-STRIPE_UNPACK 16
+STRIPE_UNPACK
 INIT_YMM avx2
-STRIPE_UNPACK 32
+STRIPE_UNPACK
 
 ;------------------------------------------------------------------------------
-; STRIPE_PACK 1:suffix
+; STRIPE_PACK
 ; void stripe_pack(uint8_t *dst, ptrdiff_t dst_stride, const int16_t *src,
-;                  size_t width, size_t height);
+;                  uintptr_t width, uintptr_t height);
 ;------------------------------------------------------------------------------
 
-%macro STRIPE_PACK 1
-cglobal stripe_pack%1, 5,7,5
+%macro STRIPE_PACK 0
+cglobal stripe_pack, 5,7,5
     lea r3, [2 * r3 + mmsize - 1]
     mov r6, r1
     and r3, -mmsize
@@ -199,9 +199,9 @@ cglobal stripe_pack%1, 5,7,5
 %endmacro
 
 INIT_XMM sse2
-STRIPE_PACK 16
+STRIPE_PACK
 INIT_YMM avx2
-STRIPE_PACK 32
+STRIPE_PACK
 
 ;------------------------------------------------------------------------------
 ; LOAD_LINE 1:m_dst, 2:base, 3:max, 4:zero_offs,
@@ -247,20 +247,20 @@ STRIPE_PACK 32
 %endmacro
 
 ;------------------------------------------------------------------------------
-; SHRINK_HORZ 1:suffix
+; SHRINK_HORZ
 ; void shrink_horz(int16_t *dst, const int16_t *src,
-;                  size_t src_width, size_t src_height);
+;                  uintptr_t src_width, uintptr_t src_height);
 ;------------------------------------------------------------------------------
 
-%macro SHRINK_HORZ 1
+%macro SHRINK_HORZ 0
 %if ARCH_X86_64
-cglobal shrink_horz%1, 4,9,9
+cglobal shrink_horz, 4,9,9
     DECLARE_REG_TMP 8
 %else
 %if !PIC
-cglobal shrink_horz%1, 4,7,8
+cglobal shrink_horz, 4,7,8
 %else
-cglobal shrink_horz%1, 4,7,8, -mmsize
+cglobal shrink_horz, 4,7,8, -mmsize
     pxor m0, m0
     mova [rsp], m0
 %endif
@@ -393,25 +393,23 @@ cglobal shrink_horz%1, 4,7,8, -mmsize
 %endmacro
 
 INIT_XMM sse2
-SHRINK_HORZ 16
-INIT_XMM ssse3
-SHRINK_HORZ 16
+SHRINK_HORZ
 INIT_YMM avx2
-SHRINK_HORZ 32
+SHRINK_HORZ
 
 ;------------------------------------------------------------------------------
-; SHRINK_VERT 1:suffix
+; SHRINK_VERT
 ; void shrink_vert(int16_t *dst, const int16_t *src,
-;                  size_t src_width, size_t src_height);
+;                  uintptr_t src_width, uintptr_t src_height);
 ;------------------------------------------------------------------------------
 
-%macro SHRINK_VERT 1
+%macro SHRINK_VERT 0
 %if ARCH_X86_64
-cglobal shrink_vert%1, 4,7,9
+cglobal shrink_vert, 4,7,9
 %elif !PIC
-cglobal shrink_vert%1, 4,7,8
+cglobal shrink_vert, 4,7,8
 %else
-cglobal shrink_vert%1, 4,7,8, -mmsize
+cglobal shrink_vert, 4,7,8, -mmsize
     pxor m0, m0
     mova [rsp], m0
 %endif
@@ -488,25 +486,25 @@ cglobal shrink_vert%1, 4,7,8, -mmsize
 %endmacro
 
 INIT_XMM sse2
-SHRINK_VERT 16
+SHRINK_VERT
 INIT_YMM avx2
-SHRINK_VERT 32
+SHRINK_VERT
 
 ;------------------------------------------------------------------------------
-; EXPAND_HORZ 1:suffix
+; EXPAND_HORZ
 ; void expand_horz(int16_t *dst, const int16_t *src,
-;                  size_t src_width, size_t src_height);
+;                  uintptr_t src_width, uintptr_t src_height);
 ;------------------------------------------------------------------------------
 
-%macro EXPAND_HORZ 1
+%macro EXPAND_HORZ 0
 %if ARCH_X86_64
-cglobal expand_horz%1, 4,9,5
+cglobal expand_horz, 4,9,5
     DECLARE_REG_TMP 8
 %else
 %if !PIC
-cglobal expand_horz%1, 4,7,5
+cglobal expand_horz, 4,7,5
 %else
-cglobal expand_horz%1, 4,7,5, -mmsize
+cglobal expand_horz, 4,7,5, -mmsize
     pxor m0, m0
     mova [rsp], m0
 %endif
@@ -636,23 +634,21 @@ cglobal expand_horz%1, 4,7,5, -mmsize
 %endmacro
 
 INIT_XMM sse2
-EXPAND_HORZ 16
-INIT_XMM ssse3
-EXPAND_HORZ 16
+EXPAND_HORZ
 INIT_YMM avx2
-EXPAND_HORZ 32
+EXPAND_HORZ
 
 ;------------------------------------------------------------------------------
-; EXPAND_VERT 1:suffix
+; EXPAND_VERT
 ; void expand_vert(int16_t *dst, const int16_t *src,
-;                  size_t src_width, size_t src_height);
+;                  uintptr_t src_width, uintptr_t src_height);
 ;------------------------------------------------------------------------------
 
-%macro EXPAND_VERT 1
+%macro EXPAND_VERT 0
 %if ARCH_X86_64 || !PIC
-cglobal expand_vert%1, 4,7,5
+cglobal expand_vert, 4,7,5
 %else
-cglobal expand_vert%1, 4,7,5, -mmsize
+cglobal expand_vert, 4,7,5, -mmsize
     pxor m0, m0
     mova [rsp], m0
 %endif
@@ -710,9 +706,9 @@ cglobal expand_vert%1, 4,7,5, -mmsize
 %endmacro
 
 INIT_XMM sse2
-EXPAND_VERT 16
+EXPAND_VERT
 INIT_YMM avx2
-EXPAND_VERT 32
+EXPAND_VERT
 
 ;------------------------------------------------------------------------------
 ; LOAD_MULTIPLIER 1:n, 2:m_mul, 3:src, 4:tmp
@@ -802,21 +798,21 @@ EXPAND_VERT 32
 %endmacro
 
 ;------------------------------------------------------------------------------
-; BLUR_HORZ 1:radius 2:suffix
+; BLUR_HORZ 1:radius
 ; void blurN_horz(int16_t *dst, const int16_t *src,
-;                 size_t src_width, size_t src_height,
+;                 uintptr_t src_width, uintptr_t src_height,
 ;                 const int16_t *param);
 ;------------------------------------------------------------------------------
 
-%macro BLUR_HORZ 2
+%macro BLUR_HORZ 1
 %if ARCH_X86_64
     %assign %%narg 9 + (%1 + 1) / 2
-cglobal blur%1_horz%2, 5,8,%%narg
+cglobal blur%1_horz, 5,8,%%narg
 %else
 %if !PIC
-cglobal blur%1_horz%2, 5,7,8
+cglobal blur%1_horz, 5,7,8
 %else
-cglobal blur%1_horz%2, 5,7,8, -mmsize
+cglobal blur%1_horz, 5,7,8, -mmsize
     pxor m0, m0
     mova [rsp], m0
 %endif
@@ -968,39 +964,33 @@ cglobal blur%1_horz%2, 5,7,8, -mmsize
 %endmacro
 
 INIT_XMM sse2
-BLUR_HORZ 4,16
-BLUR_HORZ 5,16
-BLUR_HORZ 6,16
-BLUR_HORZ 7,16
-BLUR_HORZ 8,16
-INIT_XMM ssse3
-BLUR_HORZ 4,16
-BLUR_HORZ 5,16
-BLUR_HORZ 6,16
-BLUR_HORZ 7,16
-BLUR_HORZ 8,16
+BLUR_HORZ 4
+BLUR_HORZ 5
+BLUR_HORZ 6
+BLUR_HORZ 7
+BLUR_HORZ 8
 INIT_YMM avx2
-BLUR_HORZ 4,32
-BLUR_HORZ 5,32
-BLUR_HORZ 6,32
-BLUR_HORZ 7,32
-BLUR_HORZ 8,32
+BLUR_HORZ 4
+BLUR_HORZ 5
+BLUR_HORZ 6
+BLUR_HORZ 7
+BLUR_HORZ 8
 
 ;------------------------------------------------------------------------------
-; BLUR_VERT 1:radius 2:suffix
+; BLUR_VERT 1:radius
 ; void blurN_vert(int16_t *dst, const int16_t *src,
-;                 size_t src_width, size_t src_height,
+;                 uintptr_t src_width, uintptr_t src_height,
 ;                 const int16_t *param);
 ;------------------------------------------------------------------------------
 
-%macro BLUR_VERT 2
+%macro BLUR_VERT 1
 %if ARCH_X86_64
     %assign %%narg 7 + (%1 + 1) / 2
-cglobal blur%1_vert%2, 5,7,%%narg
+cglobal blur%1_vert, 5,7,%%narg
 %elif !PIC
-cglobal blur%1_vert%2, 5,7,8
+cglobal blur%1_vert, 5,7,8
 %else
-cglobal blur%1_vert%2, 5,7,8, -mmsize
+cglobal blur%1_vert, 5,7,8, -mmsize
     pxor m0, m0
     mova [rsp], m0
 %endif
@@ -1071,14 +1061,14 @@ cglobal blur%1_vert%2, 5,7,8, -mmsize
 %endmacro
 
 INIT_XMM sse2
-BLUR_VERT 4,16
-BLUR_VERT 5,16
-BLUR_VERT 6,16
-BLUR_VERT 7,16
-BLUR_VERT 8,16
+BLUR_VERT 4
+BLUR_VERT 5
+BLUR_VERT 6
+BLUR_VERT 7
+BLUR_VERT 8
 INIT_YMM avx2
-BLUR_VERT 4,32
-BLUR_VERT 5,32
-BLUR_VERT 6,32
-BLUR_VERT 7,32
-BLUR_VERT 8,32
+BLUR_VERT 4
+BLUR_VERT 5
+BLUR_VERT 6
+BLUR_VERT 7
+BLUR_VERT 8
diff --git a/libass/x86/rasterizer.asm b/libass/x86/rasterizer.asm
index 3189115..f9853e7 100644
--- a/libass/x86/rasterizer.asm
+++ b/libass/x86/rasterizer.asm
@@ -844,9 +844,6 @@ cglobal fill_generic_tile%2, 0,7,8, -alloc_size
 INIT_XMM sse2
 FILL_GENERIC_TILE 4,16
 FILL_GENERIC_TILE 5,32
-INIT_XMM ssse3
-FILL_GENERIC_TILE 4,16
-FILL_GENERIC_TILE 5,32
 INIT_YMM avx2
 FILL_GENERIC_TILE 4,16
 FILL_GENERIC_TILE 5,32
 